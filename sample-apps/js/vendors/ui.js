/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
angular.module('enspire.ui', [
    'ng',
    'ngAnimate',
    'ngMessages',
    'ngSanitize',
    'enspire.ui.core',
    'enspire.ui.core.filters',
    'enspire.ui.components.action',
    'enspire.ui.components.adapter',
    'enspire.ui.components.alert',
    'enspire.ui.components.anchorScroll',
    'enspire.ui.components.api',
    'enspire.ui.components.auth',
    'enspire.ui.components.autocomplete',
    'enspire.ui.components.autofocus',
    'enspire.ui.components.body',
    'enspire.ui.components.button',
    'enspire.ui.components.buttonGroup',
    'enspire.ui.components.checklistModel',
    'enspire.ui.components.clipboard',
    'enspire.ui.components.collapse',
    'enspire.ui.components.collection',
    'enspire.ui.components.collectionRepeat',
    'enspire.ui.components.colorwheel',
    'enspire.ui.components.content',
    'enspire.ui.components.control',
    'enspire.ui.components.correlation',
    'enspire.ui.components.datepicker',
    'enspire.ui.components.dnd',
    'enspire.ui.components.draggable',
    'enspire.ui.components.enter',
    'enspire.ui.components.error',
    'enspire.ui.components.field',
    'enspire.ui.components.fileUpload',
    'enspire.ui.components.float',
    'enspire.ui.components.footer',
    'enspire.ui.components.form',
    'enspire.ui.components.growl',
    'enspire.ui.components.header',
    'enspire.ui.components.icon',
    'enspire.ui.components.include',
    'enspire.ui.components.input',
    'enspire.ui.components.inputTags',
    'enspire.ui.components.keyEvent',
    'enspire.ui.components.label',
    'enspire.ui.components.listObject',
    'enspire.ui.components.loader',
    'enspire.ui.components.menu',
    'enspire.ui.components.modal',
    'enspire.ui.components.msg',
    'enspire.ui.components.nav',
    'enspire.ui.components.objectDiff',
    'enspire.ui.components.panel',
    'enspire.ui.components.passwordCheck',
    'enspire.ui.components.popover',
    'enspire.ui.components.progress',
    'enspire.ui.components.quote',
    'enspire.ui.components.screen',
    'enspire.ui.components.scrollbar',
    'enspire.ui.components.section',
    'enspire.ui.components.sortable',
    'enspire.ui.components.src',
    'enspire.ui.components.subheader',
    'enspire.ui.components.tabs',
    'enspire.ui.components.time',
    'enspire.ui.components.timeDuration',
    'enspire.ui.components.title',
    'enspire.ui.components.tooltip',
    'enspire.ui.components.touch',
    'enspire.ui.components.tree',
    'enspire.ui.components.win',
    'ngFileUpload',
    'angular-growl',
    'enspire.ui.components.multiSelect',
    'enspire.ui.components.objectTree',
    'enspire.ui.components.virtualRepeat'
]);
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';
  /**
   * @ngdoc module
   * @name enspire.ui.core
   *
   * @description
   * enspire.ui's core services module.
   *
   */
    angular.module('enspire.ui.core',['ui.router'])
        .run(enCoreInitialize)
        .factory('$enConfig', enConfigFactory)
        .config([
            '$provide', function($provide) {
                return $provide.decorator('$rootScope', ['$delegate', function($delegate) {
                        $delegate.$safeApply = function(fn) {
                            var phase = $delegate.$$phase;
                            if (phase === "$apply" || phase === "$digest") {
                                if (fn && typeof fn === 'function') {
                                    fn();
                                }
                            } else {
                                $delegate.$apply(fn);
                            }
                        };
                        return $delegate;
                    }
                ]);
            }
        ]);

    /**
     * Initialization function that validates environment requirements.
     */
    function enCoreInitialize($rootScope,$state,$stateParams){
        if(typeof Hammer === 'undefined'){
            throw new Error('enspire.ui requires HammerJS to be preloaded.');
        }

        $rootScope.$state = $state;
        $rootScope.$stateParams = $stateParams;


        window.navigator.standalone && document.body.setAttribute('standalone','yes');
    }
    enCoreInitialize.$inject = ["$rootScope", "$state", "$stateParams"];


/**
* @ngdoc service
* @name $enConfig
* @module enspire.ui.core
*
* @usage
* <hljs lang="js">
*   $enConfig[propertyName];
* </hljs>
*
* @description
* Sets the enspire.ui config variables.
*
* @property MEDIA {object} - An object containing the supported media sizes, XS, SM, MD, LG.
*
* <hljs lang="js">
*   $enConfig.MEDIA[XS|SM|MD|LG];
* </hljs>
*
* @property APP {object} - An object containing the supported media sizes, XS, SM, MD, LG.
*
* @property KEY_CODE {object} - An object containing the supported media sizes, XS, SM, MD, LG.
*
*/
    function enConfigFactory() {
        return {
           MEDIA       : {
                XS: 380,
                SM: 768,
                MD: 1024,
                LG: 1280
            },
            APP: {
                navPosition: 'top'  //top, left, right
            },
            KEY_CODE: {
                COMMA       : 188,
                ENTER       : 13,
                ESCAPE      : 27,
                SPACE       : 32,
                PAGE_UP     : 33,
                PAGE_DOWN   : 34,
                END         : 35,
                HOME        : 36,
                LEFT_ARROW  : 37,
                UP_ARROW    : 38,
                RIGHT_ARROW : 39,
                DOWN_ARROW  : 40,
                TAB         : 9,
                BACKSPACE   : 8,
                DELETE      : 46
            }
        };
    }
})();




/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
angular.module('enspire.ui.core.filters',[]);

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';

/**
 * @ngdoc service
 * @name $uuid
 * @module enspire.ui.core
 *
 * @returns {string} Generated UUID.
 *
 * @description
 * The $uuid() factory will return a generated UUID string separated by a hyphen (-). To change the separator that is used, simply supply the character you want to use as the 1st argument in the call. Ex: $uuid('_').
 */

    angular.module('enspire.ui.core')
        .factory('$uuid', UUIDFactory);

    function UUIDFactory(){
        return function (sep) {
            if(!sep){
                sep = '-';
            }
            var s = [];
            var hexDigits = '0123456789abcdef';
            for (var i = 0; i < 36; i++) {
                s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
            }
            s[14] = '4';
            s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
            s[8] = s[13] = s[18] = s[23] = sep;
            return s.join('');
        };
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
    /*!--------------------------------------------------------------------
     JAVASCRIPT "Outdated Browser"
     Version:    1.1.0 - 2014
     author:     Burocratik
     website:    http://www.burocratik.com
     * @preserve
     -----------------------------------------------------------------------*/
    var outdatedBrowser = function(options) {

        //Variable definition (before ajax)
        var outdated = document.getElementById("outdated");

        // Default settings
        this.defaultOpts = {
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex',
            languagePath: ''
        };

        if (options) {
            //assign css3 property to IE browser version
            if (options.lowerThan === 'IE8' || options.lowerThan === 'borderSpacing') {
                options.lowerThan = 'borderSpacing';
            } else if (options.lowerThan === 'IE9' || options.lowerThan === 'boxShadow') {
                options.lowerThan = 'boxShadow';
            } else if (options.lowerThan === 'IE10' || options.lowerThan === 'transform' || options.lowerThan === '' || typeof options.lowerThan === "undefined") {
                options.lowerThan = 'transform';
            } else if (options.lowerThan === 'IE11' || options.lowerThan === 'borderImage') {
                options.lowerThan = 'borderImage';
            }
            //all properties
            this.defaultOpts.bgColor = options.bgColor;
            this.defaultOpts.color = options.color;
            this.defaultOpts.lowerThan = options.lowerThan;
            this.defaultOpts.languagePath = options.languagePath;

            bkgColor = this.defaultOpts.bgColor;
            txtColor = this.defaultOpts.color;
            cssProp = this.defaultOpts.lowerThan;
            languagePath = this.defaultOpts.languagePath;
        } else {
            bkgColor = this.defaultOpts.bgColor;
            txtColor = this.defaultOpts.color;
            cssProp = this.defaultOpts.lowerThan;
            languagePath = this.defaultOpts.languagePath;
        } //end if options


        //Define opacity and fadeIn/fadeOut functions
        var done = true;

        function function_opacity(opacity_value) {
            outdated.style.opacity = opacity_value / 100;
            outdated.style.filter = 'alpha(opacity=' + opacity_value + ')';
        }

        // function function_fade_out(opacity_value) {
        //     function_opacity(opacity_value);
        //     if (opacity_value == 1) {
        //         outdated.style.display = 'none';
        //         done = true;
        //     }
        // }

        function function_fade_in(opacity_value) {
            function_opacity(opacity_value);
            if (opacity_value === 1) {
                outdated.style.display = 'block';
            }
            if (opacity_value === 100) {
                done = true;
            }
        }

        //check if element has a particular class
        // function hasClass(element, cls) {
        //     return (' ' + element.className + ' ').indexOf(' ' + cls + ' ') > -1;
        // }

        var supports = ( function() {
            var div = document.createElement('div');
            var vendors = 'Khtml Ms O Moz Webkit'.split(' ');
            var len = vendors.length;

            return function(prop) {
                if (prop in div.style){
                    return true;
                }

                prop = prop.replace(/^[a-z]/, function(val) {
                    return val.toUpperCase();
                });

                while (len--) {
                    if (vendors[len] + prop in div.style) {
                        return true;
                    }
                }
                return false;
            };
        } )();

        //if browser does not supports css3 property (transform=default), if does > exit all this
        if (!supports('' + cssProp + '')) {
            if (done && outdated.style.opacity !== '1') {
                done = false;
                for (var i = 1; i <= 100; i++) {
                    setTimeout(( function(x) {
                        return function() {
                            function_fade_in(x);
                        };
                    })(i), i * 8);
                }
            }
        } else {
            return;
        } //end if

        //Check AJAX Options: if languagePath == '' > use no Ajax way, html is needed inside <div id="outdated">
        if (languagePath && (languagePath === ' ' || languagePath.length == 0)) {
            startStylesAndEvents();
        } else {
            grabFile(languagePath);
        }

        //events and colors
        function startStylesAndEvents() {
            var btnClose = document.getElementById("btnCloseUpdateBrowser");
            var btnUpdate = document.getElementById("btnUpdateBrowser");

            //check settings attributes
            outdated.style.backgroundColor = bkgColor;
            //way too hard to put !important on IE6
            outdated.style.color = txtColor;
            outdated.children[0].style.color = txtColor;
            outdated.children[1].style.color = txtColor;

            //check settings attributes
            btnUpdate.style.color = txtColor;
            // btnUpdate.style.borderColor = txtColor;
            if (btnUpdate.style.borderColor) {
                btnUpdate.style.borderColor = txtColor;
            }
            btnClose.style.color = txtColor;

            //close button
            btnClose.onmousedown = function() {
                outdated.style.display = 'none';
                return false;
            };

            //Override the update button color to match the background color
            btnUpdate.onmouseover = function() {
                this.style.color = bkgColor;
                this.style.backgroundColor = txtColor;
            };
            btnUpdate.onmouseout = function() {
                this.style.color = txtColor;
                this.style.backgroundColor = bkgColor;
            };
        } //end styles and events


        // IF AJAX with request ERROR > insert english default
        var ajaxEnglishDefault = '<h6>Your browser is out-of-date!</h6>'
            + '<p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>'
            + '<p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>';


        //** AJAX FUNCTIONS - Bulletproof Ajax by Jeremy Keith **
        function getHTTPObject() {
            var xhr = false;
            if (window.XMLHttpRequest) {
                xhr = new XMLHttpRequest();
            } else if (window.ActiveXObject) {
                try {
                    xhr = new ActiveXObject("Msxml2.XMLHTTP");
                } catch ( e ) {
                    try {
                        xhr = new ActiveXObject("Microsoft.XMLHTTP");
                    } catch ( e ) {
                        xhr = false;
                    }
                }
            }
            return xhr;
        }//end function

        function grabFile(file) {
            var request = getHTTPObject();
            if (request) {
                request.onreadystatechange = function() {
                    displayResponse(request);
                };
                request.open("GET", file, true);
                request.send(null);
            }
            return false;
        } //end grabFile

        function displayResponse(request) {
            var insertContentHere = document.getElementById("outdated");
            if (request.readyState == 4) {
                if (request.status == 200 || request.status == 304) {
                    insertContentHere.innerHTML = request.responseText;
                } else {
                    insertContentHere.innerHTML = ajaxEnglishDefault;
                }
                startStylesAndEvents();
            }
            return false;
        }//end displayResponse

    ////////END of outdatedBrowser function
    };

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.core')
        .factory('$uom', ComponentFactory);

    /**
     * @ngdoc service
     * @name $uom
     * @module enspire.ui.core
     *
     * @description
     * Unit of measurement conversion service.
     */

    var conversions = {
        mm: {
            mm : 1,
            cm : 10,
            m  : 1000,
            km : 1000000,
            in : 25.4,
            ft : 304.8,
            yd : 914.4,
            mi : 1609344
        },
        cm: {
            mm : 0.1,
            cm : 1,
            m  : 100,
            km : 100000,
            in : 2.54,
            ft : 30.48,
            yd : 91.44,
            mi : 160934
        },
        m: {
            mm : 0.001,
            cm : 0.01,
            m  : 1,
            km : 1000,
            in : 0.0254,
            ft : 0.3048,
            yd : 0.9144,
            mi : 1609.344
        },
        km: {
            mm : 0.000001,
            cm : 0.00001,
            m  : 0.001,
            km : 1,
            in : 0.0000254,
            ft : 0.0003048,
            yd : 0.0009144,
            mi : 1.609344
        },
        in: {
            mm : 0.0393701,
            cm : 0.393701,
            m  : 39.3701,
            km : 39370.1,
            in : 1,
            ft : 12,
            yd : 36,
            mi : 63360
        },
        ft: {
            mm : 0.00328084,
            cm : 0.0328084,
            m  : 3.28084,
            km : 3280.84,
            in : 0.08333333333333,
            ft : 1,
            yd : 3,
            mi : 5280
        },
        yd: {
            mm : 0.00109361333333,
            cm : 0.01093613333333,
            m  : 1.09361333333333,
            km : 1093.61333333333333,
            in : 0.02777777777778,
            ft : 0.33333333333333,
            yd : 1,
            mi : 1760
        },
        mi: {
            mm : 0.00000062137121,
            cm : 0.00000621371212,
            m  : 0.00062137121212,
            km : 0.62137121212121,
            in : 0.00001578282828,
            ft : 0.00018939393939,
            yd : 0.00056818181818,
            mi : 1
        }
    };

    function convert(val,from,to){
            var num = Number(val);
            return num * conversions[to.toLowerCase()][from.toLowerCase()];
        }


    function ComponentFactory(){

        var UOM = {
            convert: convert
        };

        return UOM;

        /**
         * @ngdoc method
         * @name $uom#convert
         *
         * @description
         * Takes 3 arguments and converts the numeric value (value) that is in (fromUom) into (returnValue) (toUom)
         *
         * @param {number} value The numeric value to be converted.
         * @param {string} fromUom The units the value is currently in.
         * @param {string} toUom The units you want to convert the value to.
         *
         * @returns {number} Returns the converted numerical value.
         */

        function convert(val,from,to){
            var num = Number(val);
            return num * conversions[to.toLowerCase()][from.toLowerCase()];
        }
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';
    /**
     * @ngdoc filter
     * @name blank
     * @module enspire.ui.core
     *
     * @description
     * Formats a value to display a placeholder when a value is null or undefined
     *
     * ## Usage
     * ### HTML Template Binding
     * <hljs lang="html">
     *   {{ expression | blank[:placeholder] }}
     * </hljs>
     *
     * ### Javascript
     * <hljs lang="javascript">
     *   $filter('blank')(expression[, placeholder]);
     * </hljs>
     *
     * @usage
     *
     * @param {expression} expression   The expression to filter against.
     * @param {string=} placeholder   The string/number displayed when the result of `expression` is `null` or `undefined`.
     *
     * @returns {string} Formated placeholder string or empty string if no placeholder argument was passed.
     */

    angular.module('enspire.ui.core')
        .filter('blank', FilterFunction);

    function FilterFunction(){
        return function (input, placeholder) {
            if (input !==0 && !input) {
                return placeholder || '';
            }
            return input;
        };
    }

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';
    angular.module('enspire.ui.core')
        .filter('lt', FilterFunction);

    function FilterFunction(){
        return function(value, num) {
            return value < num;
       }
    }
})();

(function () {
    'use strict';
    angular.module('enspire.ui.core')
        .filter('gt', FilterFunction);

    function FilterFunction(){
        return function(value, num) {
            return value > num;
       }
    }
})();

(function () {
    'use strict';
    angular.module('enspire.ui.core')
        .filter('lteq', FilterFunction);

    function FilterFunction(){
        return function(value, num) {
            return value <= num;
       }
    }
})();

(function () {
    'use strict';
    angular.module('enspire.ui.core')
        .filter('gteq', FilterFunction);

    function FilterFunction(){
        return function(value, num) {
            return value >= num;
       }
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';
    /**
     * @ngdoc filter
     * @name blank
     * @module enspire.ui.core
     *
     * @description
     * Formats a value to display a placeholder when a value is null or undefined
     *
     * ## Usage
     * ### HTML Template Binding
     * <hljs lang="html">
     *   {{ expression | blank[:placeholder] }}
     * </hljs>
     *
     * ### Javascript
     * <hljs lang="javascript">
     *   $filter('blank')(expression[, placeholder]);
     * </hljs>
     *
     * @usage
     *
     * @param {expression} expression   The expression to filter against.
     * @param {string=} placeholder   The string/number displayed when the result of `expression` is `null` or `undefined`.
     *
     * @returns {string} Formated placeholder string or empty string if no placeholder argument was passed.
     */

    angular.module('enspire.ui.core')
        .filter('blank', FilterFunction);

    function FilterFunction(){
        return function (input, placeholder) {
            if (input !==0 && !input) {
                return placeholder || '';
            }
            return input;
        };
    }

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * The MIT License
 *
 * The code has been modified and altered from the original code authored by Olivier Louvignes.
 *
 * Copyright (c) 2012-2014 Olivier Louvignes http://olouv.com
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
 *  (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,
 *  publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 *  subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 *  THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
 *  OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
 *  OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

(function() {
        'use strict';

        angular.module('enspire.ui.core')
            .factory('$enDimensions', DimensionsFactory);

        /**
         * @ngdoc service
         * @name $enDimensions
         * @module enspire.ui.core
         *
         * @description
         * A toolbox of element positioning methods.
         */

        function DimensionsFactory($document, $window) {
            var jqLite = angular.element;
            var fn = {};

            /*
             * Test the element nodeName
             * @ param element
             * @ param name
             */
            var nodeName = fn.nodeName = function(element, name) {
                return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();
            };

            /*
             * Returns the element computed style
             * @ param element
             * @ param prop
             * @ param extra
             */
            fn.css = function(element, prop, extra) {
                var value;
                if (element.currentStyle) { //IE
                    value = element.currentStyle[prop];
                } else if (window.getComputedStyle) {
                    value = window.getComputedStyle(element)[prop];
                } else {
                    value = element.style[prop];
                }
                return extra === true ? parseFloat(value) || 0 : value;
            };

            /*
             * Provides read-only equivalent of jQuery's offset function:
             * @ url http://api.jquery.com/offset/
             * @ param element
             */
            fn.offset = function(element) {
                var boxRect     = element.getBoundingClientRect();
                var docElement  = element.ownerDocument;
                var width       = boxRect.width || element.offsetWidth;
                var height      = boxRect.height || element.offsetHeight;
                var top         = boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0);
                var left        = boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0);
                return {
                    'width' : width,
                    'height': height,
                    'top'   : top,
                    'left'  : left
                };
            };

            /*
             * Provides set equivalent of jQuery's offset function:
             * @ url http://api.jquery.com/offset/
             * @ param element
             * @ param options
             * @ param i
             */
            fn.setOffset = function(element, options, i) {
                var curPosition,
                    curLeft,
                    curCSSTop,
                    curTop,
                    curOffset,
                    curCSSLeft,
                    calculatePosition,
                    position = fn.css(element, 'position'),
                    curElem = angular.element(element),
                    props = {};

                // Set position first, in-case top/left are set even on static elem
                if (position === 'static') {
                    element.style.position = 'relative';
                }

                curOffset = fn.offset(element);
                curCSSTop = fn.css(element, 'top');
                curCSSLeft = fn.css(element, 'left');
                calculatePosition = (position === 'absolute' || position === 'fixed') &&
                    (curCSSTop + curCSSLeft).indexOf('auto') > -1;

                // Need to be able to calculate position if either
                // top or left is auto and position is either absolute or fixed
                if (calculatePosition) {
                    curPosition = fn.position(element);
                    curTop = curPosition.top;
                    curLeft = curPosition.left;
                } else {
                    curTop = parseFloat(curCSSTop) || 0;
                    curLeft = parseFloat(curCSSLeft) || 0;
                }

                if (angular.isFunction(options)) {
                    options = options.call(element, i, curOffset);
                }

                if (options.top !== null) {
                    props.top = (options.top - curOffset.top) + curTop;
                }
                if (options.left !== null) {
                    props.left = (options.left - curOffset.left) + curLeft;
                }

                if ('using' in options) {
                    options.using.call(curElem, props);
                } else {
                    curElem.css({
                        top: props.top + 'px',
                        left: props.left + 'px'
                    });
                }
            };

            /*
             * Provides read-only equivalent of jQuery's position function
             * @ url http://api.jquery.com/offset/
             * @ param element
             */
            fn.position = function(element) {

                var offsetParentRect = {
                        top: 0,
                        left: 0
                    },
                    offsetParentElement,
                    offset;

                // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
                if (fn.css(element, 'position') === 'fixed') {

                    // We assume that getBoundingClientRect is available when computed position is fixed
                    offset = element.getBoundingClientRect();

                } else {

                    // Get *real* offsetParentElement
                    offsetParentElement = offsetParent(element);

                    // Get correct offsets
                    offset = fn.offset(element);
                    if (!nodeName(offsetParentElement, 'html')) {
                        offsetParentRect = fn.offset(offsetParentElement);
                    }

                    // Add offsetParent borders
                    offsetParentRect.top += fn.css(offsetParentElement, 'borderTopWidth', true);
                    offsetParentRect.left += fn.css(offsetParentElement, 'borderLeftWidth', true);
                }

                // Subtract parent offsets and element margins
                return {
                    width: element.offsetWidth,
                    height: element.offsetHeight,
                    top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),
                    left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)
                };

            };

            /*
             * Returns the closest, non-statically positioned offsetParent of a given element
             * @ required-by fn.position
             * @ param element
             */
            var offsetParent = function offsetParentElement(element) {
                var docElement = element.ownerDocument;
                var offsetParent = element.offsetParent || docElement;
                if (nodeName(offsetParent, '#document')) {
                    return docElement.documentElement;
                }
                while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElement.documentElement;
            };

            /*
             * Provides equivalent of jQuery's height function
             * @ url http://api.jquery.com/height/
             * @ param element
             * @ param outer
             */
            fn.height = function(element, outer) {
                var value = element.offsetHeight;
                if (outer) {
                    value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);
                } else {
                    value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);
                }
                return value;
            };

            /*
             * Provides equivalent of jQuery's width function
             * @ url http://api.jquery.com/width/
             * @ param element
             * @ param outer
             */
            fn.width = function(element, outer) {
                var value = element.offsetWidth;
                if (outer) {
                    value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);
                } else {
                    value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);
                }
                return value;
            };

            return fn;

        }
        DimensionsFactory.$inject = ["$document", "$window"];
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';

    angular.module('enspire.ui.core')
        .run(
            function(){

                angular.element.prototype.getStyle = function(styleName){
                    var val = this[0].style[styleName];
                    if(window.getComputedStyle && typeof window.getComputedStyle === 'function'){
                        val = getComputedStyle(this[0]);
                        if(styleName){
                            val = val[styleName];
                        }
                    }
                    return val;
                };

                angular.element.prototype.hidden = function() {
                    var style = this.getStyle();
                    if(style.visibility==='hidden' || style.display==='none' || parseFloat(style.opacity)===0){
                        return true;
                    }
                    return this[0].offsetWidth <= 0 && this[0].offsetHeight <= 0;
                };

                angular.element.prototype.visible = function() {
                    return !this.hidden();
                };

                angular.element.prototype.toggle = function() {
                    return this[this.hidden()?'show':'hide']();
                };

                angular.element.prototype.show = function() {
                    var ele = this;
                    var od = ele.data('olddisplay');
                    var cd  = ele.getStyle('display');
                    if(od && od!=='none'){
                        ele.css('display', od);
                    }else if(!od && cd !=='none'){
                        ele.data('olddisplay', cd);
                    }else{
                        ele.data('olddisplay', 'block');
                        ele.css('display', 'block');
                    }
                    ele.css('visibility', 'visible');
                    return ele;
                };

                angular.element.prototype.hide = function() {
                    var ele = this;
                    var od  = ele.data('olddisplay');
                    var cd  = ele.getStyle('display');
                    if(!od && cd!=='none'){
                        ele.data('olddisplay', cd);
                    }
                    return ele.css('display', 'none');
                };


                    /*
                 * Provides read-only equivalent of jQuery's offset function:
                 * @ url http://api.jquery.com/offset/
                 * @ param element
                 */
                angular.element.prototype.offset = function() {
                    var ele     = this[0];
                    var boxRect = ele.getBoundingClientRect();
                    var docEle  = ele.ownerDocument;

                    return {
                        'width' : boxRect.width || ele.offsetWidth,
                        'height': boxRect.height || ele.offsetHeight,
                        'top'   : boxRect.top + (window.pageYOffset || docEle.documentElement.scrollTop) - (docEle.documentElement.clientTop || 0),
                        'left'  : boxRect.left + (window.pageXOffset || docEle.documentElement.scrollLeft) - (docEle.documentElement.clientLeft || 0)
                    };
                };








            }
        );

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
// Polyfill angular < 1.4 (provide $animateCss)
angular
    .module('enspire.ui.core')
    .factory('$$mdAnimate', ["$q", "$timeout", "$mdConstant", "$animateCss", function($q, $timeout, $mdConstant, $animateCss){

        // Since $$mdAnimate is injected into $mdUtil... use a wrapper function
        // to subsequently inject $mdUtil as an argument to the AnimateDomUtils

        return function($mdUtil) {
            return AnimateDomUtils( $mdUtil, $q, $timeout, $mdConstant, $animateCss);
        };
    }]);

/**
 * Factory function that requires special injections
 */
function AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss) {
    var self;
    return self = {
        /**
         *
         */
        translate3d : function( target, from, to, options ) {
            return $animateCss(target,{
                from:from,
                to:to,
                addClass:options.transitionInClass
            })
                .start()
                .then(function(){
                    // Resolve with reverser function...
                    return reverseTranslate;
                });

            /**
             * Specific reversal of the request translate animation above...
             */
            function reverseTranslate (newFrom) {
                return $animateCss(target, {
                    to: newFrom || from,
                    addClass: options.transitionOutClass,
                    removeClass: options.transitionInClass
                }).start();

            }
        },

        /**
         * Listen for transitionEnd event (with optional timeout)
         * Announce completion or failure via promise handlers
         */
        waitTransitionEnd: function (element, opts) {
            var TIMEOUT = 3000; // fallback is 3 secs

            return $q(function(resolve, reject){
                opts = opts || { };

                var timer = $timeout(finished, opts.timeout || TIMEOUT);
                element.on($mdConstant.CSS.TRANSITIONEND, finished);

                /**
                 * Upon timeout or transitionEnd, reject or resolve (respectively) this promise.
                 * NOTE: Make sure this transitionEnd didn't bubble up from a child
                 */
                function finished(ev) {
                    if ( ev && ev.target !== element[0]) return;

                    if ( ev  ) $timeout.cancel(timer);
                    element.off($mdConstant.CSS.TRANSITIONEND, finished);

                    // Never reject since ngAnimate may cause timeouts due missed transitionEnd events
                    resolve();

                }

            });
        },

        /**
         * Calculate the zoom transform from dialog to origin.
         *
         * We use this to set the dialog position immediately;
         * then the md-transition-in actually translates back to
         * `translate3d(0,0,0) scale(1.0)`...
         *
         * NOTE: all values are rounded to the nearest integer
         */
        calculateZoomToOrigin: function (element, originator) {
            var origin = originator.element;
            var bounds = originator.bounds;

            var zoomTemplate = "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )";
            var buildZoom = angular.bind(null, $mdUtil.supplant, zoomTemplate);
            var zoomStyle = buildZoom({centerX: 0, centerY: 0, scaleX: 0.5, scaleY: 0.5});

            if (origin || bounds) {
                var originBnds = origin ? self.clientRect(origin) || currentBounds() : self.copyRect(bounds);
                var dialogRect = self.copyRect(element[0].getBoundingClientRect());
                var dialogCenterPt = self.centerPointFor(dialogRect);
                var originCenterPt = self.centerPointFor(originBnds);

                // Build the transform to zoom from the dialog center to the origin center

                zoomStyle = buildZoom({
                    centerX: originCenterPt.x - dialogCenterPt.x,
                    centerY: originCenterPt.y - dialogCenterPt.y,
                    scaleX: Math.round(100 * Math.min(0.5, originBnds.width / dialogRect.width))/100,
                    scaleY: Math.round(100 * Math.min(0.5, originBnds.height / dialogRect.height))/100
                });
            }

            return zoomStyle;

            /**
             * This is a fallback if the origin information is no longer valid, then the
             * origin bounds simply becomes the current bounds for the dialogContainer's parent
             */
            function currentBounds() {
                var cntr = element ? element.parent() : null;
                var parent = cntr ? cntr.parent() : null;

                return parent ? self.clientRect(parent) : null;
            }
        },

        /**
         * Enhance raw values to represent valid css stylings...
         */
        toCss : function( raw ) {
            var css = { };
            var lookups = 'left top right bottom width height x y min-width min-height max-width max-height';

            angular.forEach(raw, function(value,key) {
                if ( angular.isUndefined(value) ) return;

                if ( lookups.indexOf(key) >= 0 ) {
                    css[key] = value + 'px';
                } else {
                    switch (key) {
                        case 'transition':
                            convertToVendor(key, $mdConstant.CSS.TRANSITION, value);
                            break;
                        case 'transform':
                            convertToVendor(key, $mdConstant.CSS.TRANSFORM, value);
                            break;
                        case 'transformOrigin':
                            convertToVendor(key, $mdConstant.CSS.TRANSFORM_ORIGIN, value);
                            break;
                    }
                }
            });

            return css;

            function convertToVendor(key, vendor, value) {
                angular.forEach(vendor.split(' '), function (key) {
                    css[key] = value;
                });
            }
        },

        /**
         * Convert the translate CSS value to key/value pair(s).
         */
        toTransformCss: function (transform, addTransition, transition) {
            var css = {};
            angular.forEach($mdConstant.CSS.TRANSFORM.split(' '), function (key) {
                css[key] = transform;
            });

            if (addTransition) {
                transition = transition || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important";
                css['transition'] = transition;
            }

            return css;
        },

        /**
         *  Clone the Rect and calculate the height/width if needed
         */
        copyRect: function (source, destination) {
            if (!source) return null;

            destination = destination || {};

            angular.forEach('left top right bottom width height'.split(' '), function (key) {
                destination[key] = Math.round(source[key])
            });

            destination.width = destination.width || (destination.right - destination.left);
            destination.height = destination.height || (destination.bottom - destination.top);

            return destination;
        },

        /**
         * Calculate ClientRect of element; return null if hidden or zero size
         */
        clientRect: function (element) {
            var bounds = angular.element(element)[0].getBoundingClientRect();
            var isPositiveSizeClientRect = function (rect) {
                return rect && (rect.width > 0) && (rect.height > 0);
            };

            // If the event origin element has zero size, it has probably been hidden.
            return isPositiveSizeClientRect(bounds) ? self.copyRect(bounds) : null;
        },

        /**
         *  Calculate 'rounded' center point of Rect
         */
        centerPointFor: function (targetRect) {
            return targetRect ? {
                x: Math.round(targetRect.left + (targetRect.width / 2)),
                y: Math.round(targetRect.top + (targetRect.height / 2))
            } : { x : 0, y : 0 };
        }

    };
};

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
angular.module('enspire.ui.core')
    .factory('$mdConstant', MdConstantFactory);

/**
 * Factory function that creates the grab-bag $mdConstant service.
 * @ngInject
 */
function MdConstantFactory($sniffer) {

    var webkit = /webkit/i.test($sniffer.vendorPrefix);
    function vendorProperty(name) {
        return webkit ?  ('webkit' + name.charAt(0).toUpperCase() + name.substring(1)) : name;
    }

    return {
        KEY_CODE: {
            COMMA: 188,
            ENTER: 13,
            ESCAPE: 27,
            SPACE: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            LEFT_ARROW : 37,
            UP_ARROW : 38,
            RIGHT_ARROW : 39,
            DOWN_ARROW : 40,
            TAB : 9,
            BACKSPACE: 8,
            DELETE: 46
        },
        CSS: {
            /* Constants */
            TRANSITIONEND: 'transitionend' + (webkit ? ' webkitTransitionEnd' : ''),
            ANIMATIONEND: 'animationend' + (webkit ? ' webkitAnimationEnd' : ''),

            TRANSFORM: vendorProperty('transform'),
            TRANSFORM_ORIGIN: vendorProperty('transformOrigin'),
            TRANSITION: vendorProperty('transition'),
            TRANSITION_DURATION: vendorProperty('transitionDuration'),
            ANIMATION_PLAY_STATE: vendorProperty('animationPlayState'),
            ANIMATION_DURATION: vendorProperty('animationDuration'),
            ANIMATION_NAME: vendorProperty('animationName'),
            ANIMATION_TIMING: vendorProperty('animationTimingFunction'),
            ANIMATION_DIRECTION: vendorProperty('animationDirection')
        },
        /**
         * As defined in core/style/variables.scss
         *
         * $layout-breakpoint-xs:     600px !default;
         * $layout-breakpoint-sm:     960px !default;
         * $layout-breakpoint-md:     1280px !default;
         * $layout-breakpoint-lg:     1920px !default;
         *
         */
        MEDIA: {
            'xs'    : '(max-width: 599px)'                         ,
            'gt-xs' : '(min-width: 600px)'                         ,
            'sm'    : '(min-width: 600px) and (max-width: 959px)'  ,
            'gt-sm' : '(min-width: 960px)'                         ,
            'md'    : '(min-width: 960px) and (max-width: 1279px)' ,
            'gt-md' : '(min-width: 1280px)'                        ,
            'lg'    : '(min-width: 1280px) and (max-width: 1919px)',
            'gt-lg' : '(min-width: 1920px)'                        ,
            'xl'    : '(min-width: 1920px)'
        },
        MEDIA_PRIORITY: [
            'xl',
            'gt-lg',
            'lg',
            'gt-md',
            'md',
            'gt-sm',
            'sm',
            'gt-xs',
            'xs'
        ]
    };
}
MdConstantFactory.$inject = ["$sniffer"];

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/*
 * This var has to be outside the angular factory, otherwise when
 * there are multiple material apps on the same page, each app
 * will create its own instance of this array and the app's IDs
 * will not be unique.
 */
var nextUniqueId = 0;

/**
 * @ngdoc module
 * @name material.core.util
 * @description
 * Util
 */
angular
    .module('enspire.ui.core')
    .factory('$mdUtil', UtilFactory);

function UtilFactory($document, $timeout, $compile, $rootScope, $$mdAnimate, $interpolate, $log, $rootElement, $window) {
    // Setup some core variables for the processTemplate method
    var startSymbol = $interpolate.startSymbol(),
        endSymbol = $interpolate.endSymbol(),
        usesStandardSymbols = ((startSymbol === '{{') && (endSymbol === '}}'));

    /**
     * Checks if the target element has the requested style by key
     * @param {DOMElement|JQLite} target Target element
     * @param {string} key Style key
     * @param {string=} expectedVal Optional expected value
     * @returns {boolean} Whether the target element has the style or not
     */
    var hasComputedStyle = function (target, key, expectedVal) {
        var hasValue = false;

        if ( target && target.length  ) {
            var computedStyles = $window.getComputedStyle(target[0]);
            hasValue = angular.isDefined(computedStyles[key]) && (expectedVal ? computedStyles[key] == expectedVal : true);
        }

        return hasValue;
    };

    var $mdUtil = {
        dom: {},
        now: window.performance ?
            angular.bind(window.performance, window.performance.now) : Date.now || function() {
            return new Date().getTime();
        },

        clientRect: function(element, offsetParent, isOffsetRect) {
            var node = getNode(element);
            offsetParent = getNode(offsetParent || node.offsetParent || document.body);
            var nodeRect = node.getBoundingClientRect();

            // The user can ask for an offsetRect: a rect relative to the offsetParent,
            // or a clientRect: a rect relative to the page
            var offsetRect = isOffsetRect ?
                offsetParent.getBoundingClientRect() :
            {left: 0, top: 0, width: 0, height: 0};
            return {
                left: nodeRect.left - offsetRect.left,
                top: nodeRect.top - offsetRect.top,
                width: nodeRect.width,
                height: nodeRect.height
            };
        },
        offsetRect: function(element, offsetParent) {
            return $mdUtil.clientRect(element, offsetParent, true);
        },

        // Annoying method to copy nodes to an array, thanks to IE
        nodesToArray: function(nodes) {
            nodes = nodes || [];

            var results = [];
            for (var i = 0; i < nodes.length; ++i) {
                results.push(nodes.item(i));
            }
            return results;
        },

        /**
         * Calculate the positive scroll offset
         * TODO: Check with pinch-zoom in IE/Chrome;
         *       https://code.google.com/p/chromium/issues/detail?id=496285
         */
        scrollTop: function(element) {
            element = angular.element(element || $document[0].body);

            var body = (element[0] == $document[0].body) ? $document[0].body : undefined;
            var scrollTop = body ? body.scrollTop + body.parentElement.scrollTop : 0;

            // Calculate the positive scroll offset
            return scrollTop || Math.abs(element[0].getBoundingClientRect().top);
        },

        /**
         * @ngdoc directive
         * @name mdAutofocus
         * @module material.core.util
         *

         *
         * @description
         * `$mdUtil.findFocusTarget()` provides an optional way to identify the focused element when a dialog, bottomsheet, sideNav
         * or other element opens. This is optional attribute finds a nested element with the mdAutoFocus attribute and optional
         * expression. An expression may be specified as the directive value; to enable conditional activation of the autoFocus.
         *
         * @usage
         * ### Dialog
         * <hljs lang="html">
         * <md-dialog>
         *   <form>
         *     <md-input-container>
         *       <label for="testInput">Label</label>
         *       <input id="testInput" type="text" md-autofocus>
         *     </md-input-container>
         *   </form>
         * </md-dialog>
         * </hljs>
         *
         * ### Bottomsheet
         * <hljs lang="html">
         * <md-bottom-sheet class="md-list md-has-header">
         *  <md-subheader>Comment Actions</md-subheader>
         *  <md-list>
         *    <md-list-item ng-repeat="item in items">
         *
         *      <md-button md-autofocus="$index == 2">
         *        <md-icon md-svg-src="{{item.icon}}"></md-icon>
         *        <span class="md-inline-list-icon-label">{{ item.name }}</span>
         *      </md-button>
         *
         *    </md-list-item>
         *  </md-list>
         * </md-bottom-sheet>
         * </hljs>
         *
         * ### Autocomplete
         * <hljs lang="html">
         *   <en-autocomplete
         *       md-autofocus
         *       md-selected-item="selectedItem"
         *       md-search-text="searchText"
         *       md-items="item in getMatches(searchText)"
         *       md-item-text="item.display">
         *     <span md-highlight-text="searchText">{{item.display}}</span>
         *   </en-autocomplete>
         * </hljs>
         *
         * ### Sidenav
         * <hljs lang="html">
         * <div layout="row" ng-controller="MyController">
         *   <md-sidenav md-component-id="left" class="md-sidenav-left">
         *     Left Nav!
         *   </md-sidenav>
         *
         *   <md-content>
         *     Center Content
         *     <md-button ng-click="openLeftMenu()">
         *       Open Left Menu
         *     </md-button>
         *   </md-content>
         *
         *   <md-sidenav md-component-id="right"
         *     md-is-locked-open="$mdMedia('min-width: 333px')"
         *     class="md-sidenav-right">
         *     <form>
         *       <md-input-container>
         *         <label for="testInput">Test input</label>
         *         <input id="testInput" type="text"
         *                ng-model="data" md-autofocus>
         *       </md-input-container>
         *     </form>
         *   </md-sidenav>
         * </div>
         * </hljs>
         **/
        findFocusTarget: function(containerEl, attributeVal) {
            var AUTO_FOCUS = '[md-autofocus]';
            var elToFocus;

            elToFocus = scanForFocusable(containerEl, attributeVal || AUTO_FOCUS);

            if ( !elToFocus && attributeVal != AUTO_FOCUS) {
                // Scan for deprecated attribute
                elToFocus = scanForFocusable(containerEl, '[md-auto-focus]');

                if ( !elToFocus ) {
                    // Scan for fallback to 'universal' API
                    elToFocus = scanForFocusable(containerEl, AUTO_FOCUS);
                }
            }

            return elToFocus;

            /**
             * Can target and nested children for specified Selector (attribute)
             * whose value may be an expression that evaluates to True/False.
             */
            function scanForFocusable(target, selector) {
                var elFound, items = target[0].querySelectorAll(selector);

                // Find the last child element with the focus attribute
                if ( items && items.length ){
                    var EXP_ATTR = /\s*\[?([\-a-z]*)\]?\s*/i;
                    var matches = EXP_ATTR.exec(selector);
                    var attribute = matches ? matches[1] : null;

                    items.length && angular.forEach(items, function(it) {
                        it = angular.element(it);

                        // If the expression evaluates to FALSE, then it is not focusable target
                        var focusExpression = it[0].getAttribute(attribute);
                        var isFocusable = !focusExpression || !$mdUtil.validateScope(it) ? true :
                            (it.scope().$eval(focusExpression) !== false );

                        if (isFocusable) elFound = it;
                    });
                }
                return elFound;
            }
        },

        // Disables scroll around the passed element.
        disableScrollAround: function(element, parent) {
            $mdUtil.disableScrollAround._count = $mdUtil.disableScrollAround._count || 0;
            ++$mdUtil.disableScrollAround._count;
            if ($mdUtil.disableScrollAround._enableScrolling) return $mdUtil.disableScrollAround._enableScrolling;
            element = angular.element(element);
            var body = $document[0].body,
                restoreBody = disableBodyScroll(),
                restoreElement = disableElementScroll(parent);

            return $mdUtil.disableScrollAround._enableScrolling = function() {
                if (!--$mdUtil.disableScrollAround._count) {
                    restoreBody();
                    restoreElement();
                    delete $mdUtil.disableScrollAround._enableScrolling;
                }
            };

            // Creates a virtual scrolling mask to absorb touchmove, keyboard, scrollbar clicking, and wheel events
            function disableElementScroll(element) {
                element = angular.element(element || body)[0];
                var zIndex = 50;
                var scrollMask = angular.element(
                    '<div class="md-scroll-mask" style="z-index: ' + zIndex + '">' +
                    '  <div class="md-scroll-mask-bar"></div>' +
                    '</div>');
                element.appendChild(scrollMask[0]);

                scrollMask.on('wheel', preventDefault);
                scrollMask.on('touchmove', preventDefault);
                $document.on('keydown', disableKeyNav);

                return function restoreScroll() {
                    scrollMask.off('wheel');
                    scrollMask.off('touchmove');
                    scrollMask[0].parentNode.removeChild(scrollMask[0]);
                    $document.off('keydown', disableKeyNav);
                    delete $mdUtil.disableScrollAround._enableScrolling;
                };

                // Prevent keypresses from elements inside the body
                // used to stop the keypresses that could cause the page to scroll
                // (arrow keys, spacebar, tab, etc).
                function disableKeyNav(e) {
                    //-- temporarily removed this logic, will possibly re-add at a later date
                    //if (!element[0].contains(e.target)) {
                    //  e.preventDefault();
                    //  e.stopImmediatePropagation();
                    //}
                }

                function preventDefault(e) {
                    e.preventDefault();
                }
            }

            // Converts the body to a position fixed block and translate it to the proper scroll
            // position
            function disableBodyScroll() {
                var htmlNode = body.parentNode;
                var restoreHtmlStyle = htmlNode.getAttribute('style') || '';
                var restoreBodyStyle = body.getAttribute('style') || '';
                var scrollOffset = $mdUtil.scrollTop(body);
                var clientWidth = body.clientWidth;

                if (body.scrollHeight > body.clientHeight + 1) {
                    applyStyles(body, {
                        position: 'fixed',
                        width: '100%',
                        top: -scrollOffset + 'px'
                    });

                    applyStyles(htmlNode, {
                        overflowY: 'scroll'
                    });
                }

                if (body.clientWidth < clientWidth) applyStyles(body, {overflow: 'hidden'});

                return function restoreScroll() {
                    body.setAttribute('style', restoreBodyStyle);
                    htmlNode.setAttribute('style', restoreHtmlStyle);
                    body.scrollTop = scrollOffset;
                    htmlNode.scrollTop = scrollOffset;
                };
            }

            function applyStyles(el, styles) {
                for (var key in styles) {
                    el.style[key] = styles[key];
                }
            }
        },
        enableScrolling: function() {
            var method = this.disableScrollAround._enableScrolling;
            method && method();
        },
        floatingScrollbars: function() {
            if (this.floatingScrollbars.cached === undefined) {
                var tempNode = angular.element('<div style="width: 100%; z-index: -1; position: absolute; height: 35px; overflow-y: scroll"><div style="height: 60px;"></div></div>');
                $document[0].body.appendChild(tempNode[0]);
                this.floatingScrollbars.cached = (tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth);
                tempNode.remove();
            }
            return this.floatingScrollbars.cached;
        },

        // Mobile safari only allows you to set focus in click event listeners...
        forceFocus: function(element) {
            var node = element[0] || element;

            document.addEventListener('click', function focusOnClick(ev) {
                if (ev.target === node && ev.$focus) {
                    node.focus();
                    ev.stopImmediatePropagation();
                    ev.preventDefault();
                    node.removeEventListener('click', focusOnClick);
                }
            }, true);

            var newEvent = document.createEvent('MouseEvents');
            newEvent.initMouseEvent('click', false, true, window, {}, 0, 0, 0, 0,
                false, false, false, false, 0, null);
            newEvent.$material = true;
            newEvent.$focus = true;
            node.dispatchEvent(newEvent);
        },

        /**
         * facade to build md-backdrop element with desired styles
         * NOTE: Use $compile to trigger backdrop postLink function
         */
        createBackdrop: function(scope, addClass) {
            return $compile($mdUtil.supplant('<md-backdrop class="{0}">', [addClass]))(scope);
        },

        /**
         * supplant() method from Crockford's `Remedial Javascript`
         * Equivalent to use of $interpolate; without dependency on
         * interpolation symbols and scope. Note: the '{<token>}' can
         * be property names, property chains, or array indices.
         */
        supplant: function(template, values, pattern) {
            pattern = pattern || /\{([^\{\}]*)\}/g;
            return template.replace(pattern, function(a, b) {
                var p = b.split('.'),
                    r = values;
                try {
                    for (var s in p) {
                        if (p.hasOwnProperty(s) ) {
                            r = r[p[s]];
                        }
                    }
                } catch (e) {
                    r = a;
                }
                return (typeof r === 'string' || typeof r === 'number') ? r : a;
            });
        },

        fakeNgModel: function() {
            return {
                $fake: true,
                $setTouched: angular.noop,
                $setViewValue: function(value) {
                    this.$viewValue = value;
                    this.$render(value);
                    this.$viewChangeListeners.forEach(function(cb) {
                        cb();
                    });
                },
                $isEmpty: function(value) {
                    return ('' + value).length === 0;
                },
                $parsers: [],
                $formatters: [],
                $viewChangeListeners: [],
                $render: angular.noop
            };
        },

        // Returns a function, that, as long as it continues to be invoked, will not
        // be triggered. The function will be called after it stops being called for
        // N milliseconds.
        // @param wait Integer value of msecs to delay (since last debounce reset); default value 10 msecs
        // @param invokeApply should the $timeout trigger $digest() dirty checking
        debounce: function(func, wait, scope, invokeApply) {
            var timer;

            return function debounced() {
                var context = scope,
                    args = Array.prototype.slice.call(arguments);

                $timeout.cancel(timer);
                timer = $timeout(function() {

                    timer = undefined;
                    func.apply(context, args);

                }, wait || 10, invokeApply);
            };
        },

        // Returns a function that can only be triggered every `delay` milliseconds.
        // In other words, the function will not be called unless it has been more
        // than `delay` milliseconds since the last call.
        throttle: function throttle(func, delay) {
            var recent;
            return function throttled() {
                var context = this;
                var args = arguments;
                var now = $mdUtil.now();

                if (!recent || (now - recent > delay)) {
                    func.apply(context, args);
                    recent = now;
                }
            };
        },

        /**
         * Measures the number of milliseconds taken to run the provided callback
         * function. Uses a high-precision timer if available.
         */
        time: function time(cb) {
            var start = $mdUtil.now();
            cb();
            return $mdUtil.now() - start;
        },

        /**
         * Create an implicit getter that caches its `getter()`
         * lookup value
         */
        valueOnUse : function (scope, key, getter) {
            var value = null, args = Array.prototype.slice.call(arguments);
            var params = (args.length > 3) ? args.slice(3) : [ ];

            Object.defineProperty(scope, key, {
                get: function () {
                    if (value === null) value = getter.apply(scope, params);
                    return value;
                }
            });
        },

        /**
         * Get a unique ID.
         *
         * @returns {string} an unique numeric string
         */
        nextUid: function() {
            return '' + nextUniqueId++;
        },

        /**
         * By default AngularJS attaches information about binding and scopes to DOM nodes,
         * and adds CSS classes to data-bound elements. But this information is NOT available
         * when `$compileProvider.debugInfoEnabled(false);`
         *
         * @see https://docs.angularjs.org/guide/production
         */
        validateScope : function(element) {
            var hasScope = element && angular.isDefined(element.scope());
            if ( !hasScope ) {
                $log.warn("element.scope() is not available when 'debug mode' == false. @see https://docs.angularjs.org/guide/production!");
            }

            return hasScope;
        },

        // Stop watchers and events from firing on a scope without destroying it,
        // by disconnecting it from its parent and its siblings' linked lists.
        disconnectScope: function disconnectScope(scope) {
            if (!scope) return;

            // we can't destroy the root scope or a scope that has been already destroyed
            if (scope.$root === scope) return;
            if (scope.$$destroyed) return;

            var parent = scope.$parent;
            scope.$$disconnected = true;

            // See Scope.$destroy
            if (parent.$$childHead === scope) parent.$$childHead = scope.$$nextSibling;
            if (parent.$$childTail === scope) parent.$$childTail = scope.$$prevSibling;
            if (scope.$$prevSibling) scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
            if (scope.$$nextSibling) scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;

            scope.$$nextSibling = scope.$$prevSibling = null;

        },

        // Undo the effects of disconnectScope above.
        reconnectScope: function reconnectScope(scope) {
            if (!scope) return;

            // we can't disconnect the root node or scope already disconnected
            if (scope.$root === scope) return;
            if (!scope.$$disconnected) return;

            var child = scope;

            var parent = child.$parent;
            child.$$disconnected = false;
            // See Scope.$new for this logic...
            child.$$prevSibling = parent.$$childTail;
            if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
            } else {
                parent.$$childHead = parent.$$childTail = child;
            }
        },

        /*
         * getClosest replicates jQuery.closest() to walk up the DOM tree until it finds a matching nodeName
         *
         * @param el Element to start walking the DOM from
         * @param tagName Tag name to find closest to el, such as 'form'
         */
        getClosest: function getClosest(el, tagName, onlyParent) {
            if (el instanceof angular.element) el = el[0];
            tagName = tagName.toUpperCase();
            if (onlyParent) el = el.parentNode;
            if (!el) return null;
            do {
                if (el.nodeName === tagName) {
                    return el;
                }
            } while (el = el.parentNode);
            return null;
        },

        /**
         * Build polyfill for the Node.contains feature (if needed)
         */
        elementContains: function(node, child) {
            var hasContains = (window.Node && window.Node.prototype && Node.prototype.contains);
            var findFn = hasContains ? angular.bind(node, node.contains) : angular.bind(node, function(arg) {
                // compares the positions of two nodes and returns a bitmask
                return (node === child) || !!(this.compareDocumentPosition(arg) & 16)
            });

            return findFn(child);
        },

        /**
         * Functional equivalent for $element.filter(‘md-bottom-sheet’)
         * useful with interimElements where the element and its container are important...
         *
         * @param {[]} elements to scan
         * @param {string} name of node to find (e.g. 'md-dialog')
         * @param {boolean=} optional flag to allow deep scans; defaults to 'false'.
         * @param {boolean=} optional flag to enable log warnings; defaults to false
         */
        extractElementByName: function(element, nodeName, scanDeep, warnNotFound) {
            var found = scanTree(element);
            if (!found && !!warnNotFound) {
                $log.warn( $mdUtil.supplant("Unable to find node '{0}' in element '{1}'.",[nodeName, element[0].outerHTML]) );
            }

            return angular.element(found || element);

            /**
             * Breadth-First tree scan for element with matching `nodeName`
             */
            function scanTree(element) {
                return scanLevel(element) || (!!scanDeep ? scanChildren(element) : null);
            }

            /**
             * Case-insensitive scan of current elements only (do not descend).
             */
            function scanLevel(element) {
                if ( element ) {
                    for (var i = 0, len = element.length; i < len; i++) {
                        if (element[i].nodeName.toLowerCase() === nodeName) {
                            return element[i];
                        }
                    }
                }
                return null;
            }

            /**
             * Scan children of specified node
             */
            function scanChildren(element) {
                var found;
                if ( element ) {
                    for (var i = 0, len = element.length; i < len; i++) {
                        var target = element[i];
                        if ( !found ) {
                            for (var j = 0, numChild = target.childNodes.length; j < numChild; j++) {
                                found = found || scanTree([target.childNodes[j]]);
                            }
                        }
                    }
                }
                return found;
            }

        },

        /**
         * Give optional properties with no value a boolean true if attr provided or false otherwise
         */
        initOptionalProperties: function(scope, attr, defaults) {
            defaults = defaults || {};
            angular.forEach(scope.$$isolateBindings, function(binding, key) {
                if (binding.optional && angular.isUndefined(scope[key])) {
                    var attrIsDefined = angular.isDefined(attr[binding.attrName]);
                    scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : attrIsDefined;
                }
            });
        },

        /**
         * Alternative to $timeout calls with 0 delay.
         * nextTick() coalesces all calls within a single frame
         * to minimize $digest thrashing
         *
         * @param callback
         * @param digest
         * @returns {*}
         */
        nextTick: function(callback, digest, scope) {
            //-- grab function reference for storing state details
            var nextTick = $mdUtil.nextTick;
            var timeout = nextTick.timeout;
            var queue = nextTick.queue || [];

            //-- add callback to the queue
            queue.push(callback);

            //-- set default value for digest
            if (digest == null) digest = true;

            //-- store updated digest/queue values
            nextTick.digest = nextTick.digest || digest;
            nextTick.queue = queue;

            //-- either return existing timeout or create a new one
            return timeout || (nextTick.timeout = $timeout(processQueue, 0, false));

            /**
             * Grab a copy of the current queue
             * Clear the queue for future use
             * Process the existing queue
             * Trigger digest if necessary
             */
            function processQueue() {
                var skip = scope && scope.$$destroyed;
                var queue = !skip ? nextTick.queue : [];
                var digest = !skip ? nextTick.digest : null;

                nextTick.queue = [];
                nextTick.timeout = null;
                nextTick.digest = false;

                queue.forEach(function(callback) {
                    callback();
                });

                if (digest) $rootScope.$digest();
            }
        },

        /**
         * Processes a template and replaces the start/end symbols if the application has
         * overriden them.
         *
         * @param template The template to process whose start/end tags may be replaced.
         * @returns {*}
         */
        processTemplate: function(template) {
            if (usesStandardSymbols) {
                return template;
            } else {
                if (!template || !angular.isString(template)) return template;
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }
        },

        /**
         * Scan up dom hierarchy for enabled parent;
         */
        getParentWithPointerEvents: function (element) {
            var parent = element.parent();

            // jqLite might return a non-null, but still empty, parent; so check for parent and length
            while (hasComputedStyle(parent, 'pointer-events', 'none')) {
                parent = parent.parent();
            }

            return parent;
        },

        getNearestContentElement: function (element) {
            var current = element.parent()[0];
            // Look for the nearest parent md-content, stopping at the rootElement.
            while (current && current !== $rootElement[0] && current !== document.body && current.nodeName.toUpperCase() !== 'MD-CONTENT') {
                current = current.parentNode;
            }
            return current;
        },

        hasComputedStyle: hasComputedStyle
    };

// Instantiate other namespace utility methods

    $mdUtil.dom.animator = $$mdAnimate($mdUtil);

    return $mdUtil;

    function getNode(el) {
        return el[0] || el;
    }

}
UtilFactory.$inject = ["$document", "$timeout", "$compile", "$rootScope", "$$mdAnimate", "$interpolate", "$log", "$rootElement", "$window"];

/*
 * Since removing jQuery from the demos, some code that uses `element.focus()` is broken.
 * We need to add `element.focus()`, because it's testable unlike `element[0].focus`.
 */

angular.element.prototype.focus = angular.element.prototype.focus || function() {
        if (this.length) {
            this[0].focus();
        }
        return this;
    };
angular.element.prototype.blur = angular.element.prototype.blur || function() {
        if (this.length) {
            this[0].blur();
        }
        return this;
    };

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';
        /**
         * @ngdoc filter
         * @name pixel
         * @module enspire.ui.core
         *
         * @description
         * Accepts a number value, unit of measure and optional dpi number and returns the pixel value of those arguments.
         *
         *
         */
    angular.module('enspire.ui.core')
        .filter('pixel', PixelFilter)
        .filter('pixelTo', PixelToUnitFilter)

    //$filter('pixel')(unitValueArg, unitTypeArg)
    //$filter('pixel')(2.25, 'in');
    //{{unitValue | pixel:'in'}}

    function PixelFilter($filter) {
        return function(val, unit, dpi){
            if(dpi){
                dpi = parseFloat(dpi);
            }else{
                dpi = 96;//203;
            }

            var units = {
                cm:dpi/2.54,
                mm:dpi/25.4,
                in:dpi,
                pt:dpi/72,
                px:1
            };

            // if no unit given and no unit found in val return original val
            if(!unit){
                unit = val.replace(/[^a-z]/gi,'');
                val  = parseFloat(val.replace(/[^0-9.]/gi,'')).toFixed(3);
                return unit!=='' ? (val * units[unit.toLowerCase()]).toFixed(0) : val;
            }else{
                return (parseFloat(val) * units[unit.toLowerCase()]).toFixed(0);
            }
        };
    }
    PixelFilter.$inject = ["$filter"];

    //$filter('pixelToUnit')(pxValueArg, unitTypeToConvertToArg)
    //$filter('pixelToUnit')(380, 'in');
    //{{unitValue | pixel:'in'}}
    function PixelToUnitFilter($filter) {
        return function(val, unit, dpi){
            if(dpi){
                dpi = parseFloat(dpi);
            }else{
                dpi = 96;//203;
            }

            var units = {
                cm:dpi/2.54,
                mm:dpi/25.4,
                in:dpi,
                pt:dpi/72,
                px:1
            };

            // if no unit given and no unit found in val return original val
            if(!unit){
                unit = val.replace(/[^a-z]/gi,'');
                val  = parseFloat(val.replace(/[^0-9.]/gi,'')).toFixed(3);
                return unit!=='' ? (val / units[unit.toLowerCase()]).toFixed(3) : val;
            }else{
                return (parseFloat(val) / units[unit.toLowerCase()]).toFixed(3);
            }
        };
    }
    PixelToUnitFilter.$inject = ["$filter"];




})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.core')
        .factory('$enPosition', PositionFactory);

    /**
     * @ngdoc service
     * @name $enPosition
     * @module enspire.ui.core
     *
     * @description
     * A toolbox of element positioning methods.
     */
    
    function PositionFactory(){

        var Position = {
            rect: getClientRect
        };

        return Position;
        
        /**
         * @ngdoc method
         * @name $enPosition#rect
         *
         * @description
         * Takes an angular.element object, determines its position and dimensions, and returns all found properties.
         *
         * @param {object} element The angular.element represented dom element to be inspected.
         * 
         * @returns {object} Contains an elements position and dimension properties.
         * <hljs lang="js">
         *   {
         *     bottom : 0,
         *     left   : 0,
         *     right  : 0,
         *     top    : 0,
         *     height : 0,
         *     width  : 0
         *   }
         * </hljs>
         */

        function getClientRect(ele){
            ele         = angular.element(ele)[0];
            var w       = window;
            var doc     = document.documentElement || document.body.parentNode || document.body;
            var x       = (angular.isDefined(w.pageXOffset)) ? w.pageXOffset : doc.scrollLeft;
            var y       = (angular.isDefined(w.pageYOffset)) ? w.pageYOffset : doc.scrollTop;
            var rect    = ele.getBoundingClientRect();

            if(angular.isNumber(x) && angular.isNumber(y)){
                return {
                    bottom: rect.bottom+y,
                    left  : rect.left + x,
                    right : rect.right + x,
                    top   : rect.top + y,
                    height: rect.height,
                    width : rect.width
                };
            }
            return rect;
        }
        
        
        
        
    }
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';
    /**
     * @ngdoc filter
     * @name prettyDate
     * @module enspire.ui.core
     *
     * @description
     * Provides pretty dates to users based on a UTC DateTime (13 digit timestamp) string.
     *
     * ### Example Output
     *
     * - just now
     * - 1 minute ago
     * - 4 days ago
     * - 3 weeks ago
     * - 9 months ago
     * - 3 years ago
     *
     * ## Usage
     * ### HTML Template Binding
     * <hljs lang="html">
     *   {{ expression | prettyDate }}
     * </hljs>
     *
     * ### Javascript
     * <hljs lang="javascript">
     *   $filter('prettyDate')(expression);
     * </hljs>
     *
     *
     * @usage
     *
     * @param {expression} expression   13 digit UTC timestamp.
     *
     * @returns {string} Simple string representation of 'how long ago' the timestamp was.
     */

    angular.module('enspire.ui.core')
        .filter('prettyDate', FilterFunction);

    function FilterFunction(){
        return function (input) {

            if (!input || !angular.isString(input)) {
                return input;
            }

            var time_formats = [
                [60, 'just now'],
                [90, '1 minute'],
                [3600, 'minutes', 60],
                [5400, '1 hour'],
                [86400, 'hours', 3600],
                [129600, '1 day'],
                [604800, 'days', 86400],
                [907200, '1 week'],
                [2628000, 'weeks', 604800],
                [3942000, '1 month'],
                [31536000, 'months', 2628000],
                [47304000, '1 year'],
                [3153600000, 'years', 31536000]
            ];

            var time = ('' + input).replace(/-/g, '/').replace(/[TZ]/g, ' '),
                dt = new Date(),
                seconds = ((dt - new Date(time) + (dt.getTimezoneOffset() * 60000)) / 1000),
                token = ' ago',
                i = 0,
                format;

            if (seconds < 0) {
                seconds = Math.abs(seconds);
                token = '';
            }

            while (format = time_formats[i++]) {
                if (seconds < format[0]) {
                    if (format.length === 2) {
                        return format[1] + (i > 1 ? token : '');
                    } else {
                        return Math.round(seconds / format[2]) + ' ' + format[1] + (i > 1 ? token : '');
                    }
                }
            }

            return input;
        };
    }

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';
    /**
     * @ngdoc filter
     * @name reverse
     * @module enspire.ui.core
     *
     * @description
     * Filter used to reverse the order of an array. Useful when you need to reverse an array inside an ng-repeat.
     *
     * ## Usage
     * ### HTML
     * <hljs lang="html">
     *   <div ng-repeat="item in lineItems | reverse">{{item.name}}</div>
     * </hljs>
     *
     * ### Javascript
     * <hljs lang="javascript">
     *   $filter('reverse')([1,2,3,4,5,6,7,8]);
     * </hljs>
     *
     * @usage
     *
     * @returns {array} Reversed array.
     */

    angular.module('enspire.ui.core')
        .filter('reverse', FilterFunction);

    function FilterFunction(){
        return function(items) {
            return items.slice().reverse();
        };
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';
    angular.module('enspire.ui.core')
        .filter('round', FilterFunction);

    function FilterFunction(){
        return function(value, decimals) {
            return Number(Math.round(value+'e'+decimals)+'e-'+decimals);
       }
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * @ngdoc service
 * @name $enBase64
 * @module enspire.ui.core
 *
 * @returns {object} $enBase64 factory object.
 *
 * @description
 * ..
 *
 * > **Note:** This module is, at the moment, poorly documented.
 */

angular.module('enspire.ui.core').factory('$enBase64', [function() {

    var PADCHAR = '=';

    var ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    function getbyte64(s,i) {
        var idx = ALPHA.indexOf(s.charAt(i));
        if (idx == -1) {
            throw "Cannot decode base64";
        }
        return idx;
    }

    function decode(s) {
        // convert to string
        s = "" + s;
        var pads, i, b10;
        var imax = s.length;
        if (imax == 0) {
            return s;
        }

        if (imax % 4 != 0) {
            throw "Cannot decode base64";
        }

        pads = 0;
        if (s.charAt(imax -1) == PADCHAR) {
            pads = 1;
            if (s.charAt(imax -2) == PADCHAR) {
                pads = 2;
            }
            // either way, we want to ignore this last block
            imax -= 4;
        }

        var x = [];
        for (i = 0; i < imax; i += 4) {
            b10 = (getbyte64(s,i) << 18) | (getbyte64(s,i+1) << 12) |
                (getbyte64(s,i+2) << 6) | getbyte64(s,i+3);
            x.push(String.fromCharCode(b10 >> 16, (b10 >> 8) & 0xff, b10 & 0xff));
        }

        switch (pads) {
            case 1:
                b10 = (getbyte64(s,i) << 18) | (getbyte64(s,i+1) << 12) | (getbyte64(s,i+2) << 6);
                x.push(String.fromCharCode(b10 >> 16, (b10 >> 8) & 0xff));
                break;
            case 2:
                b10 = (getbyte64(s,i) << 18) | (getbyte64(s,i+1) << 12);
                x.push(String.fromCharCode(b10 >> 16));
                break;
        }
        return x.join('');
    }

    function getbyte(s,i) {
        var x = s.charCodeAt(i);
        if (x > 255) {
            throw "INVALID_CHARACTER_ERR: DOM Exception 5";
        }
        return x;
    }

    function encode(s) {
        if (arguments.length != 1) {
            throw "SyntaxError: Not enough arguments";
        }

        var i, b10;
        var x = [];

        // convert to string
        s = "" + s;

        var imax = s.length - s.length % 3;

        if (s.length == 0) {
            return s;
        }
        for (i = 0; i < imax; i += 3) {
            b10 = (getbyte(s,i) << 16) | (getbyte(s,i+1) << 8) | getbyte(s,i+2);
            x.push(ALPHA.charAt(b10 >> 18));
            x.push(ALPHA.charAt((b10 >> 12) & 0x3F));
            x.push(ALPHA.charAt((b10 >> 6) & 0x3f));
            x.push(ALPHA.charAt(b10 & 0x3f));
        }
        switch (s.length - imax) {
            case 1:
                b10 = getbyte(s,i) << 16;
                x.push(ALPHA.charAt(b10 >> 18) + ALPHA.charAt((b10 >> 12) & 0x3F) +
                    PADCHAR + PADCHAR);
                break;
            case 2:
                b10 = (getbyte(s,i) << 16) | (getbyte(s,i+1) << 8);
                x.push(ALPHA.charAt(b10 >> 18) + ALPHA.charAt((b10 >> 12) & 0x3F) +
                    ALPHA.charAt((b10 >> 6) & 0x3f) + PADCHAR);
                break;
        }
        return x.join('');
    }

    return {
        encode: encode,
        decode: decode
    };
}]);
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */

(function () {


/**
 * @ngdoc service
 * @name $enLocalStorageProvider
 * @module enspire.ui.core
 *
 * @description Provider to configure the {@link $enLocalStorage $enLocalStorage} service.
 *
 * @usage
 * <hljs lang="js">
 * myApp.config(function($enLocalStorageProvider) {
 *   $enLocalStorageProvider.setPrefix(prefix);
 *   $enLocalStorageProvider.setStorageType(storageType);
 *   $enLocalStorageProvider.setStorageCookie(expires, path);
 *   $enLocalStorageProvider.setStorageCookieDomain(domain);
 *   $enLocalStorageProvider.setNotify(itemSet, itemRemove);
 *
 *   // provider methods are also chainable
 *
 *   $enLocalStorageProvider
 *       .setPrefix(prefix)
 *       .setStorageType(storageType)
 *       .setStorageCookie(expires, path)
 *       .setStorageCookieDomain(domain)
 *       .setNotify(itemSet, itemRemove);
 * });
 * </hljs>
 *
 *
 */



    var isDefined = angular.isDefined,
        isUndefined = angular.isUndefined,
        isNumber = angular.isNumber,
        isObject = angular.isObject,
        isArray = angular.isArray,
        extend = angular.extend,
        toJson = angular.toJson;

    angular.module('enspire.ui.core')
        .provider('$enLocalStorage', function() {
            /**
             * @ngdoc property
             * @name $enLocalStorageProvider#prefix
             *
             * @description
             * Returns prefix string used to avoid overwriting any local storage variables from the rest of your app.  Use `$enLocalStorageProvider.setPrefix('yourAppName');` to change the prefix. *Default prefix is "ls"*
             **/
            this.prefix = 'ls';

             /**
             * @ngdoc property
             * @name $enLocalStorageProvider#storageType
             *
             * @description
             * Returns the providers current storageType string.  Use `$enLocalStorageProvider.setStorageType('localStorage || sessionStorage');` to change. *Default is "localStorage"*
             **/
            this.storageType = 'localStorage';

            /**
             * @ngdoc property
             * @name $enLocalStorageProvider#cookie
             *
             * @description
             * Returns the providers current cookie options object.  Use `$enLocalStorageProvider.setStorageCookie(expires, path);` to change. *Default is:
             *
             * <hljs lang="js">
             * {
             *     expiry: 30,   // Number of days before cookies expires. 0 = Does not expire.
             *     path: '/'     // The web path the cookie represents.
             * }
             * </hljs>
             **/
            this.cookie = {
                expiry: 30,
                path: '/'
            };


            /**
             * @ngdoc property
             * @name $enLocalStorageProvider#notify
             *
             * @description
             * Returns the providers notify object.  Use `$enLocalStorageProvider.setNotify(itemSet, itemRemove);` to change. *Default is:
             *
             * <hljs lang="js">
             * {
             *     setItem: true,
             *     removeItem: false
             * }
             * </hljs>
             **/
            this.notify = {
                setItem: true,
                removeItem: false
            };

            /**
             * @ngdoc method
             * @name $enLocalStorageProvider#setPrefix
             *
             * @description
             * Public method to set the $enLocalStorageProvider service's prefix.
             *
             * @param {string} [prefix]  The prefix string to set as the $enLocalStorage's go to prefix.
             *
             * @returns {object} Returns the $enLocalStorageProvider instance.
             */
            this.setPrefix = function(prefix) {
                this.prefix = prefix;
                return this;
            };

            this.setStorageType = function(storageType) {
                this.storageType = storageType;
                return this;
            };

            /**
             * @ngdoc method
             * @name $enLocalStorageProvider#setStorageCookie
             *
             * @description
             * Public method to set the $enLocalStorageProvider service's cookie expire and path settings setter.
             *
             * @param {number} [expires]  Number of days until the cookie should expire. To keep a cookie from expiring set this parameter to 0.
             * @param {string} [path]  The web path the cookie represents. In most cases "/" should work.
             *
             * @returns {object} Returns the $enLocalStorageProvider instance.
             */
            this.setStorageCookie = function(exp, path) {
                this.cookie.expiry = exp;
                this.cookie.path = path;
                return this;
            };

            /**
             * @ngdoc method
             * @name $enLocalStorageProvider#setStorageCookieDomain
             *
             * @description
             * $enLocalStorageProvider's cookie domain setter.
             *
             * @param {string} [domain]  Domain to be set on the `$enLocalStorageProvider.cookie.domain` property.
             *
             * @returns {object} Returns the $enLocalStorageProvider instance.
             */
            this.setStorageCookieDomain = function(domain) {
                this.cookie.domain = domain;
                return this;
            };

            /**
             * @ngdoc method
             * @name $enLocalStorageProvider#setNotify
             *
             * @description
             * Setter method for $enLocalStorageProvider's notify settings.
             *
             * @param {boolean} [itemSet]  Send notify when an item is set using the $enLocalStorage service.
             * @param {boolean} [itemRemove]  Send notify when an item is removed using the $enLocalStorage service.
             *
             * @returns {object} Returns the $enLocalStorageProvider instance.
             */
            this.setNotify = function(itemSet, itemRemove) {
                this.notify = {
                    setItem: itemSet,
                    removeItem: itemRemove
                };
                return this;
            };


            /**
             * @ngdoc service
             * @name $enLocalStorage
             * @module enspire.ui.core
             *
             * @description `$enLocalStorage` service is used to set/retrieve items from cookies and/or a browsers localStorage.  The service is configurable at runtime by using the `$enLocalStorageProvider` inside an apps' `.config()` method.
             *
             * <hljs lang="js">
             * myApp.config(function($enLocalStorageProvider) {
             *   $enLocalStorageProvider.setPrefix(prefix);
             *   $enLocalStorageProvider.setStorageType(storageType);
             *   $enLocalStorageProvider.setStorageCookie(expires, path);
             *   $enLocalStorageProvider.setStorageCookieDomain(domain);
             *   $enLocalStorageProvider.setNotify(itemSet, itemRemove);
             *
             *   // provider methods are also chainable
             *
             *   $enLocalStorageProvider
             *       .setPrefix(prefix)
             *       .setStorageType(storageType)
             *       .setStorageCookie(expires, path)
             *       .setStorageCookieDomain(domain)
             *       .setNotify(itemSet, itemRemove);
             * });
             * </hljs>
             */
            this.$get = ['$rootScope', '$window', '$document', '$parse', function($rootScope, $window, $document, $parse) {
                var self = this;
                var prefix = self.prefix;
                var cookie = self.cookie;
                var notify = self.notify;
                var storageType = self.storageType;
                var webStorage;

                // When Angular's $document is not available
                if (!$document) {
                    $document = document;
                } else if ($document[0]) {
                    $document = $document[0];
                }

                // If there is a prefix set in the config lets use that with an appended period for readability
                if (prefix.substr(-1) !== '.') {
                    prefix = !!prefix ? prefix + '.' : '';
                }

                var deriveQualifiedKey = function(key) {
                    return prefix + key;
                };

                // Checks the browser to see if local storage is supported
                var browserSupportsLocalStorage = (function () {
                    try {
                        var supported = (storageType in $window && $window[storageType] !== null);

                        // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage
                        // is available, but trying to call .setItem throws an exception.
                        //
                        // "QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage
                        // that exceeded the quota."
                        var key = deriveQualifiedKey('__' + Math.round(Math.random() * 1e7));
                        if (supported) {
                            webStorage = $window[storageType];
                            webStorage.setItem(key, '');
                            webStorage.removeItem(key);
                        }

                        return supported;
                    } catch (e) {
                        storageType = 'cookie';
                        $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
                        return false;
                    }
                }());

                // Directly adds a value to local storage
                // If local storage is not available in the browser use cookies
                // Example use: $enLocalStorage.add('library','angular');
                var addToLocalStorage = function (key, value) {
                    // Let's convert undefined values to null to get the value consistent
                    if (isUndefined(value)) {
                        value = null;
                    } else {
                        value = toJson(value);
                    }

                    // If this browser does not support local storage use cookies
                    if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
                        if (!browserSupportsLocalStorage) {
                            $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
                        }

                        if (notify.setItem) {
                            $rootScope.$broadcast('LocalStorageModule.notification.setitem', {key: key, newvalue: value, storageType: 'cookie'});
                        }
                        return addToCookies(key, value);
                    }

                    try {
                        if (webStorage) {
                            webStorage.setItem(deriveQualifiedKey(key), value);
                        }
                        if (notify.setItem) {
                            $rootScope.$broadcast('LocalStorageModule.notification.setitem', {key: key, newvalue: value, storageType: self.storageType});
                        }
                    } catch (e) {
                        $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
                        return addToCookies(key, value);
                    }
                    return true;
                };

                // Directly get a value from local storage
                // Example use: $enLocalStorage.get('library'); // returns 'angular'
                var getFromLocalStorage = function (key) {

                    if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
                        if (!browserSupportsLocalStorage) {
                            $rootScope.$broadcast('LocalStorageModule.notification.warning','LOCAL_STORAGE_NOT_SUPPORTED');
                        }

                        return getFromCookies(key);
                    }

                    var item = webStorage ? webStorage.getItem(deriveQualifiedKey(key)) : null;
                    // angular.toJson will convert null to 'null', so a proper conversion is needed
                    // FIXME not a perfect solution, since a valid 'null' string can't be stored
                    if (!item || item === 'null') {
                        return null;
                    }

                    try {
                        return JSON.parse(item);
                    } catch (e) {
                        return item;
                    }
                };

                // Remove an item from local storage
                // Example use: $enLocalStorage.remove('library'); // removes the key/value pair of library='angular'
                var removeFromLocalStorage = function () {
                    var i, key;
                    for (i=0; i<arguments.length; i++) {
                        key = arguments[i];
                        if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
                            if (!browserSupportsLocalStorage) {
                                $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
                            }

                            if (notify.removeItem) {
                                $rootScope.$broadcast('LocalStorageModule.notification.removeitem', {key: key, storageType: 'cookie'});
                            }
                            removeFromCookies(key);
                        }
                        else {
                            try {
                                webStorage.removeItem(deriveQualifiedKey(key));
                                if (notify.removeItem) {
                                    $rootScope.$broadcast('LocalStorageModule.notification.removeitem', {
                                        key: key,
                                        storageType: self.storageType
                                    });
                                }
                            } catch (e) {
                                $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
                                removeFromCookies(key);
                            }
                        }
                    }
                };

                // Return array of keys for local storage
                // Example use: var keys = $enLocalStorage.keys()
                var getKeysForLocalStorage = function () {

                    if (!browserSupportsLocalStorage) {
                        $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
                        return false;
                    }

                    var prefixLength = prefix.length;
                    var keys = [];
                    for (var key in webStorage) {
                        // Only return keys that are for this app
                        if (key.substr(0,prefixLength) === prefix) {
                            try {
                                keys.push(key.substr(prefixLength));
                            } catch (e) {
                                $rootScope.$broadcast('LocalStorageModule.notification.error', e.Description);
                                return [];
                            }
                        }
                    }
                    return keys;
                };

                // Remove all data for this app from local storage
                // Also optionally takes a regular expression string and removes the matching key-value pairs
                // Example use: $enLocalStorage.clearAll();
                // Should be used mostly for development purposes
                var clearAllFromLocalStorage = function (regularExpression) {

                    // Setting both regular expressions independently
                    // Empty strings result in catchall RegExp
                    var prefixRegex = !!prefix ? new RegExp('^' + prefix) : new RegExp();
                    var testRegex = !!regularExpression ? new RegExp(regularExpression) : new RegExp();

                    if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
                        if (!browserSupportsLocalStorage) {
                            $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
                        }
                        return clearAllFromCookies();
                    }

                    var prefixLength = prefix.length;

                    for (var key in webStorage) {
                        // Only remove items that are for this app and match the regular expression
                        if (prefixRegex.test(key) && testRegex.test(key.substr(prefixLength))) {
                            try {
                                removeFromLocalStorage(key.substr(prefixLength));
                            } catch (e) {
                                $rootScope.$broadcast('LocalStorageModule.notification.error',e.message);
                                return clearAllFromCookies();
                            }
                        }
                    }
                    return true;
                };

                // Checks the browser to see if cookies are supported
                var browserSupportsCookies = (function() {
                    try {
                        return $window.navigator.cookieEnabled ||
                            ("cookie" in $document && ($document.cookie.length > 0 ||
                            ($document.cookie = "test").indexOf.call($document.cookie, "test") > -1));
                    } catch (e) {
                        $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
                        return false;
                    }
                }());

                // Directly adds a value to cookies
                // Typically used as a fallback is local storage is not available in the browser
                // Example use: $enLocalStorage.cookie.add('library','angular');
                var addToCookies = function (key, value, daysToExpiry) {

                    if (isUndefined(value)) {
                        return false;
                    } else if(isArray(value) || isObject(value)) {
                        value = toJson(value);
                    }

                    if (!browserSupportsCookies) {
                        $rootScope.$broadcast('LocalStorageModule.notification.error', 'COOKIES_NOT_SUPPORTED');
                        return false;
                    }

                    try {
                        var expiry = '',
                            expiryDate = new Date(),
                            cookieDomain = '';

                        if (value === null) {
                            // Mark that the cookie has expired one day ago
                            expiryDate.setTime(expiryDate.getTime() + (-1 * 24 * 60 * 60 * 1000));
                            expiry = "; expires=" + expiryDate.toGMTString();
                            value = '';
                        } else if (isNumber(daysToExpiry) && daysToExpiry !== 0) {
                            expiryDate.setTime(expiryDate.getTime() + (daysToExpiry * 24 * 60 * 60 * 1000));
                            expiry = "; expires=" + expiryDate.toGMTString();
                        } else if (cookie.expiry !== 0) {
                            expiryDate.setTime(expiryDate.getTime() + (cookie.expiry * 24 * 60 * 60 * 1000));
                            expiry = "; expires=" + expiryDate.toGMTString();
                        }
                        if (!!key) {
                            var cookiePath = "; path=" + cookie.path;
                            if(cookie.domain){
                                cookieDomain = "; domain=" + cookie.domain;
                            }
                            $document.cookie = deriveQualifiedKey(key) + "=" + encodeURIComponent(value) + expiry + cookiePath + cookieDomain;
                        }
                    } catch (e) {
                        $rootScope.$broadcast('LocalStorageModule.notification.error',e.message);
                        return false;
                    }
                    return true;
                };

                // Directly get a value from a cookie
                // Example use: $enLocalStorage.cookie.get('library'); // returns 'angular'
                var getFromCookies = function (key) {
                    if (!browserSupportsCookies) {
                        $rootScope.$broadcast('LocalStorageModule.notification.error', 'COOKIES_NOT_SUPPORTED');
                        return false;
                    }

                    var cookies = $document.cookie && $document.cookie.split(';') || [];
                    for(var i=0; i < cookies.length; i++) {
                        var thisCookie = cookies[i];
                        while (thisCookie.charAt(0) === ' ') {
                            thisCookie = thisCookie.substring(1,thisCookie.length);
                        }
                        if (thisCookie.indexOf(deriveQualifiedKey(key) + '=') === 0) {
                            var storedValues = decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length));
                            try {
                                return JSON.parse(storedValues);
                            } catch(e) {
                                return storedValues;
                            }
                        }
                    }
                    return null;
                };

                var removeFromCookies = function (key) {
                    addToCookies(key,null);
                };

                var clearAllFromCookies = function () {
                    var thisCookie = null, thisKey = null;
                    var prefixLength = prefix.length;
                    var cookies = $document.cookie.split(';');
                    for(var i = 0; i < cookies.length; i++) {
                        thisCookie = cookies[i];

                        while (thisCookie.charAt(0) === ' ') {
                            thisCookie = thisCookie.substring(1, thisCookie.length);
                        }

                        var key = thisCookie.substring(prefixLength, thisCookie.indexOf('='));
                        removeFromCookies(key);
                    }
                };

                var getStorageType = function() {
                    return storageType;
                };

                // Add a listener on scope variable to save its changes to local storage
                // Return a function which when called cancels binding
                var bindToScope = function(scope, key, def, lsKey) {
                    lsKey = lsKey || key;
                    var value = getFromLocalStorage(lsKey);

                    if (value === null && isDefined(def)) {
                        value = def;
                    } else if (isObject(value) && isObject(def)) {
                        value = extend(value, def);
                    }

                    $parse(key).assign(scope, value);

                    return scope.$watch(key, function(newVal) {
                        addToLocalStorage(lsKey, newVal);
                    }, isObject(scope[key]));
                };

                // Return $enLocalStorage.length
                // ignore keys that not owned
                var lengthOfLocalStorage = function() {
                    var count = 0;
                    var storage = $window[storageType];
                    for(var i = 0; i < storage.length; i++) {
                        if(storage.key(i).indexOf(prefix) === 0 ) {
                            count++;
                        }
                    }
                    return count;
                };

                return {
                    /**
                     * @ngdoc method
                     * @name $enLocalStorage#isSupported
                     *
                     * @description
                     * Checks to see if the browser in use supports localStorage.
                     *
                     *
                     * @returns {boolean}
                     */
                    isSupported: browserSupportsLocalStorage,
                    /**
                     * @ngdoc method
                     * @name $enLocalStorage#getStorageType
                     *
                     * @description
                     * Getter for the storage type currently in use.
                     *
                     *
                     * @returns {string} localStorage | sessionStorage
                     */
                    getStorageType: getStorageType,
                    /**
                     * @ngdoc method
                     * @name $enLocalStorage#set
                     *
                     * @description
                     * The key/value pair to add to localStorage.
                     *
                     *
                     * @param {string} [key]  The property name that will be used later to reference the value being set.
                     * @param {number|string|boolean|object} [value]  The value to be set.
                     *
                     * @returns {boolean} True if item was set, false if it was not.
                     */
                    set: addToLocalStorage,
                    add: addToLocalStorage, //DEPRECATED
                    /**
                     * @ngdoc method
                     * @name $enLocalStorage#get
                     *
                     * @description
                     * Retrieves a properties value from localStorage.
                     *
                     *
                     * @param {string} [key]  The property name used to retrieve a previously set value.
                     *
                     * @returns {number|string|boolean|object} Returns the keys value.
                     */
                    get: getFromLocalStorage,
                    /**
                     * @ngdoc method
                     * @name $enLocalStorage#keys
                     *
                     * @description
                     * Gets a lsit of all keys found in localStorage.
                     *
                     * <hljs lang="js">
                     *      var keyArray = $enLocalStorage.keys();
                     * </hljs>
                     *
                     *
                     * @returns {array} Local storage keys.
                     */
                    keys: getKeysForLocalStorage,
                    /**
                     * @ngdoc method
                     * @name $enLocalStorage#remove
                     *
                     * @description
                     * Removes a specific property from localStorage.
                     *
                     * <hljs lang="js">
                     *      $enLocalStorage.remove('customSetting');
                     * </hljs>
                     *
                     *
                     * @param {string} key The name of the key that is to be removed from localStorage.
                     */
                    remove: removeFromLocalStorage,
                    /**
                     * @ngdoc method
                     * @name $enLocalStorage#clearAll
                     *
                     * @description
                     * Removes all data from an apps localStorage.
                     *
                     * This method is better off being used mainly for development purposes only and could have ramifications in a production environment.
                     *
                     * <hljs lang="js">
                     *      $enLocalStorage.clearAll();  //clear all key/value pairs
                     *      $enLocalStorage.clearAll(/^setting/);  //clear all key/value pairs who's key starts with the word "setting"
                     * </hljs>
                     *
                     *
                     * @param {string=} regExpression If provided the clearAll method will only clear all key/value pairs from localStorage that match the regular expression argument given.
                     *
                     * @returns {boolean} True/False of whether the clear was successful.
                     */
                    clearAll: clearAllFromLocalStorage,
                    /**
                     * @ngdoc method
                     * @name $enLocalStorage#bind
                     *
                     * @description
                     * Adds a $watcher on a scope variable to save its changes to local storage. Returns a function which when called cancels the binding.
                     *
                     * <hljs lang="js">
                     *      var bindProp = $enLocalStorage.bind($scope, prop, def, lsKey); //to set the $watcher
                     *      bindProp(); // to cancel the watcher and remove the binding.
                     * </hljs>
                     *
                     *
                     * @param {object} scope The scope the watcher will be bound to.
                     * @param {string} prop The name of the scoped property (key name) to watch.
                     * @param {number|string|boolean|object} value The current value of $scope.prop to be set as the current localStorage value of prop.
                     * @param {string=} key Name of the localStorage key if different from `prop`.
                     *
                     * @returns {function} When called cancels the binding/$watcher.
                     */
                    bind: bindToScope,
                    /**
                     * @ngdoc method
                     * @name $enLocalStorage#deriveKey
                     *
                     * @description
                     * Prefixes a key name with the current $enLocalStorage.prefix property.  This method does not camelize the key name passed to it.
                     *
                     * <hljs lang="js">
                     *      var lsKey = $enLocalStorage.deriveKey('MyKey');
                     *      // returns lsKey = 'prefixMyKey';
                     * </hljs>
                     *
                     *
                     * @param {string} key Name of the localStorage key.
                     *
                     * @returns {string} Keyname prefixed with the $enLocalStorage.prefix.
                     */
                    deriveKey: deriveQualifiedKey,
                    /**
                     * @ngdoc method
                     * @name $enLocalStorage#length
                     *
                     * @description
                     * Gets a total count of all keys in storage that start with the $enLocalStorage.prefix property.
                     *
                     * <hljs lang="js">
                     *      // assume total of 50 local storage items.
                     *      // 23 of which are prefixed with the apps'
                     *      // $enLocalStorage.prefix of 'ls'
                     *
                     *      var lsLen = $enLocalStorage.length();  // returns 23;
                     * </hljs>
                     *
                     *
                     * @returns {number}
                     */
                    length: lengthOfLocalStorage,

                    cookie: {
                        isSupported: browserSupportsCookies,
                        set: addToCookies,
                        add: addToCookies, //DEPRECATED
                        get: getFromCookies,
                        remove: removeFromCookies,
                        clearAll: clearAllFromCookies
                    }
                };
            }];
        });
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */

// jshint ignore: start
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
    'use strict';

    var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
    var TEST_ELEMENT = document.createElement('div');

    var TYPE_FUNCTION = 'function';

    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;

    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }

    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }

    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */
    function each(obj, iterator, context) {
        var i;

        if (!obj) {
            return;
        }

        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge]
     * @returns {Object} dest
     */
    function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || (merge && dest[keys[i]] === undefined)) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }

    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    function merge(dest, src) {
        return extend(dest, src, true);
    }

    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */
    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;

        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;

        if (properties) {
            extend(childP, properties);
        }
    }

    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }

    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }

    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */
    function ifUndefined(val1, val2) {
        return (val1 === undefined) ? val2 : val1;
    }

    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
        });
    }

    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
        });
    }

    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }

    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }

    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }

    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }

    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }

    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;

        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }

        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }

        return results;
    }

    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);

        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = (prefix) ? prefix + camelProp : property;

            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }

    /**
     * get a unique id
     * @returns {number} uniqueId
     */
    var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }

    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */
    function getWindowForElement(element) {
        var doc = element.ownerDocument;
        return (doc.defaultView || doc.parentWindow);
    }

    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

    var SUPPORT_TOUCH = ('ontouchstart' in window);
    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

    var INPUT_TYPE_TOUCH = 'touch';
    var INPUT_TYPE_PEN = 'pen';
    var INPUT_TYPE_MOUSE = 'mouse';
    var INPUT_TYPE_KINECT = 'kinect';

    var COMPUTE_INTERVAL = 25;

    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;

    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;

    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

    var PROPS_XY = ['x', 'y'];
    var PROPS_CLIENT_XY = ['clientX', 'clientY'];

    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;

        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };

        this.init();

    }

    Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() { },

        /**
         * bind the events
         */
        init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },

        /**
         * unbind the events
         */
        destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };

    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;

        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new (Type)(manager, inputHandler);
    }

    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
        var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;

        if (isFirst) {
            manager.session = {};
        }

        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;

        // compute scale, rotation etc
        computeInputData(manager, input);

        // emit secret event
        manager.emit('hammer.input', input);

        manager.recognize(input);
        manager.session.prevInput = input;
    }

    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;

        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }

        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }

        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;

        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);

        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);

        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

        computeIntervalInputData(session, input);

        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }

    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};

        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };

            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }

        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }

    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity, velocityX, velocityY, direction;

        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = last.deltaX - input.deltaX;
            var deltaY = last.deltaY - input.deltaY;

            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);

            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }

        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }

    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }

        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }

    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */
    function getCenter(pointers) {
        var pointersLength = pointers.length;

        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }

        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }

        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }

    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }

    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }

        if (abs(x) >= abs(y)) {
            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }

    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];

        return Math.sqrt((x * x) + (y * y));
    }

    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }

    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }

    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };

    var MOUSE_ELEMENT_EVENTS = 'mousedown';
    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;

        this.allow = true; // used by Input.TouchMouse to disable mouse events
        this.pressed = false; // mousedown state

        Input.apply(this, arguments);
    }

    inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];

            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && ev.button === 0) {
                this.pressed = true;
            }

            if (eventType & INPUT_MOVE && ev.which !== 1) {
                eventType = INPUT_END;
            }

            // mouse must be down, and mouse events are allowed (see the TouchMouse input)
            if (!this.pressed || !this.allow) {
                return;
            }

            if (eventType & INPUT_END) {
                this.pressed = false;
            }

            this.callback(this.manager, eventType, {
                pointers: [ev],
                changedPointers: [ev],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            });
        }
    });

    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };

// in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };

    var POINTER_ELEMENT_EVENTS = 'pointerdown';
    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
    if (window.MSPointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
    }

    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;

        Input.apply(this, arguments);

        this.store = (this.manager.session.pointerEvents = []);
    }

    inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;

            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

            var isTouch = (pointerType == INPUT_TYPE_TOUCH);

            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, 'pointerId');

            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                removePointer = true;
            }

            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) {
                return;
            }

            // update the event in the store
            store[storeIndex] = ev;

            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [ev],
                pointerType: pointerType,
                srcEvent: ev
            });

            if (removePointer) {
                // remove from the store
                store.splice(storeIndex, 1);
            }
        }
    });

    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;

        Input.apply(this, arguments);
    }

    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

            // should we handle the touch events?
            if (type === INPUT_START) {
                this.started = true;
            }

            if (!this.started) {
                return;
            }

            var touches = normalizeSingleTouches.call(this, ev, type);

            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                this.started = false;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);

        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }

        return [all, changed];
    }

    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};

        Input.apply(this, arguments);
    }

    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
                return;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;

        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }

        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;

        // get target touches from touches
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
        });

        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }

        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }

            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }

        if (!changedTargetTouches.length) {
            return;
        }

        return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
            changedTargetTouches
        ];
    }

    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */
    function TouchMouseInput() {
        Input.apply(this, arguments);

        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
    }

    inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
                isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

            // when we're in a touch event, so  block all upcoming mouse events
            // most mobile browser also emit mouseevents, right after touchstart
            if (isTouch) {
                this.mouse.allow = false;
            } else if (isMouse && !this.mouse.allow) {
                return;
            }

            // reset the allowMouse when we're done
            if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
                this.mouse.allow = true;
            }

            this.callback(manager, inputEvent, inputData);
        },

        /**
         * remove the event listeners
         */
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });

    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
    var TOUCH_ACTION_COMPUTE = 'compute';
    var TOUCH_ACTION_AUTO = 'auto';
    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
    var TOUCH_ACTION_NONE = 'none';
    var TOUCH_ACTION_PAN_X = 'pan-x';
    var TOUCH_ACTION_PAN_Y = 'pan-y';

    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }

    TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) {
                value = this.compute();
            }

            if (NATIVE_TOUCH_ACTION) {
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
        },

        /**
         * just re-set the touchAction value
         */
        update: function() {
            this.set(this.manager.options.touchAction);
        },

        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [recognizer])) {
                    actions = actions.concat(recognizer.getTouchAction());
                }
            });
            return cleanTouchActions(actions.join(' '));
        },

        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
            // not needed with native support for the touchAction property
            if (NATIVE_TOUCH_ACTION) {
                return;
            }

            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;

            // if the touch action did prevented once this session
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return;
            }

            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE);
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

            if (hasNone ||
                (hasPanY && direction & DIRECTION_HORIZONTAL) ||
                (hasPanX && direction & DIRECTION_VERTICAL)) {
                return this.preventSrc(srcEvent);
            }
        },

        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };

    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }

        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

        // pan-x and pan-y can be combined
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
        }

        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }

        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }

        return TOUCH_ACTION_AUTO;
    }

    /**
     * Recognizer flow explained; *
     * All recognizers have the initial state of POSSIBLE when a input session starts.
     * The definition of a input session is from the first input until the last input, with all it's movement in it. *
     * Example session for mouse-input: mousedown -> mousemove -> mouseup
     *
     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
     * which determines with state it should be.
     *
     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
     * POSSIBLE to give it another change on the next cycle.
     *
     *               Possible
     *                  |
     *            +-----+---------------+
     *            |                     |
     *      +-----+-----+               |
     *      |           |               |
     *   Failed      Cancelled          |
     *                          +-------+------+
     *                          |              |
     *                      Recognized       Began
     *                                         |
     *                                      Changed
     *                                         |
     *                                  Ended/Recognized
     */
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;

    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer(options) {
        this.id = uniqueId();

        this.manager = null;
        this.options = merge(options || {}, this.defaults);

        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);

        this.state = STATE_POSSIBLE;

        this.simultaneous = {};
        this.requireFail = [];
    }

    Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},

        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
            extend(this.options, options);

            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },

        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                return this;
            }

            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },

        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },

        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                return this;
            }

            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },

        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
                this.requireFail.splice(index, 1);
            }
            return this;
        },

        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },

        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },

        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
            var self = this;
            var state = this.state;

            function emit(withState) {
                self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
            }

            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) {
                emit(true);
            }

            emit(); // simple 'eventName' events

            // panend and pancancel
            if (state >= STATE_ENDED) {
                emit(true);
            }
        },

        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
            if (this.canEmit()) {
                return this.emit(input);
            }
            // it's failing anyway
            this.state = STATE_FAILED;
        },

        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
            var i = 0;
            while (i < this.requireFail.length) {
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                    return false;
                }
                i++;
            }
            return true;
        },

        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = extend({}, inputData);

            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }

            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                this.state = STATE_POSSIBLE;
            }

            this.state = this.process(inputDataClone);

            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                this.tryEmit(inputDataClone);
            }
        },

        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) { }, // jshint ignore:line

        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() { },

        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() { }
    };

    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }

    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }

    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }

    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }

    inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
            /**
             * @type {Number}
             * @default 1
             */
            pointers: 1
        },

        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },

        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
            var state = this.state;
            var eventType = input.eventType;

            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);

            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
                if (eventType & INPUT_END) {
                    return state | STATE_ENDED;
                } else if (!(state & STATE_BEGAN)) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });

    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);

        this.pX = null;
        this.pY = null;
    }

    inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
            event: 'pan',
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },

        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
                actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
                actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
        },

        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;

            // lock to axis?
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },

        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) &&
                (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
        },

        emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;

            var direction = directionStr(input.direction);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }

            this._super.emit.call(this, input);
        }
    });

    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'pinch',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function(input) {
            return this._super.attrTest.call(this, input) &&
                (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },

        emit: function(input) {
            this._super.emit.call(this, input);
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? 'in' : 'out';
                this.manager.emit(this.options.event + inOut, input);
            }
        }
    });

    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);

        this._timer = null;
        this._input = null;
    }

    inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
            event: 'press',
            pointers: 1,
            time: 500, // minimal time of the pointer to be pressed
            threshold: 5 // a minimal movement is ok, but keep it low
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
        },

        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;

            this._input = input;

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
                this.reset();
            } else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },

        reset: function() {
            clearTimeout(this._timer);
        },

        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
                return;
            }

            if (input && (input.eventType & INPUT_END)) {
                this.manager.emit(this.options.event + 'up', input);
            } else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
            event: 'rotate',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function(input) {
            return this._super.attrTest.call(this, input) &&
                (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });

    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
            event: 'swipe',
            threshold: 10,
            velocity: 0.65,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },

        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },

        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;

            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                velocity = input.velocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
                velocity = input.velocityX;
            } else if (direction & DIRECTION_VERTICAL) {
                velocity = input.velocityY;
            }

            return this._super.attrTest.call(this, input) &&
                direction & input.direction &&
                input.distance > this.options.threshold &&
                abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },

        emit: function(input) {
            var direction = directionStr(input.direction);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }

            this.manager.emit(this.options.event, input);
        }
    });

    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);

        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;

        this._timer = null;
        this._input = null;
        this.count = 0;
    }

    inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'tap',
            pointers: 1,
            taps: 1,
            interval: 300, // max time between the multi-tap taps
            time: 250, // max time of the pointer to be down (like finger on the screen)
            threshold: 2, // a minimal movement is ok, but keep it low
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
        },

        process: function(input) {
            var options = this.options;

            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;

            this.reset();

            if ((input.eventType & INPUT_START) && (this.count === 0)) {
                return this.failTimeout();
            }

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) {
                    return this.failTimeout();
                }

                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

                this.pTime = input.timeStamp;
                this.pCenter = input.center;

                if (!validMultiTap || !validInterval) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }

                this._input = input;

                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },

        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },

        reset: function() {
            clearTimeout(this._timer);
        },

        emit: function() {
            if (this.state == STATE_RECOGNIZED ) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Simple way to create an manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }

    /**
     * @const {string}
     */
    Hammer.VERSION = '2.0.4';

    /**
     * default settings
     * @namespace
     */
    Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,

        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,

        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,

        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,

        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,

        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [RotateRecognizer, { enable: false }],
            [PinchRecognizer, { enable: false }, ['rotate']],
            [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
            [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
            [TapRecognizer],
            [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
            [PressRecognizer]
        ],

        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
            /**
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',

            /**
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: 'none',

            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',

            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',

            /**
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',

            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };

    var STOP = 1;
    var FORCED_STOP = 2;

    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager(element, options) {
        options = options || {};

        this.options = merge(options, Hammer.defaults);
        this.options.inputTarget = this.options.inputTarget || element;

        this.handlers = {};
        this.session = {};
        this.recognizers = [];

        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);

        toggleCssProps(this, true);

        each(options.recognizers, function(item) {
            var recognizer = this.add(new (item[0])(item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }

    Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
            extend(this.options, options);

            // Options that need a little more setup
            if (options.touchAction) {
                this.touchAction.update();
            }
            if (options.inputTarget) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },

        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },

        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
                return;
            }

            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);

            var recognizer;
            var recognizers = this.recognizers;

            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;

            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
                curRecognizer = session.curRecognizer = null;
            }

            var i = 0;
            while (i < recognizers.length) {
                recognizer = recognizers[i];

                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                    recognizer.recognize(inputData);
                } else {
                    recognizer.reset();
                }

                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },

        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
                return recognizer;
            }

            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
                if (recognizers[i].options.event == recognizer) {
                    return recognizers[i];
                }
            }
            return null;
        },

        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
            if (invokeArrayArg(recognizer, 'add', this)) {
                return this;
            }

            // remove existing
            var existing = this.get(recognizer.options.event);
            if (existing) {
                this.remove(existing);
            }

            this.recognizers.push(recognizer);
            recognizer.manager = this;

            this.touchAction.update();
            return recognizer;
        },

        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
            if (invokeArrayArg(recognizer, 'remove', this)) {
                return this;
            }

            var recognizers = this.recognizers;
            recognizer = this.get(recognizer);
            recognizers.splice(inArray(recognizers, recognizer), 1);

            this.touchAction.update();
            return this;
        },

        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },

        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) {
                    delete handlers[event];
                } else {
                    handlers[event].splice(inArray(handlers[event], handler), 1);
                }
            });
            return this;
        },

        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) {
                triggerDomEvent(event, data);
            }

            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
                return;
            }

            data.type = event;
            data.preventDefault = function() {
                data.srcEvent.preventDefault();
            };

            var i = 0;
            while (i < handlers.length) {
                handlers[i](data);
                i++;
            }
        },

        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
            this.element && toggleCssProps(this, false);

            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };

    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        each(manager.options.cssProps, function(value, name) {
            element.style[prefixed(element.style, name)] = add ? value : '';
        });
    }

    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }

    extend(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,

        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,

        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,

        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,

        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,

        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,

        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });

    if (typeof define == TYPE_FUNCTION && define.amd) {
        define(function() {
            return Hammer;
        });
    } else if (typeof module != 'undefined' && module.exports) {
        module.exports = Hammer;
    } else {
        window[exportName] = Hammer;
    }

})(window, document, 'Hammer');


(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        window.propagating = factory();
    }
}(function () {
    var _firstTarget = null; // singleton, will contain the target element where the touch event started
    var _processing = false; // singleton, true when a touch event is being handled

    /**
     * Extend an Hammer.js instance with event propagation.
     *
     * Features:
     * - Events emitted by hammer will propagate in order from child to parent
     *   elements.
     * - Events are extended with a function `event.stopPropagation()` to stop
     *   propagation to parent elements.
     * - An option `preventDefault` to stop all default browser behavior.
     *
     * Usage:
     *   var hammer = propagatingHammer(new Hammer(element));
     *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});
     *
     * @param {Hammer.Manager} hammer   An hammer instance.
     * @param {Object} [options]        Available options:
     *                                  - `preventDefault: true | 'mouse' | 'touch' | 'pen'`.
     *                                    Enforce preventing the default browser behavior.
     *                                    Cannot be set to `false`.
     * @return {Hammer.Manager} Returns the same hammer instance with extended
     *                          functionality
     */
    return function propagating(hammer, options) {
        if (options && options.preventDefault === false) {
            throw new Error('Only supports preventDefault == true');
        }
        var _options = options || {
                preventDefault: false
            };

        if (hammer.Manager) {
            // This looks like the Hammer constructor.
            // Overload the constructors with our own.
            var Hammer = hammer;

            var PropagatingHammer = function(element, options) {
                return propagating(new Hammer(element, options), _options);
            };
            Hammer.extend(PropagatingHammer, Hammer);
            PropagatingHammer.Manager = function (element, options) {
                return propagating(new Hammer.Manager(element, options), _options);
            };

            return PropagatingHammer;
        }

        // attach to DOM element
        var element = hammer.element;
        element.hammer = hammer;

        // move the original functions that we will wrap
        hammer._on = hammer.on;
        hammer._off = hammer.off;
        hammer._emit = hammer.emit;
        hammer._destroy = hammer.destroy;

        /** @type {Object.<String, Array.<function>>} */
        hammer._handlers = {};

        // register an event to catch the start of a gesture and store the
        // target in a singleton
        hammer._on('hammer.input', function (event) {
            if (_options.preventDefault === true || (_options.preventDefault === event.pointerType)) {
                event.preventDefault();
            }
            if (event.isFirst) {
                _firstTarget = event.target;
                _processing = true;
            }
            if (event.isFinal) {
                _processing = false;
            }
        });

        /**
         * Register a handler for one or multiple events
         * @param {String} events    A space separated string with events
         * @param {function} handler A callback function, called as handler(event)
         * @returns {Hammer.Manager} Returns the hammer instance
         */
        hammer.on = function (events, handler) {
            // register the handler
            split(events).forEach(function (event) {
                var _handlers = hammer._handlers[event];
                if (!_handlers) {
                    hammer._handlers[event] = _handlers = [];

                    // register the static, propagated handler
                    hammer._on(event, propagatedHandler);
                }
                _handlers.push(handler);
            });

            return hammer;
        };

        /**
         * Unregister a handler for one or multiple events
         * @param {String} events      A space separated string with events
         * @param {function} [handler] Optional. The registered handler. If not
         *                             provided, all handlers for given events
         *                             are removed.
         * @returns {Hammer.Manager}   Returns the hammer instance
         */
        hammer.off = function (events, handler) {
            // unregister the handler
            split(events).forEach(function (event) {
                var _handlers = hammer._handlers[event];
                if (_handlers) {
                    _handlers = handler ? _handlers.filter(function (h) {
                        return h !== handler;
                    }) : [];

                    if (_handlers.length > 0) {
                        hammer._handlers[event] = _handlers;
                    }
                    else {
                        // remove static, propagated handler
                        hammer._off(event, propagatedHandler);
                        delete hammer._handlers[event];
                    }
                }
            });

            return hammer;
        };

        /**
         * Emit to the event listeners
         * @param {string} eventType
         * @param {Event} event
         */
        hammer.emit = function(eventType, event) {
            if (!_processing) {
                _firstTarget = event.target;
            }
            hammer._emit(eventType, event);
        };

        hammer.destroy = function () {
            // Detach from DOM element
            var element = hammer.element;
            delete element.hammer;

            // clear all handlers
            hammer._handlers = {};

            // call original hammer destroy
            hammer._destroy();
        };

        // split a string with space separated words
        function split(events) {
            return events.match(/[^ ]+/g);
        }

        /**
         * A static event handler, applying event propagation.
         * @param {Object} event
         */
        function propagatedHandler(event) {
            // let only a single hammer instance handle this event
            if (event.type !== 'hammer.input') {
                // it is possible that the same srcEvent is used with multiple hammer events,
                // we keep track on which events are handled in an object _handled
                if (!event.srcEvent._handled) {
                    event.srcEvent._handled = {};
                }

                if (event.srcEvent._handled[event.type]) {
                    return;
                }
                else {
                    event.srcEvent._handled[event.type] = true;
                }
            }

            // attach a stopPropagation function to the event
            var stopped = false;
            event.stopPropagation = function () {
                stopped = true;
            };

            // attach firstTarget property to the event
            event.firstTarget = _firstTarget;

            // propagate over all elements (until stopped)
            var elem = _firstTarget;
            while (elem && !stopped) {
                var _handlers = elem.hammer && elem.hammer._handlers[event.type];
                if (_handlers) {
                    for (var i = 0; i < _handlers.length && !stopped; i++) {
                        _handlers[i](event);
                    }
                }

                elem = elem.parentNode;
            }
        }

        return hammer;
    };
}));
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * @ngdoc service
 * @name $enTouch
 * @module enspire.ui.core
 * 
 * @returns {object} $enTouch factory object.
 * 
 * @description
 * Creates the ground work for an applications touch interface.
 * 
 * > **Note:** This module is, at the moment, poorly documented.
 */

angular.module('enspire.ui.core')
    .factory('$enTouch', ['$document',
    function($document) {

        var $touch = {};

        /*To detect microsoft touch devices*/
        function isTouchDevice() {
            return (('ontouchstart' in window) || (navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0) || ('onmsgesturechange' in window));
        }

        /**
         * @ngdoc method
         * @name $enTouch#isTouch
         *
         * @description
         * Determines if the device in use is a touch device.
         *
         * @returns {boolean} True if the device supports touch, false if it does not.
         */
        $touch.isTouch = isTouchDevice();

        //This is for CSS reason.. it allows you to easily put your hover events behind it so they don't show on touch devices
        if($touch.isTouch){
            $document.find('body').addClass('touch');
        }else{
            $document.find('body').addClass('no-touch');
        }

        /**
         * @ngdoc method
         * @name $enTouch#element
         *
         * @description
         * Create a Hammer object for the passed element.
         *
         * @param {object} element The html element returned by angular.
         *
         * @returns {object} Returns a Hammer object.
         */
        $touch.element = function(elm){
            return propagating(new Hammer(elm[0]));
        };

        return $touch;
    }
]);
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.action
     */
    //Creates the action module.
    angular.module('enspire.ui.components.action', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.adapter
     * @description
     * `en-adapter` module.
     *
     */

    angular.module('enspire.ui.components.adapter', []);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.alert
     */
    //Creates the alert module.
    angular.module('enspire.ui.components.alert', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.anchorScroll
     */
    //Creates the alert module.
    angular.module('enspire.ui.components.anchorScroll', ['enspire.ui.core']).run(["$rootScope", "$enAnchorScroll", "$timeout", function($rootScope,$enAnchorScroll,$timeout){
        $rootScope.$enAnchorScroll = function (id){
            $timeout(function(){ $enAnchorScroll.scrollTo(id); });
        };
    }]);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.api
     */
    //Creates the alert module.
    angular.module('enspire.ui.components.api', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.auth
     */

    angular.module('enspire.ui.components.auth', ['enspire.ui.core']);

    /**
     * @ngdoc directive
     * @name enAuth
     * @module enspire.ui.components.auth
     * @restrict E
     * @description
     * Creates styled login and registration forms.
     *
     * @element en-panel
     *
     * @usage
     * <hljs lang="html">
     *   <div class="auth-view">
     *      <en-panel class="panel-auth">
     *   </div>
     * </hljs>
     *
     */

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * @ngdoc module
 * @name enspire.ui.components.autocomplete
 */

angular.module('enspire.ui.components.autocomplete', ['enspire.ui.core']);

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.autofocus
     * @description
     * `en-autofocus` module.
     *
     */

    angular.module('enspire.ui.components.autofocus', []);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.body
     */

    angular.module('enspire.ui.components.body', ['enspire.ui.core']);
    
    /**
     * @ngdoc directive
     * @name enBody
     * @module enspire.ui.components.body
     * @restrict E
     * @description
     * `en-body` creates a styled body element.
     *
     * @element en-body
     *
     * @usage
     * <hljs lang="html">
     *   <en-body> ... </en-body>
     * </hljs>
     *
     */

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.button
     */

    angular.module('enspire.ui.components.button', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.buttonGroup
     */

    angular.module('enspire.ui.components.buttonGroup', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.checklistModel
     */
    //Creates the alert module.
    angular.module('enspire.ui.components.checklistModel', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.clipboard
     */
    angular.module('enspire.ui.components.clipboard', ['enspire.ui.core']);
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.collapse
     */
    angular.module('enspire.ui.components.collapse', ['enspire.ui.core']);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.collection
     * @description
     *
     *  App `<en-collection>` directive..
     *
     */
    angular.module('enspire.ui.components.collection', [
        'enspire.ui.core'
    ]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

   /**
     * @ngdoc module
     * @name enspire.ui.components.collectionRepeat
     * @description
     * `en-collection-repeat` module.
     *
     */
    angular.module('enspire.ui.components.collectionRepeat', []);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.colorwheel
     */

    angular.module('enspire.ui.components.colorwheel', ['enspire.ui.core']);

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.content
     * @description
     *
     *  App `<en-content>` directive..
     *
     */
    angular.module('enspire.ui.components.content', [
        'enspire.ui.core'
    ]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.control
     */

    angular.module('enspire.ui.components.control', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.correlation
     * @description
     * `en-correlation` module.
     *
     */

    angular.module('enspire.ui.components.correlation', []);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.datepicker
     */

    angular.module('enspire.ui.components.datepicker', ['enspire.ui.core'])
        .config(DatePickerConfig);


    function DatePickerConfig($enDatePickerProvider){

        var defaults = {
            dateOutput      : 'UTC',
            dateDisplay     : 'MM/dd/yyyy',
            dateRangeType   : null,
            prevButton      : '<en-icon icon="chevron-left"></en-icon>',
            nextButton      : '<en-icon icon="chevron-right"></en-icon>',
            template        : calendarTemplate
        };

        angular.extend($enDatePickerProvider.defaults, defaults);

        function calendarTemplate(){
                var cal = ''+
                    '<div class="datepicker-calendar" tabindex="0" ng-blur="hideCalendar()">' +
                    //month+year header
                    '<div class="cal-header">' +
                    '   <div class="cal-header-btn">' +
                    '       <a href="javascript:void(0)" ng-show="!showYearsPagination" en-tap="prevMonth()">' + defaults.prevButton + '</a>' +
                    '       <a href="javascript:void(0)" ng-show="showYearsPagination" en-tap="paginateYears(paginationYears[0])">' + defaults.prevButton + '</a>' +
                    '   </div>' +
                    '   <div class="cal-header-middle cal-month" ng-show="!showYearsPagination">' +
                    '       <span>{{month}}</span>' +
                    '       <a href="javascript:void(0)" en-tap="showYearsPagination = !showYearsPagination">' +
                    '           <span>' +
                    '               {{year}} <i ng-if="!showYearsPagination">&dtrif;</i> <i ng-if="showYearsPagination">&urtri;</i> ' +
                    '           </span>' +
                    '       </a>' +
                    '   </div>' +
                    '   <div class="cal-header-middle cal-month" ng-show="showYearsPagination">' +
                    '       Year:' +
                    '       <a href="javascript:void(0)" en-tap="showYearsPagination = !showYearsPagination">' +
                    '           <span>' +
                    '               {{year}} <i ng-if="!showYearsPagination">&dtrif;</i> <i ng-if="showYearsPagination">&urtri;</i> ' +
                    '           </span>' +
                    '       </a>' +
                    '   </div>' +
                    '   <div class="cal-header-btn">' +
                    '       <a href="javascript:void(0)" ng-show="!showYearsPagination" en-tap="nextMonth()">' + defaults.nextButton + '</a>' +
                    '       <a href="javascript:void(0)" ng-show="showYearsPagination" en-tap="paginateYears(paginationYears[paginationYears.length -1 ])">' + defaults.nextButton + '</a>' +
                    '   </div>' +
                    '</div>' +
                    //years pagination body
                    '<div class="cal-header" ng-show="showYearsPagination">' +
                    '   <div class="cal-years-pagination">' +
                    '       <span ' +
                    '           ng-class="{\'datepicker-active\': y === year, \'datepicker-disabled\': !isSelectableMaxYear(y) || !isSelectableMinYear(y)}" ' +
                    '           en-tap="setYear(y)" ' +
                    '           ng-repeat="y in paginationYears">' +
                    '           {{y}}' +
                    '       </span>' +
                    '   </div>' +
                    '</div>' +
                    //days column headers
                    '<div class="cal-days-header" ng-show="!showYearsPagination">' +
                    '   <div ng-repeat="d in daysInString"> {{d}} </div> ' +
                    '</div>' +
                    //days
                    '<div class="cal-body" ng-show="!showYearsPagination">' +
                    '   <a ng-repeat="px in prevMonthDays" class="cal-day datepicker-disabled">{{px}}</a>' +
                    '   <a ng-repeat="item in days" en-tap="setDatepickerDay(item)" ng-class="{\'datepicker-active\': day === item, \'datepicker-disabled\': !isSelectableMinDate(year + \'/\' + monthNumber + \'/\' + item ) || !isSelectableMaxDate(year + \'/\' + monthNumber + \'/\' + item)}" class="cal-day">{{item}}</a>' +
                    '   <a ng-repeat="nx in nextMonthDays" class="cal-day datepicker-disabled">{{nx}}</a>' +
                    '</div>' +
                    '</div>' +
                    '</div>';
                return cal;
            }
    }
    DatePickerConfig.$inject = ["$enDatePickerProvider"];



})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.dnd
     * @description
     *
     *  Drag & Drop Component
     *
     */
    angular.module('enspire.ui.components.dnd', [])
    /**
    * This workaround handles the fact that Internet Explorer does not support drag types other than
    * "Text" and "URL". That means we can not know whether the data comes from one of our elements or
    * is just some other data like a text selection. As a workaround we save the isDragging flag in
    * here. When a dropover event occurs, we only allow the drop if we are already dragging, because
    * that means the element is ours.
    */
    .factory('dndDragTypeWorkaround', function(){ return {} })

    /**
    * Chrome on Windows does not set the dropEffect field, which we need in dragend to determine
    * whether a drag operation was successful. Therefore we have to maintain it in this global
    * variable. The bug report for that has been open for years:
    * https://code.google.com/p/chromium/issues/detail?id=39399
    */
    .factory('dndDropEffectWorkaround', function(){ return {} });



})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.draggable
     * @description
     *
     *  `en-draggable` module.
     *
     */
    angular.module('enspire.ui.components.draggable', []);
})();


/**
 * 11kb minified package
 *
 * Other installation options:
 * - bower install draggabilly
 * - npm install draggabilly
 *
 * Installed here to keep it self contained, if en-draggable
 * is refactored this library dependency goes away.
 */

/* jshint ignore:start */
try {

    /*!
     * Draggabilly PACKAGED v1.2.1
     * Make that shiz draggable
     * http://draggabilly.desandro.com
     * MIT license
     */
    !function(t){function e(){}function n(t){function n(e){e.prototype.option||(e.prototype.option=function(e){t.isPlainObject(e)&&(this.options=t.extend(!0,this.options,e))})}function o(e,n){t.fn[e]=function(o){if("string"==typeof o){for(var s=i.call(arguments,1),a=0,p=this.length;p>a;a++){var u=this[a],d=t.data(u,e);if(d)if(t.isFunction(d[o])&&"_"!==o.charAt(0)){var c=d[o].apply(d,s);if(void 0!==c)return c}else r("no such method '"+o+"' for "+e+" instance");else r("cannot call methods on "+e+" prior to initialization; attempted to call '"+o+"'")}return this}return this.each(function(){var i=t.data(this,e);i?(i.option(o),i._init()):(i=new n(this,o),t.data(this,e,i))})}}if(t){var r="undefined"==typeof console?e:function(t){console.error(t)};return t.bridget=function(t,e){n(e),o(t,e)},t.bridget}}var i=Array.prototype.slice;"function"==typeof define&&define.amd?define("jquery-bridget/jquery.bridget",["jquery"],n):n("object"==typeof exports?require("jquery"):t.jQuery)}(window),function(t){function e(t){return new RegExp("(^|\\s+)"+t+"(\\s+|$)")}function n(t,e){var n=i(t,e)?r:o;n(t,e)}var i,o,r;"classList"in document.documentElement?(i=function(t,e){return t.classList.contains(e)},o=function(t,e){t.classList.add(e)},r=function(t,e){t.classList.remove(e)}):(i=function(t,n){return e(n).test(t.className)},o=function(t,e){i(t,e)||(t.className=t.className+" "+e)},r=function(t,n){t.className=t.className.replace(e(n)," ")});var s={hasClass:i,addClass:o,removeClass:r,toggleClass:n,has:i,add:o,remove:r,toggle:n};"function"==typeof define&&define.amd?define("classie/classie",s):"object"==typeof exports?module.exports=s:t.classie=s}(window),function(t){function e(t){if(t){if("string"==typeof i[t])return t;t=t.charAt(0).toUpperCase()+t.slice(1);for(var e,o=0,r=n.length;r>o;o++)if(e=n[o]+t,"string"==typeof i[e])return e}}var n="Webkit Moz ms Ms O".split(" "),i=document.documentElement.style;"function"==typeof define&&define.amd?define("get-style-property/get-style-property",[],function(){return e}):"object"==typeof exports?module.exports=e:t.getStyleProperty=e}(window),function(t){function e(t){var e=parseFloat(t),n=-1===t.indexOf("%")&&!isNaN(e);return n&&e}function n(){}function i(){for(var t={width:0,height:0,innerWidth:0,innerHeight:0,outerWidth:0,outerHeight:0},e=0,n=s.length;n>e;e++){var i=s[e];t[i]=0}return t}function o(n){function o(){if(!h){h=!0;var i=t.getComputedStyle;if(u=function(){var t=i?function(t){return i(t,null)}:function(t){return t.currentStyle};return function(e){var n=t(e);return n||r("Style returned "+n+". Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1"),n}}(),d=n("boxSizing")){var o=document.createElement("div");o.style.width="200px",o.style.padding="1px 2px 3px 4px",o.style.borderStyle="solid",o.style.borderWidth="1px 2px 3px 4px",o.style[d]="border-box";var s=document.body||document.documentElement;s.appendChild(o);var a=u(o);c=200===e(a.width),s.removeChild(o)}}}function a(t){if(o(),"string"==typeof t&&(t=document.querySelector(t)),t&&"object"==typeof t&&t.nodeType){var n=u(t);if("none"===n.display)return i();var r={};r.width=t.offsetWidth,r.height=t.offsetHeight;for(var a=r.isBorderBox=!(!d||!n[d]||"border-box"!==n[d]),h=0,f=s.length;f>h;h++){var l=s[h],g=n[l];g=p(t,g);var v=parseFloat(g);r[l]=isNaN(v)?0:v}var y=r.paddingLeft+r.paddingRight,m=r.paddingTop+r.paddingBottom,E=r.marginLeft+r.marginRight,b=r.marginTop+r.marginBottom,P=r.borderLeftWidth+r.borderRightWidth,x=r.borderTopWidth+r.borderBottomWidth,_=a&&c,w=e(n.width);w!==!1&&(r.width=w+(_?0:y+P));var S=e(n.height);return S!==!1&&(r.height=S+(_?0:m+x)),r.innerWidth=r.width-(y+P),r.innerHeight=r.height-(m+x),r.outerWidth=r.width+E,r.outerHeight=r.height+b,r}}function p(e,n){if(t.getComputedStyle||-1===n.indexOf("%"))return n;var i=e.style,o=i.left,r=e.runtimeStyle,s=r&&r.left;return s&&(r.left=e.currentStyle.left),i.left=n,n=i.pixelLeft,i.left=o,s&&(r.left=s),n}var u,d,c,h=!1;return a}var r="undefined"==typeof console?n:function(t){console.error(t)},s=["paddingLeft","paddingRight","paddingTop","paddingBottom","marginLeft","marginRight","marginTop","marginBottom","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth"];"function"==typeof define&&define.amd?define("get-size/get-size",["get-style-property/get-style-property"],o):"object"==typeof exports?module.exports=o(require("desandro-get-style-property")):t.getSize=o(t.getStyleProperty)}(window),function(t){function e(e){var n=t.event;return n.target=n.target||n.srcElement||e,n}var n=document.documentElement,i=function(){};n.addEventListener?i=function(t,e,n){t.addEventListener(e,n,!1)}:n.attachEvent&&(i=function(t,n,i){t[n+i]=i.handleEvent?function(){var n=e(t);i.handleEvent.call(i,n)}:function(){var n=e(t);i.call(t,n)},t.attachEvent("on"+n,t[n+i])});var o=function(){};n.removeEventListener?o=function(t,e,n){t.removeEventListener(e,n,!1)}:n.detachEvent&&(o=function(t,e,n){t.detachEvent("on"+e,t[e+n]);try{delete t[e+n]}catch(i){t[e+n]=void 0}});var r={bind:i,unbind:o};"function"==typeof define&&define.amd?define("eventie/eventie",r):"object"==typeof exports?module.exports=r:t.eventie=r}(window),function(){function t(){}function e(t,e){for(var n=t.length;n--;)if(t[n].listener===e)return n;return-1}function n(t){return function(){return this[t].apply(this,arguments)}}var i=t.prototype,o=this,r=o.EventEmitter;i.getListeners=function(t){var e,n,i=this._getEvents();if(t instanceof RegExp){e={};for(n in i)i.hasOwnProperty(n)&&t.test(n)&&(e[n]=i[n])}else e=i[t]||(i[t]=[]);return e},i.flattenListeners=function(t){var e,n=[];for(e=0;e<t.length;e+=1)n.push(t[e].listener);return n},i.getListenersAsObject=function(t){var e,n=this.getListeners(t);return n instanceof Array&&(e={},e[t]=n),e||n},i.addListener=function(t,n){var i,o=this.getListenersAsObject(t),r="object"==typeof n;for(i in o)o.hasOwnProperty(i)&&-1===e(o[i],n)&&o[i].push(r?n:{listener:n,once:!1});return this},i.on=n("addListener"),i.addOnceListener=function(t,e){return this.addListener(t,{listener:e,once:!0})},i.once=n("addOnceListener"),i.defineEvent=function(t){return this.getListeners(t),this},i.defineEvents=function(t){for(var e=0;e<t.length;e+=1)this.defineEvent(t[e]);return this},i.removeListener=function(t,n){var i,o,r=this.getListenersAsObject(t);for(o in r)r.hasOwnProperty(o)&&(i=e(r[o],n),-1!==i&&r[o].splice(i,1));return this},i.off=n("removeListener"),i.addListeners=function(t,e){return this.manipulateListeners(!1,t,e)},i.removeListeners=function(t,e){return this.manipulateListeners(!0,t,e)},i.manipulateListeners=function(t,e,n){var i,o,r=t?this.removeListener:this.addListener,s=t?this.removeListeners:this.addListeners;if("object"!=typeof e||e instanceof RegExp)for(i=n.length;i--;)r.call(this,e,n[i]);else for(i in e)e.hasOwnProperty(i)&&(o=e[i])&&("function"==typeof o?r.call(this,i,o):s.call(this,i,o));return this},i.removeEvent=function(t){var e,n=typeof t,i=this._getEvents();if("string"===n)delete i[t];else if(t instanceof RegExp)for(e in i)i.hasOwnProperty(e)&&t.test(e)&&delete i[e];else delete this._events;return this},i.removeAllListeners=n("removeEvent"),i.emitEvent=function(t,e){var n,i,o,r,s=this.getListenersAsObject(t);for(o in s)if(s.hasOwnProperty(o))for(i=s[o].length;i--;)n=s[o][i],n.once===!0&&this.removeListener(t,n.listener),r=n.listener.apply(this,e||[]),r===this._getOnceReturnValue()&&this.removeListener(t,n.listener);return this},i.trigger=n("emitEvent"),i.emit=function(t){var e=Array.prototype.slice.call(arguments,1);return this.emitEvent(t,e)},i.setOnceReturnValue=function(t){return this._onceReturnValue=t,this},i._getOnceReturnValue=function(){return this.hasOwnProperty("_onceReturnValue")?this._onceReturnValue:!0},i._getEvents=function(){return this._events||(this._events={})},t.noConflict=function(){return o.EventEmitter=r,t},"function"==typeof define&&define.amd?define("eventEmitter/EventEmitter",[],function(){return t}):"object"==typeof module&&module.exports?module.exports=t:o.EventEmitter=t}.call(this),function(t,e){"function"==typeof define&&define.amd?define("unipointer/unipointer",["eventEmitter/EventEmitter","eventie/eventie"],function(n,i){return e(t,n,i)}):"object"==typeof exports?module.exports=e(t,require("wolfy87-eventemitter"),require("eventie")):t.Unipointer=e(t,t.EventEmitter,t.eventie)}(window,function(t,e,n){function i(){}function o(){}o.prototype=new e,o.prototype.bindStartEvent=function(t){this._bindStartEvent(t,!0)},o.prototype.unbindStartEvent=function(t){this._bindStartEvent(t,!1)},o.prototype._bindStartEvent=function(e,i){i=void 0===i?!0:!!i;var o=i?"bind":"unbind";t.navigator.pointerEnabled?n[o](e,"pointerdown",this):t.navigator.msPointerEnabled?n[o](e,"MSPointerDown",this):(n[o](e,"mousedown",this),n[o](e,"touchstart",this))},o.prototype.handleEvent=function(t){var e="on"+t.type;this[e]&&this[e](t)},o.prototype.getTouch=function(t){for(var e=0,n=t.length;n>e;e++){var i=t[e];if(i.identifier==this.pointerIdentifier)return i}},o.prototype.onmousedown=function(t){var e=t.button;e&&0!==e&&1!==e||this._pointerDown(t,t)},o.prototype.ontouchstart=function(t){this._pointerDown(t,t.changedTouches[0])},o.prototype.onMSPointerDown=o.prototype.onpointerdown=function(t){this._pointerDown(t,t)},o.prototype._pointerDown=function(t,e){this.isPointerDown||(this.isPointerDown=!0,this.pointerIdentifier=void 0!==e.pointerId?e.pointerId:e.identifier,this.pointerDown(t,e))},o.prototype.pointerDown=function(t,e){this._bindPostStartEvents(t),this.emitEvent("pointerDown",[t,e])};var r={mousedown:["mousemove","mouseup"],touchstart:["touchmove","touchend","touchcancel"],pointerdown:["pointermove","pointerup","pointercancel"],MSPointerDown:["MSPointerMove","MSPointerUp","MSPointerCancel"]};return o.prototype._bindPostStartEvents=function(e){if(e){for(var i=r[e.type],o=e.preventDefault?t:document,s=0,a=i.length;a>s;s++){var p=i[s];n.bind(o,p,this)}this._boundPointerEvents={events:i,node:o}}},o.prototype._unbindPostStartEvents=function(){var t=this._boundPointerEvents;if(t&&t.events){for(var e=0,i=t.events.length;i>e;e++){var o=t.events[e];n.unbind(t.node,o,this)}delete this._boundPointerEvents}},o.prototype.onmousemove=function(t){this._pointerMove(t,t)},o.prototype.onMSPointerMove=o.prototype.onpointermove=function(t){t.pointerId==this.pointerIdentifier&&this._pointerMove(t,t)},o.prototype.ontouchmove=function(t){var e=this.getTouch(t.changedTouches);e&&this._pointerMove(t,e)},o.prototype._pointerMove=function(t,e){this.pointerMove(t,e)},o.prototype.pointerMove=function(t,e){this.emitEvent("pointerMove",[t,e])},o.prototype.onmouseup=function(t){this._pointerUp(t,t)},o.prototype.onMSPointerUp=o.prototype.onpointerup=function(t){t.pointerId==this.pointerIdentifier&&this._pointerUp(t,t)},o.prototype.ontouchend=function(t){var e=this.getTouch(t.changedTouches);e&&this._pointerUp(t,e)},o.prototype._pointerUp=function(t,e){this._pointerDone(),this.pointerUp(t,e)},o.prototype.pointerUp=function(t,e){this.emitEvent("pointerUp",[t,e])},o.prototype._pointerDone=function(){this.isPointerDown=!1,delete this.pointerIdentifier,this._unbindPostStartEvents(),this.pointerDone()},o.prototype.pointerDone=i,o.prototype.onMSPointerCancel=o.prototype.onpointercancel=function(t){t.pointerId==this.pointerIdentifier&&this._pointerCancel(t,t)},o.prototype.ontouchcancel=function(t){var e=this.getTouch(t.changedTouches);e&&this._pointerCancel(t,e)},o.prototype._pointerCancel=function(t,e){this._pointerDone(),this.pointerCancel(t,e)},o.prototype.pointerCancel=function(t,e){this.emitEvent("pointerCancel",[t,e])},o.getPointerPoint=function(t){return{x:void 0!==t.pageX?t.pageX:t.clientX,y:void 0!==t.pageY?t.pageY:t.clientY}},o}),function(t,e){"function"==typeof define&&define.amd?define("unidragger/unidragger",["eventie/eventie","unipointer/unipointer"],function(n,i){return e(t,n,i)}):"object"==typeof exports?module.exports=e(t,require("eventie"),require("unipointer")):t.Unidragger=e(t,t.eventie,t.Unipointer)}(window,function(t,e,n){function i(){}function o(t){t.preventDefault?t.preventDefault():t.returnValue=!1}function r(t){for(;t!=document.body;)if(t=t.parentNode,"A"==t.nodeName)return t}function s(){}function a(){return!1}s.prototype=new n,s.prototype.bindHandles=function(){this._bindHandles(!0)},s.prototype.unbindHandles=function(){this._bindHandles(!1)};var p=t.navigator;s.prototype._bindHandles=function(t){t=void 0===t?!0:!!t;var n;n=p.pointerEnabled?function(e){e.style.touchAction=t?"none":""}:p.msPointerEnabled?function(e){e.style.msTouchAction=t?"none":""}:function(){t&&d(s)};for(var i=t?"bind":"unbind",o=0,r=this.handles.length;r>o;o++){var s=this.handles[o];this._bindStartEvent(s,t),n(s),e[i](s,"click",this)}};var u="attachEvent"in document.documentElement,d=u?function(t){"IMG"==t.nodeName&&(t.ondragstart=a);for(var e=t.querySelectorAll("img"),n=0,i=e.length;i>n;n++){var o=e[n];o.ondragstart=a}}:i,c=s.allowTouchstartNodes={INPUT:!0,A:!0,BUTTON:!0,SELECT:!0};return s.prototype.pointerDown=function(t,e){this._dragPointerDown(t,e);var n=document.activeElement;n&&n.blur&&n.blur(),this._bindPostStartEvents(t),this.emitEvent("pointerDown",[t,e])},s.prototype._dragPointerDown=function(t,e){this.pointerDownPoint=n.getPointerPoint(e);var i=t.target.nodeName,s="touchstart"==t.type&&(c[i]||r(t.target));s||"SELECT"==i||o(t)},s.prototype.pointerMove=function(t,e){var n=this._dragPointerMove(t,e);this.emitEvent("pointerMove",[t,e,n]),this._dragMove(t,e,n)},s.prototype._dragPointerMove=function(t,e){var i=n.getPointerPoint(e),o={x:i.x-this.pointerDownPoint.x,y:i.y-this.pointerDownPoint.y};return!this.isDragging&&this.hasDragStarted(o)&&this._dragStart(t,e),o},s.prototype.hasDragStarted=function(t){return Math.abs(t.x)>3||Math.abs(t.y)>3},s.prototype.pointerUp=function(t,e){this.emitEvent("pointerUp",[t,e]),this._dragPointerUp(t,e)},s.prototype._dragPointerUp=function(t,e){this.isDragging?this._dragEnd(t,e):this._staticClick(t,e)},s.prototype._dragStart=function(t,e){this.isDragging=!0,this.dragStartPoint=s.getPointerPoint(e),this.isPreventingClicks=!0,this.dragStart(t,e)},s.prototype.dragStart=function(t,e){this.emitEvent("dragStart",[t,e])},s.prototype._dragMove=function(t,e,n){this.isDragging&&this.dragMove(t,e,n)},s.prototype.dragMove=function(t,e,n){this.emitEvent("dragMove",[t,e,n])},s.prototype._dragEnd=function(t,e){this.isDragging=!1;var n=this;setTimeout(function(){delete n.isPreventingClicks}),this.dragEnd(t,e)},s.prototype.dragEnd=function(t,e){this.emitEvent("dragEnd",[t,e])},s.prototype.onclick=function(t){this.isPreventingClicks&&o(t)},s.prototype._staticClick=function(t,e){"INPUT"==t.target.nodeName&&"text"==t.target.type&&t.target.focus(),this.staticClick(t,e)},s.prototype.staticClick=function(t,e){this.emitEvent("staticClick",[t,e])},s.getPointerPoint=function(t){return{x:void 0!==t.pageX?t.pageX:t.clientX,y:void 0!==t.pageY?t.pageY:t.clientY}},s.getPointerPoint=n.getPointerPoint,s}),function(t,e){"function"==typeof define&&define.amd?define("draggabilly/draggabilly",["classie/classie","get-style-property/get-style-property","get-size/get-size","unidragger/unidragger"],function(n,i,o,r){e(t,n,i,o,r)}):"object"==typeof exports?module.exports=e(t,require("desandro-classie"),require("desandro-get-style-property"),require("get-size"),require("unidragger")):t.Draggabilly=e(t,t.classie,t.getStyleProperty,t.getSize,t.Unidragger)}(window,function(t,e,n,i,o){function r(){}function s(t,e){for(var n in e)t[n]=e[n];return t}function a(t,e){this.element="string"==typeof t?d.querySelector(t):t,P&&(this.$element=P(this.element)),this.options=s({},this.constructor.defaults),this.option(e),this._create()}function p(t,e,n){return n=n||"round",e?Math[n](t/e)*e:t}for(var u,d=t.document,c=d.defaultView,h=c&&c.getComputedStyle?function(t){return c.getComputedStyle(t,null)}:function(t){return t.currentStyle},f="object"==typeof HTMLElement?function(t){return t instanceof HTMLElement}:function(t){return t&&"object"==typeof t&&1==t.nodeType&&"string"==typeof t.nodeName},l=0,g="webkit moz ms o".split(" "),v=t.requestAnimationFrame,y=t.cancelAnimationFrame,m=0;m<g.length&&(!v||!y);m++)u=g[m],v=v||t[u+"RequestAnimationFrame"],y=y||t[u+"CancelAnimationFrame"]||t[u+"CancelRequestAnimationFrame"];v&&y||(v=function(e){var n=(new Date).getTime(),i=Math.max(0,16-(n-l)),o=t.setTimeout(function(){e(n+i)},i);return l=n+i,o},y=function(e){t.clearTimeout(e)});var E=n("transform"),b=!!n("perspective"),P=t.jQuery;s(a.prototype,o.prototype),a.defaults={},a.prototype.option=function(t){s(this.options,t)},a.prototype._create=function(){this.position={},this._getPosition(),this.startPoint={x:0,y:0},this.dragPoint={x:0,y:0},this.startPosition=s({},this.position);var t=h(this.element);"relative"!=t.position&&"absolute"!=t.position&&(this.element.style.position="relative"),this.enable(),this.setHandles()},a.prototype.setHandles=function(){this.handles=this.options.handle?this.element.querySelectorAll(this.options.handle):[this.element],this.bindHandles()},a.prototype.dispatchEvent=function(e,n,i){var o=[n].concat(i);this.emitEvent(e,o);var r=t.jQuery;if(r&&this.$element)if(n){var s=r.Event(n);s.type=e,this.$element.trigger(s,i)}else this.$element.trigger(e,i)},a.prototype._getPosition=function(){var t=h(this.element),e=parseInt(t.left,10),n=parseInt(t.top,10);this.position.x=isNaN(e)?0:e,this.position.y=isNaN(n)?0:n,this._addTransformPosition(t)},a.prototype._addTransformPosition=function(t){if(E){var e=t[E];if(0===e.indexOf("matrix")){var n=e.split(","),i=0===e.indexOf("matrix3d")?12:4,o=parseInt(n[i],10),r=parseInt(n[i+1],10);this.position.x+=o,this.position.y+=r}}},a.prototype.pointerDown=function(t,n){this._dragPointerDown(t,n);var i=d.activeElement;i&&i.blur&&i.blur(),this._bindPostStartEvents(t),e.add(this.element,"is-pointer-down"),this.dispatchEvent("pointerDown",t,[n])},a.prototype.pointerMove=function(t,e){var n=this._dragPointerMove(t,e);this.dispatchEvent("pointerMove",t,[e,n]),this._dragMove(t,e,n)},a.prototype.dragStart=function(t,n){this.isEnabled&&(this._getPosition(),this.measureContainment(),this.startPosition.x=this.position.x,this.startPosition.y=this.position.y,this.setLeftTop(),this.dragPoint.x=0,this.dragPoint.y=0,this.isDragging=!0,e.add(this.element,"is-dragging"),this.dispatchEvent("dragStart",t,[n]),this.animate())},a.prototype.measureContainment=function(){var t=this.options.containment;if(t){this.size=i(this.element);var e=this.element.getBoundingClientRect(),n=f(t)?t:"string"==typeof t?d.querySelector(t):this.element.parentNode;this.containerSize=i(n);var o=n.getBoundingClientRect();this.relativeStartPosition={x:e.left-o.left,y:e.top-o.top}}},a.prototype.dragMove=function(t,e,n){if(this.isEnabled){var i=n.x,o=n.y,r=this.options.grid,s=r&&r[0],a=r&&r[1];i=p(i,s),o=p(o,a),i=this.containDrag("x",i,s),o=this.containDrag("y",o,a),i="y"==this.options.axis?0:i,o="x"==this.options.axis?0:o,this.position.x=this.startPosition.x+i,this.position.y=this.startPosition.y+o,this.dragPoint.x=i,this.dragPoint.y=o,this.dispatchEvent("dragMove",t,[e,n])}},a.prototype.containDrag=function(t,e,n){if(!this.options.containment)return e;var i="x"==t?"width":"height",o=this.relativeStartPosition[t],r=p(-o,n,"ceil"),s=this.containerSize[i]-o-this.size[i];return s=p(s,n,"floor"),Math.min(s,Math.max(r,e))},a.prototype.pointerUp=function(t,n){e.remove(this.element,"is-pointer-down"),this.dispatchEvent("pointerUp",t,[n]),this._dragPointerUp(t,n)},a.prototype.dragEnd=function(t,n){this.isEnabled&&(this.isDragging=!1,E&&(this.element.style[E]="",this.setLeftTop()),e.remove(this.element,"is-dragging"),this.dispatchEvent("dragEnd",t,[n]))},a.prototype.animate=function(){if(this.isDragging){this.positionDrag();var t=this;v(function(){t.animate()})}};var x=b?function(t,e){return"translate3d( "+t+"px, "+e+"px, 0)"}:function(t,e){return"translate( "+t+"px, "+e+"px)"};return a.prototype.setLeftTop=function(){this.element.style.left=this.position.x+"px",this.element.style.top=this.position.y+"px"},a.prototype.positionDrag=E?function(){this.element.style[E]=x(this.dragPoint.x,this.dragPoint.y)}:a.prototype.setLeftTop,a.prototype.staticClick=function(t,e){this.dispatchEvent("staticClick",t,[e])},a.prototype.enable=function(){this.isEnabled=!0},a.prototype.disable=function(){this.isEnabled=!1,this.isDragging&&this.dragEnd()},a.prototype.destroy=function(){this.disable(),E&&(this.element.style[E]=""),this.element.style.left="",this.element.style.top="",this.element.style.position="",this.unbindHandles(),this.$element&&this.$element.removeData("draggabilly")},a.prototype._init=r,P&&P.bridget&&P.bridget("draggabilly",a),a});

} catch(e) {
    console && console.warn('Failed to load Draggabilly library.');
}
/* jshint ignore:end */
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.enter
     */
    //Creates the enter module.
    angular.module('enspire.ui.components.enter', ['enspire.ui.core']);

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.error
     * @description
     * `en-error` module.
     *
     */

    angular.module('enspire.ui.components.error', []);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.field
     */

    angular.module('enspire.ui.components.field', ['enspire.ui.core']);

    /**
     * @ngdoc directive
     * @name enField
     * @module enspire.ui.components.field
     * @restrict E
     * @description
     * en-field is a wrapper that adds position and styling to en-label, en-button & en-icon components on either side of a form field. It is fully 
     * autonomous and requires no additional css classes or html attributes to work.
     * 
     * > ### Important
     * > en-field's can only be used inside of {@link #/api/enspire.ui.components.control/directive/enControl `<en-control>`} elements.
     * 
     * ### Layout
     * An en-field supports up to 3 child elements and will position each element in the order placed.
     * 
     * ### Supported Child Elements (up to 3)
     * #### Enspire.UI Specific
     * - en-label
     * - en-button
     * - en-icon
     * - en-select
     * - en-input
     * 
     * #### Standard HTML
     * - input
     * 
     * 
     * 
     *
     * @element en-field

     *
     * @usage
     * 
     */
    
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.fileUpload
     */

    angular.module('enspire.ui.components.fileUpload', ['ngFileUpload'])
        .filter('enFormatBytes', function(){
            return function(bytes, decimalPlace, space) {
                /**
                 * Filter to format bytes into the most logical magnitude (KB, MB,
                 * or GB).
                 */
                var units = ['B', 'KB', 'MB', 'GB', 'TB'];
                bytes = parseInt(bytes);
                decimalPlace = (decimalPlace === undefined) ? 2: decimalPlace;
                space = (space) ? ' ': '';

                for (var i = 0; bytes >= 1024 && i < 4; i++) {
                    bytes /= 1024;
                }

                return bytes.toFixed(decimalPlace) + space + units[i];
            }
        });

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.float', []).directive('float', function(){
        return {
            require: 'ngModel',
            link: function(scope, ele, attr, ctrl){
                ctrl.$parsers.unshift(function(viewValue){
                    viewValue = viewValue+'';
                    var float = parseFloat(viewValue.replace(/[^0-9.]/g, ''), 10);
                    if(isNaN(float)) float = 0;
                    return float;
                });

                ctrl.$formatters.push(function (value) {
                    value = value+'';
                    var float = parseFloat(value.replace(/[^0-9.]/g, ''), 10);
                    if(isNaN(float)) float = 0;
                    return float.toFixed(2);
                });

                ele.bind('blur', function() {
                    ctrl.$viewValue = (ctrl.$modelValue).toFixed(2);
                    ctrl.$render();
                });
            }
        };
    });
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.footer
     */

    angular.module('enspire.ui.components.footer', ['enspire.ui.core']);
    
    /**
     * @ngdoc directive
     * @name enFooter
     * @module enspire.ui.components.footer
     * @restrict E
     * @description
     * `en-footer` creates a styled footer element.
     *
     * @element en-footer
     *
     * @usage
     * <hljs lang="html">
     *   <en-footer> ... </en-footer>
     * </hljs>
     *
     */

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.form
     */
    //Creates the form module.
    angular.module('enspire.ui.components.form', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

   /**
     * @ngdoc module
     * @name enspire.ui.components.growl
     * @description
     * `growl` module.
     *
     */
    angular
        .module('enspire.ui.components.growl', ['angular-growl']);        
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.header
     */

    angular.module('enspire.ui.components.header', ['enspire.ui.core']);

    /**
     * @ngdoc directive
     * @name enHeader
     * @module enspire.ui.components.header
     * @restrict E
     * @element en-header
     *
     * @description
     * `en-header` creates a styled header element.
     *
     * @usage
     * <hljs lang="html">
     *   <en-header>
     *       <en-title class="title-md">Header Title</en-title>
     *       <en-flex></en-flex> <!-- Expandable Spacer -->
     *       <en-button class="trim">
     *          <en-icon icon="plus-circle"></en-icon>
     *       </en-button>
     *   </en-header>
     * </hljs>
     *
     */

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.icon
     */

    angular.module('enspire.ui.components.icon', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.include
     * @description
     *
     *  App `<en-include>` directive..
     *
     */
    angular.module('enspire.ui.components.include', [
        'enspire.ui.core'
    ]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.input
     */

    angular.module('enspire.ui.components.input', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013 Michael Benford
 *
 * This code has been modified and altered from the original code authored
 * by Michael Benford.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

(function(){
    'use strict';

   /**
     * @ngdoc module
     * @name enspire.ui.components.inputTags
     * @description
     * `en-input-tags` module.
     *
     */
    angular
        .module('enspire.ui.components.inputTags', [])
        .run(["$templateCache", function($templateCache){

            $templateCache.put('input-tags/input-tags.html',
                "<div class=\"host\" tabindex=\"-1\" ng-click=\"eventHandlers.host.click()\" en-input-tags-transclude-append=\"\"><div class=\"tags\" ng-class=\"{focused: hasFocus}\"><ul class=\"tag-list\" ng-if=\"tagList.showTags\"><li class=\"tag-item\" ng-repeat=\"tag in tagList.items track by track(tag)\" ng-class=\"{ selected: tag == tagList.selected }\"><en-input-tag-item data=\"tag\"></en-input-tag-item></li></ul><input class=\"input\" autocomplete=\"off\" ng-model=\"newTag.text\" ng-change=\"eventHandlers.input.change(newTag.text)\" ng-keydown=\"eventHandlers.input.keydown($event)\" ng-focus=\"eventHandlers.input.focus($event)\" ng-blur=\"eventHandlers.input.blur($event)\" ng-paste=\"eventHandlers.input.paste($event)\" ng-trim=\"false\" ng-class=\"{'invalid-tag': newTag.invalid}\" ng-disabled=\"disabled\" ti-bind-attrs=\"{type: options.type, placeholder: options.placeholder, tabindex: options.tabindex, spellcheck: options.spellcheck}\" en-input-tags-autosize=\"\"></div></div>"
            );

            $templateCache.put('input-tags/tag-item.html',
                "<span ng-bind=\"$getDisplayText()\"></span> <a class=\"remove-button\" ng-click=\"$removeTag()\" ng-bind=\"$$removeTagSymbol\"></a>"
            );


            $templateCache.put('input-tags/auto-complete.html',
                "<div class=\"autocomplete\" ng-if=\"suggestionList.visible\"><ul class=\"suggestion-list\"><li class=\"suggestion-item\" ng-repeat=\"item in suggestionList.items track by track(item)\" ng-class=\"{selected: item == suggestionList.selected}\" ng-click=\"addSuggestionByIndex($index)\" ng-mouseenter=\"suggestionList.select($index)\"><en-input-tags-auto-match data=\"item\"></en-input-tags-auto-match></li></ul></div>"
            );

            $templateCache.put('input-tags/auto-complete-match.html',
                "<span ng-bind-html=\"$highlight($getDisplayText())\"></span>"
            );
        }]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.keyEvent
     */

    angular.module('enspire.ui.components.keyEvent', ['enspire.ui.core']);

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.label
     */
    //Creates the label module.
    angular.module('enspire.ui.components.label', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.listObject
     */
    //Creates the listObject module.
    angular.module('enspire.ui.components.listObject', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.loader
     */
    //Creates the loader module.
    angular.module('enspire.ui.components.loader', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.menu
     */
    //Creates the menu module.  See /menu for controllers & directives.
    angular.module('enspire.ui.components.menu', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.modal
     * @description
     *
     *  App `<en-modal>` directive..
     *
     */
    angular.module('enspire.ui.components.modal', [
        'enspire.ui.core'
    ]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.msg
     */
    //Creates the message module.
    angular.module('enspire.ui.components.msg', ['enspire.ui.core','enspire.ui.components.form']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.nav
     */
    //Creates the nav module.  See /nav for controllers & directives.
    angular.module('enspire.ui.components.nav', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

   /**
     * @ngdoc module
     * @name enspire.ui.components.objectDiff
     * @description
     * `objectDiff` module.
     *
     */
    angular
        .module('enspire.ui.components.objectDiff', [])
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.panel
     */
    //Creates the panel module.  See /panel for controllers & directives.
    angular.module('enspire.ui.components.panel', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.passwordCheck
     * @description
     * `en-password-check` module.
     *
     */

    angular.module('enspire.ui.components.passwordCheck', []);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * The MIT License
 *
 * Copyright (c) 2012-2014 Olivier Louvignes http://olouv.com
 *
 * This code has been modified and altered from the original code authored
 * by Olivier Louvignes.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
 *  (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,
 *  publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 *  subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 *  THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
 *  OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
 *  OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

(function(){
    'use strict';

   /**
     * @ngdoc module
     * @name enspire.ui.components.popover
     * @description
     * `en-popover` module.
     *
     */
    angular
        .module('enspire.ui.components.popover', ['enspire.ui.components.tooltip'])
        .run([ '$templateCache', function($templateCache) {
            $templateCache.put('popover/popover.tpl.html', '<div class="popover"><div class="arrow"></div><h3 class="popover-title" ng-bind="title" ng-show="title"></h3><div class="popover-content" ng-bind="content"></div></div>');
        } ]);

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.progress
     * @description
     * `en-progress` module.
     *
     */

    angular.module('enspire.ui.components.progress', [])
        .run(["$templateCache", function($templateCache){
            $templateCache.put('progress/progress.html',
                '<div class="progress">'
                +   '<div class="progress-bar {{::progress.css}}" ng-class="{\'active\': progress.animate}" role="progressbar" aria-valuenow="{{progress.value}}" aria-valuemin="{{::progress.min}}" aria-valuemax="{{::progress.max}}" ng-style="{\'width\': progress.value + \'%\'}">'
                +       '<span ng-show="progress.label">{{progress.value}}% {{progress.label}}</span>'
                +   '</div>'
                + '</div>'
            );
        }]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.quote
     */
    //Creates the quote module.
    angular.module('enspire.ui.components.quote', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.screen
     * @description
     *
     *  App `<en-screen>` directive..
     *
     */
    angular.module('enspire.ui.components.screen', [
        'enspire.ui.core'
    ]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.scrollbar
     */

    angular.module('enspire.ui.components.scrollbar', ['enspire.ui.core']);

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.section
     * @description
     *
     *  App `<en-section>` directive..
     *
     */
    angular.module('enspire.ui.components.section', [
        'enspire.ui.core'
    ]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 kamilkp
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.sortable
     * @description
     * `en-sortable` module.
     *
     */
    angular
        .module('enspire.ui.components.sortable', [])
        .run(function(){

            // Simple implementation of jQuery's .add method
            if(typeof angular.element.prototype.add !== 'function'){
                angular.element.prototype.add = function(elem){
                    var i, res = angular.element();
                    elem = angular.element(elem);
                    for(i=0;i<this.length;i++){
                        res.push(this[i]);
                    }
                    for(i=0;i<elem.length;i++){
                        res.push(elem[i]);
                    }
                    return res;
                };
            }
        });
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.src
     * @description
     *
     *  App `<img en-src="">` directive..
     *
     */
    angular.module('enspire.ui.components.src', [
        'enspire.ui.core'
    ]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.subheader
     */

    angular.module('enspire.ui.components.subheader', ['enspire.ui.core']);
    
    /**
     * @ngdoc directive
     * @name enSubheader
     * @module enspire.ui.components.subheader
     * @restrict E
     * @description
     * `en-subheader` creates a styled subheader element.
     *
     * @element en-subheader
     *
     * @usage
     * <hljs lang="html">
     *   <en-subheader> ... </en-subheader>
     * </hljs>
     *
     */

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.tabs
     * @description
     *
     *  `<en-tabs>` module.
     *
     */
    angular.module('enspire.ui.components.tabs', [
        'enspire.ui.core'
    ]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.time
     * @description
     * `en-time` module.
     *
     */

    angular.module('enspire.ui.components.time', []);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.timeDuration
     * @description
     * `en-time-duration` module.
     *
     */

    angular.module('enspire.ui.components.timeDuration', []);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.title
     */
    //Creates the title module.
    angular.module('enspire.ui.components.title', ['enspire.ui.core']);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * The MIT License
 *
 * Copyright (c) 2012-2014 Olivier Louvignes http://olouv.com
 *
 * This code has been modified and altered from the original code authored
 * by Olivier Louvignes.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
 *  (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,
 *  publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 *  subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 *  THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
 *  OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
 *  OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

(function(){
    'use strict';

   /**
     * @ngdoc module
     * @name enspire.ui.components.tooltip
     */
    angular
        .module('enspire.ui.components.tooltip', ['enspire.ui.core','ngSanitize'])
        .run([ '$templateCache', function($templateCache) {
            $templateCache.put('tooltip/tooltip.tpl.html', '<div class="tooltip in" ng-show="title"><div class="tooltip-arrow"></div><div class="tooltip-inner" ng-bind="title"></div></div>');
        } ]);

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.touch
     * @description
     *
     *  App `<en-touch>` directive..
     *
     */
    angular.module('enspire.ui.components.touch', [
        'enspire.ui.core'
    ]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.tree
     * @description
     * `en-tree` module.
     *
     */

    angular.module('enspire.ui.components.tree', [])
        .run(["$templateCache", function($templateCache){
            $templateCache.put('enTree/tree.html',
              '<ul class="tree open">'
              + '  <li class="branch" ng-repeat="$branch in branches">'
              + '    <en-tree-branch object="$branch" parent="branches"></en-tree-branch>'
              + '  </li>'
              + '</ul>'
            );

            $templateCache.put('enTree/branch.html',
              '{{branchNode}}'
              + '<ul class="tree" ng-class="{open: node.open}" ng-if="$branch[nodeChildren].length && node.open">'
              + '  <li class="branch" ng-repeat="subBranch in $branch[nodeChildren]">'
              + '    <en-tree-branch object="subBranch" parent="$branch"></en-tree-branch>'
              + '  </li>'
              + '</ul>'
            );

            /* Old Way but still same
            $templateCache.put('enTree/branch-node.html',
              '<branch-node>'
              + '    <en-icon icon="{{ $branch[nodeChildren].length ? ( node.open ? \'folder-open\': \'folder\' ): \'file\' }}"></en-icon>'
              + '    <span class="branch-name" ng-bind="$branch[ nodeLabel ]" ng-class="{\'expandable\': $branch[nodeChildren].length}">'
              + '    </span>'
              + '</branch-node>'
            );
            */

            $templateCache.put('enTree/branch-node.html',
              '<branch-node>'
              + '    <en-icon icon="{{ $branch.$hasChildren() ? ( $branch.$isOpen() ? \'folder-open\': \'folder\' ): \'file\' }}"></en-icon>'
              + '    <span class="branch-name" ng-bind="$branch.$label()" ng-class="{\'expandable\': $branch.$hasChildren(), \'selected\': $branch.isSelected }">'
              + '    </span>'
              + '</branch-node>'
            );

            $templateCache.put('enTree/context-menu.html',
              '<context-menu>'
              + '    <ul layout="column">'
              + '        <li flex>'
              + '            <en-button flex ng-click="$$add($branch)"><en-icon icon="plus"></en-icon> Add Sibling</en-button>'
              + '        </li>'
              + '        <li flex>'
              + '            <en-button flex ng-click="$$add($branch, true)"><en-icon icon="plus"></en-icon> Add Child</en-button>'
              + '        </li>'
              + '        <li flex>'
              + '            <en-button flex ng-click="$$edit($branch)"><en-icon icon="edit"></en-icon>Edit</en-button>'
              + '        </li>'
              + '        <li flex>'
              + '            <en-button flex ng-click="$$delete($branch)"><en-icon icon="trash"></en-icon> Delete</en-button>'
              + '        </li>'
              + '    </ul>'
              + '</context-menu>'
            );
        }]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.win
     * @description
     *
     *  Win `<en-win>` directive..
     *
     */
    angular.module('enspire.ui.components.win', [
        'enspire.ui.core'
    ]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * @ngdoc directive
 * @name enActions
 * @module enspire.ui.components.action
 * @restrict E
 * @element en-actions
 *
 * @description
 * Produces a button or icon that will open a popover containing a list of `en-action`'s
 *
 * @param {string=}     [type=icon|icon, button]           Actions display style
 * @param {string=}     icon                               Name of icon to use for action or actions
 * @param {string=}     class                              Classname(s) to add to the en-action icon/button.
 *
 * @param {string=}     [viewport=en-win-body]             The element selector the popover will use to configure its top, right, bottom and left boundaries.
 * @param {string=}     [container=en-modal/en-win-body]   The element selector the actions popover will be placed inside of.  In most cases this will be auto set depending on the loaction of the calling en-action button.  If it is inside a modal, and $scope.isModal is true, this will be set to `en-modal` otherwise it will always default to `en-win-body`, unless otherwise specified.
 * @param {string=}     [placement=auto bottom]            `horizontal vertical` positioning of the en-action popover.
 * @param {boolean=}    [autoClose=true]                   Sets whether the en-actions popover should close automatically when an inner item is clicked.
 * @param {string=}     [customClass=popover-dark]         Classname to assign to the en-popover element that gets created by this directive.
 * @param {expression=} [disabled=false]                   Watched expression that will eval to true/false.  When disabled, the en-action button itself will show as disabled and will not fire any actionable popover when clicked.
 *
 *
 * @usage
 * <hljs lang="html">
 * <en-actions type="button">
 *     <en-action icon="edit">Edit</en-action>
 *     <en-action icon="trash">Delete</en-action>
 * </en-actions>
 * </hljs>
 *
 */


/**
 * @ngdoc directive
 * @name enAction
 * @module enspire.ui.components.action
 * @restrict E
 *
 * @requires enActions
 *
 * @element en-action
 *
 * @description
 * Produces a button or icon within an `en-actions` popover containing actions
 *
 * @param {string=}     icon                               Name of icon to use for action button.
 * @param {string=}     ng-href                            Used when the en-action button being pressed needs to send the user to a new url.
 *
 * @usage
 * <hljs lang="html">
 * <en-actions type="button">
 *     <en-action icon="edit" en-tap="scopeMethodToRun();">Edit</en-action>
 *     <en-action icon="trash" ng-href="http://www.externalurl.com/delete">Delete</en-action>
 * </en-actions>
 * </hljs>
 *
 */

(function(){
    'use strict';
    angular.module('enspire.ui.components.action').directive('enActions', actionsDirective);
    angular.module('enspire.ui.components.action').directive('enAction', actionDirective);

    function actionsDirective($enPopover) {

        return {
            restrict    : 'E',
            compile     : compile
        };

        function compile($element, $attrs) {
            //capture raw contents and remove from element before it is compiled
            $element.addClass('en-actions');

            var icon = $attrs.icon || 'gear';

            var actionContents = '<ul>'+$element.html()+'</ul>';

            var strBtn = '<button type="button" class="';

            if($attrs.type!=='button'){
                $element.addClass('actions-icon');
            }else{
                strBtn += 'en-button ';
            }

            strBtn += ($attrs.class ? $attrs.class+' ' : '')+'trim"><en-icon icon="'+icon+'"></en-icon></button>';

            $element.html(strBtn);

            return function postLink($scope, $element, $attrs, $enCollectionCtrl) {

                var isModal = ($scope.isModal || false);

                var $el = angular.element($element[0]).find('button');
                var viewport = (angular.isDefined($attrs.viewport) ? $attrs.viewport : (isModal ? 'en-win-body' : 'en-win-body'));
                var container = (angular.isDefined($attrs.container) ? $attrs.container : (isModal ? '.'+$scope.modalId+" en-modal-body" : 'en-win-body'));
                var placement = (angular.isDefined($attrs.placement) ? $attrs.placement : 'auto bottom');
                var autoClose = (angular.isDefined($attrs.autoClose) ? $attrs.autoClose : true);
                var customClass = (angular.isDefined($attrs.customClass) ? $attrs.customClass : 'popover-dark');

                var popOver = $enPopover( $el, {
                    scope: $scope,
                    inlineTemplate: true,
                    content: actionContents,
                    viewport: {selector:viewport, padding: 0 },
                    container: container,
                    customClass: customClass,
                    autoClose: autoClose,
                    html: true,
                    placement: placement
                });

                var $winBody = angular.element(document.querySelector('en-win-body'));
                function closePopover(){
                    if(!popOver || !popOver.$isShown) return;
                    popOver.hide();
                }

                $winBody.on('scroll', closePopover);

                var checkDisabled = function(){
                    if($attrs.disabled){
                        $el.attr('disabled',true);
                    }else{
                        $el.attr('disabled',false);
                    }
                };

                checkDisabled();

                var obvDisabled = $attrs.$observe('disabled', function() {
                    checkDisabled();
                });

                $element.bind('$destroy', function () {
                    closePopover();
                    obvDisabled();
                });
            };
        }
    }
    actionsDirective.$inject = ["$enPopover"];

    function actionDirective() {

        function resolveTemplate($element, $attrs){
            var strTemplate =  '<li>';
                strTemplate += '<en-button class="button-popover-dark" ';

            if($attrs.ngHref){
                strTemplate += ' ng-href="'+$attrs.ngHref+'"';
            }
                strTemplate += '>';

            if(angular.isDefined($attrs.icon)){
                strTemplate += '<en-icon icon="'+$attrs.icon+'"></en-icon>';
            }
            strTemplate += $element.html();
            strTemplate += '</en-button>';
            strTemplate += '</li>';

            return strTemplate;
        }

        return {
            restrict    : 'E',
            compile      : compile,
            replace     : true,
            template    : resolveTemplate
        };

        function compile($element, $attrs) {
            return function postLink($scope, $element, $attrs, $enCollectionCtrl) {

            };
        }
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.adapter').directive('enAdapter', ComponentDirective);

    /**
     * @ngdoc directive
     * @name enAdapter
     * @module enspire.ui.components.adapter
     * @restrict AE
     * @description
     * Transforms model data from one format into another format.
     *
     * @param {string} [en-adapter= ] The data transformation rules.
     *
     * @param {object} [en-adapter-input= ] Model data to read from as input.
     *
     * @param {object} [en-adapter-output= ] Transformed data as output.
     *
     * @param {boolean=} [one-way-bind= ] Transform only from input to output.
     *
     * @param {string=} [en-adapter-rev-rule= ] Apply a specific reverse transform rule.
     *                                          Otherwise uses value of en-adapter attribute.
     *
     * @param {function=} [en-after-rev-transform= ] Callback function to execute after the output
     *                                              model has been reverse transformed but
     *                                              before it is assigned back to input model.
     *                                              The value returned from this function gets
     *                                              assigned to input model.
     *                                              <br /><br />
     *                                              Parameters passed to this function is inputModel
     *                                              and transformedModel.  callback( inputModel, transformedModel).
     *
     * @param {boolean=} [use-deep-watch=false] Perform a deep watch (more expensive) , otherwise perform shallow watch of models.
     *
     *
     *
     * @usage
     * ### Basic Example
     * <hljs lang="html">
     *   # Element whose data you want to transform, give ngModel any name
     *   <en-input-tags ng-model="rawData"></en-input-tags>
     *
     *   # Element that receives the transformed data
     *   <input type="hidden"
     *          ng-model="transformedData"
     *          en-adapter="*.text"
     *          en-adapter-input="rawData"
     *          en-adapter-output="transformedData" />
     * </hljs>
     *
     * # Transformation Rules:
     * (see DEMO page for now.)
     */

    function ComponentDirective() {
        return {
            restrict: 'A',
            controller: ["$scope", "$element", "enAdapter", "$attrs", function($scope, $element, enAdapter, $attrs) {
                var rules = $attrs.enAdapter,
                    modelInput = $attrs.enAdapterInput,
                    modelOutput = $attrs.enAdapterOutput,
                    oneWayBind = $attrs.oneWayBind,
                    applyRevRule = $attrs.enAdapterRevRule,
                    onAfterRevTransform = $attrs.enAfterRevTransform,
                    useDeepWatch = $attrs.useDeepWatch;

                enAdapter.init({
                    // view scope
                    'scope': $scope,

                    // Transformation rules
                    'rules': rules,

                    // Source data
                    'modelInput': modelInput,

                    // Output data
                    'modelOutput': modelOutput,

                    // Only transform data one way
                    'oneWayBind': oneWayBind,

                    // Use specific rev transform rules,  otherwise use default rules
                    'applyRevRule': applyRevRule,

                    // callback after rev transform occurs
                    'onAfterRevTransform': onAfterRevTransform,

                    // Deep watch?
                    'useDeepWatch': useDeepWatch
                });
            }]
        }
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.adapter').provider('enAdapterParser', ComponentService);

    function ComponentService() {
        var self = this;

        //TODO: Refactor to get under ~30 lines. I see ways to optimize even more.

        self.$get = function() {
            /**
             * Parses rules string into an array of objects
             */
            function ComponentFactory(str) {
                var stubRegExp = new RegExp('\\{stub\\}'),
                    stub = '{stub}',
                    parts,
                    stubs,
                    output;

                function swapRegExp(matchChar) {
                    return new RegExp('[\'"]{1}[^' + matchChar + '\'"\(\)]*(' + matchChar + ')[^\'"]*[\'"]{1}', 'g');
                }

                // Remove opening and closing brackets
                str = str.replace(/^\s+|\s+$/, '');

                // Swap out any '.' within quotes so we can split correctly
                // with {dot}. Will add back later.
                stubs = str.match(swapRegExp('\\.'));
                str = str.replace(swapRegExp('\\.'), stub);

                parts = str.split('.');

                parts.forEach(function(item, index, self) {
                    var swaps,
                        part,
                        rule;

                    // Put back the '.' so later we know what rule to apply
                    if (index > 0) self[index] = '.' + self[index];

                    // Put back what we swapped out previously
                    while (stubRegExp.test(self[index])) {

                        // Have to assign using self[index] in order to change array
                        self[index] = self[index].replace(stubRegExp, stubs.shift());
                    }

                    // Split based on modifiers. Example is *:contains(), *.status:eq()
                    swaps = self[index].match(swapRegExp('\\:'));
                    part = self[index].replace(swapRegExp('\\:'), stub);
                    part = part.split(':');

                    part.forEach(function(subItem, subIndex, origPart){
                        //TODO: Clean up, origPart should be same as part

                        // Put back the ':' so later we know what rule to apply
                        if (subIndex > 0) origPart[subIndex] = ':' + origPart[subIndex];

                        while( stubRegExp.test(origPart[index]) ) {
                            origPart[index] = origPart[index].replace(stubRegExp, swaps.shift());
                        }
                    });

                    self[index] = part;
                });

                // Flatten array
                output = [];
                parts.forEach(function(item){
                    output = output.concat(item);
                });

                return output;
            }; //parse fn

            return ComponentFactory;
        }
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.adapter').provider('enAdapterRules', ComponentService);

    function ComponentService() {

         this.$get = ["enAdapterRuleStar", "enAdapterRuleDot", "enAdapterRuleColon", function(enAdapterRuleStar, enAdapterRuleDot, enAdapterRuleColon) {
            var self = {},
                _rules = {};

            /**
             * Extract rule name from given rule
             * @param {string} rule - Adapter rule
             */
            self.getRuleName = function(rule){
                return rule.match(/[^\()]+/)[0];
            }


            /**
             * Execute a rule against the given context
             *
             * @param {string} rule    - Adapter rule
             * @param {object} context - Data after applying rule transformations.
             * @param {object} source  - Original data object
             */
            self.applyRule = function(rule, context, source) {
                var ruleName = self.getRuleName(rule);

                // Has '.', extraction rule
                if (ruleName.match(/^\./)) {
                    // Extract unless there's a wildcard *
                    ruleName = (ruleName.substr(1,1) !== '*') ? '.': '*';
                }

                // Has ':', action rule
                else if (ruleName.match(/^\:/)) {
                    ruleName = ':';
                }

                // Invalid rule, show warning and do nothing
                if (!_rules[ruleName]) {
                    console.warn('enAdapter: Invalid data adapter rule! "' + ruleName + '"');
                    return context;
                }

                return _rules[ruleName].apply(self, [rule, context, source]);
            }


            /**
             * Register adapter rule
             *
             * @param {string}   name - Name of the rule.
             * @param {function} fn   - Rule function to execute.
             *                          The function must return object.
             *
             * @param {boolean}  overwrite - Overwrite rule if exists
             */
            self.registerRule = function(name, fn, overwrite) {
                if (!_rules[name] && typeof(fn) === 'function') {
                    _rules[name] = fn;
                }
                else if (overwrite && typeof(fn) === 'function') {
                    _rules[name] = fn;
                }
            }


            /**
             * Data Adapter Rules
             * ------------------
             */

            // RULE * - Match root or child elements
            enAdapterRuleStar(self);

            // RULE . - Extract contents of array or object
            enAdapterRuleDot(self);

            // RULE : - Perform some action against context
            //          Loads associated action rule
            enAdapterRuleColon(self);

            return self;
         }]
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.adapter').provider('enAdapter', ComponentService);

    function ComponentService() {

        this.$get = ["enAdapterParser", "enAdapterRules", "$timeout", "$parse", "$rootScope", function(enAdapterParser, enAdapterRules, $timeout, $parse, $rootScope) {
            var debounceRate = 100, // ms
                timestamp;

            /**
             * Initialize the service
             * @params {object} config - Configuration object
             *
             * Composed of scope, rules, modelInput, and modelOutput.
             * More information supplied in docs.
             */
            function init(config) {
                var $scope = config.scope,
                    modelInput = config.modelInput,
                    modelOutput = config.modelOutput,
                    oneWayBind = (config.oneWayBind === undefined) ? false: $parse( config.oneWayBind )(config.scope),
                    useDeepWatch = (config.useDeepWatch === undefined) ? false: $parse( config.useDeepWatch )(config.scope),
                    offInputWatch,
                    offOutputWatch,
                    offRulesWatch,
                    isEmpty;

                function isEmpty(val) {
                    var empty = false;
                    if (val === undefined) {
                        empty = true;
                    }
                    else if (val === null) {
                        empty = true;
                    }
                    else if (angular.isArray() && !val.length) {
                        empty = true;
                    }
                    else if (angular.isObject(val) && !Object.keys(val).length) {
                        empty = true;
                    }
                    else if (val === '') {
                        empty = true;
                    }
                    return empty;
                }

                // If rules is object watch it, otherwise treat as string literal
                if (angular.isObject(config.rules)) {
                    offRulesWatch = $scope.$watchCollection(config.rules, function(newVal, oldVal){
                        if ( isEmpty(newVal) ) return;
                        // Expecting object with property rule
                        config.rules = newVal.rule || '';
                    });
                }

                // Watching input source for changes
                if (useDeepWatch) {
                    // Perform deep watch
                    offInputWatch = $scope.$watch(modelInput, function(newVal, oldVal) {
                        if ( isEmpty(newVal) || ignoreBounce() ) return;
                        $timeout(function(){
                            applyTransformation(config);
                        });
                    }, true);
                }
                else {
                    // Shallow Watch only
                    offInputWatch = $scope.$watchCollection(modelInput, function(newVal, oldVal) {
                        if ( isEmpty(newVal) || ignoreBounce() ) return;
                        $timeout(function(){
                            applyTransformation(config);
                        });
                    });
                }



                // Watching output destination for changes
                if (oneWayBind === false) {
                    if (useDeepWatch) {
                        // Perform deep watch
                        offInputWatch = $scope.$watch(modelOutput, function(newVal, oldVal) {
                            if ( isEmpty(newVal) || ignoreBounce() ) return;
                            $timeout(function(){
                                applyReverseTransformation(config);
                            });
                        }, true);
                    }
                    else {
                        offOutputWatch = $scope.$watchCollection(modelOutput, function(newVal, oldVal) {
                            if ( isEmpty(newVal) || ignoreBounce() ) return;
                            $timeout(function(){
                                applyReverseTransformation(config);
                            });
                        });
                    }
                }

                // Turn off our watches
                $scope.$on('$destroy', function(){
                    offInputWatch();
                    offOutputWatch && offOutputWatch();
                    offRulesWatch && offRulesWatch();
                });
            }


            /**
             * Apply data transformation to model based
             * on supplied rules
             */
            function applyTransformation(config) {
                var rules = config.rules,
                    $scope = config.scope,
                    context = $parse(config.modelInput)($scope),
                    source = {},
                    modelInput = config.modelInput,
                    modelOutput = config.modelOutput;

                // Fail early if input model is not an object
                if (!angular.isObject(context)) return;
                context = angular.copy( context );

                rules = parseRules(rules);

                source.rules = rules;
                source.data = context;
                source.scope = $scope;
                source.results = [];

                rules.forEach(function(rule, index) {
                    // Keep track in case advanced rule needs to go up or down stack
                    source.ruleIndex = index;
                    source.prevRule = (index) ? source.rules[index - 1]: '';
                    source.results.push(context);
                    // Set current context
                    context = enAdapterRules.applyRule(rule, context, source);
                });
                source = undefined;

                timestamp = new Date().getTime();
                $scope.$eval(modelOutput + '= context', {'context': context});
            }


            /**
             * Reverse data transformation to source model
             * when reading from destination.
             */
            function applyReverseTransformation(config) {
                var $scope = config.scope,
                    context = $parse(config.modelOutput)($scope),
                    rules = config.applyRevRule || config.rules,
                    onAfterRevTransform = $parse(config.onAfterRevTransform)($scope),
                    inputModel,
                    ruleValue,
                    rule,
                    obj;


                // Fail early if input model is not an object
                if (!angular.isObject(context)) return;
                context = angular.copy( context );

                rules = parseRules(rules);

                while(rules.length) {
                    // Next rule from end (in reverse)
                    rule = rules.pop();

                    // Undo '.' value extraction
                    if (rule.substr(0,1) === '.') {
                        if (angular.isArray(context)) {
                            obj = [];
                            context.forEach(function(item){
                                var itemObj = {};
                                itemObj[rule.substr(1)] = item;
                                obj.push(itemObj);
                            });
                        }
                        else if (angular.isObject(context)) {
                            obj = {};
                            obj[rule.substr(1)] = context;
                        }
                        // Error non object
                        else {
                            console.warn('enAdapter: Unable to reverse transform . rule! Passed in type: ' + typeof(context));
                        }

                        context = obj;
                    }
                    // Undo '*'
                    else if (rule === '*') {
                        obj = [];
                        if (angular.isArray(context)) {
                            obj = context;
                        }
                        else if (angular.isObject(context)) {
                            obj.push(context);
                        }
                        // Error non object
                        else {
                            console.warn('enAdapter: Unable to reverse transform * rule! Passed in type: ' + typeof(context));
                        }

                        context = obj;
                    }
                    // Undo ':obj2array()'
                    else if (rule.match(/^\:obj2array/)) {
                        ruleValue = rule.match(/\(([^\)]*)/)[1];
                        obj = {};

                        if (ruleValue) {
                            ruleValue = ruleValue.replace(/^['"]|['"]$/g, '');
                            context.forEach(function(item, index, origArray){
                                var oldKey = String(item[ruleValue]);
                                if (oldKey) {
                                    delete item[ruleValue];
                                    obj[oldKey] = item;
                                }
                            });
                            context = (Object.keys(obj).length) ? obj: context;
                        }
                        // Need to know the old key
                        else {
                            console.warn('enAdapter: Unable to reverse transform :obj2array() rule! Need the old key value.');
                        }
                    }
                    // Error non object
                    else {
                        if (rule !== "") console.warn('enAdapter: Unsupported reserve transformation rule! Rule: ' + rule);
                    }
                } //while

                timestamp = new Date().getTime();
                // Run on after rev transform if exists
                // assign output to context object
                if (onAfterRevTransform) {
                    inputModel = $parse(config.modelInput)($scope);
                    context = onAfterRevTransform(inputModel, context);
                }
                // assign context to input model
                $scope.$eval(config.modelInput + '= context', {'context': context});
            }


            /**
             * Parse rules if object, string or undefined.
             */
            function parseRules(rules) {
                // If rules is object, expect rule property to contain the rules. Useful if rules changes from scope.
                // Otherwise assume string literal
                // If nothing passed then default to '*'
                return enAdapterParser(rules.rule || rules || '*');
            }

            /**
             * Avoid constant loop of model updates
             */
            function ignoreBounce() {
                var time, proceed;
                if (!timestamp) return;
                time = new Date().getTime();
                return (time - timestamp < debounceRate);
            }

            /**
             * Run a reverse transformation
             */
             function runRevTransform(rules, model) {
                var scope = $rootScope.$new(true),
                    newModel,
                    config;

                scope.modelOutput = model;
                scope.modelInput = {};

                config = {
                    'scope': scope,
                    'modelInput': 'modelInput',
                    'modelOutput': 'modelOutput',
                    'rules': rules
                };

                applyReverseTransformation(config);
                newModel = scope.modelInput;
                scope.$destroy();

                return newModel;
             }


             function runTransform(rules, model) {
                var scope = $rootScope.$new(true),
                    newModel,
                    config;

                scope.modelInput = model;
                scope.modelOutput = [];

                config = {
                    'scope': scope,
                    'modelInput': 'modelInput',
                    'modelOutput': 'modelOutput',
                    'rules': rules
                };

                applyTransformation(config);
                newModel = scope.modelOutput;
                scope.$destroy();

                return newModel;
             }


            return {
                'init': init,
                'transform': runTransform,
                'reverseTransform': runRevTransform
            }
        }]
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
'use strict';

    //angular.module('enspire.ui.components.alert').directive('enAlert', AlertDirective);

    /**
     * @ngdoc directive
     * @name enAlert
     * @module enspire.ui.components.alert
     * @restrict E
     * @element en-alert
     *
     * @description
     * Produces a styled alert content block.
     *
     *
     * @usage
     * <hljs lang="html">
     *     <en-alert>
     *       [Content]
     *     </en-alert>
     * </hljs>
     *
     *
     * ## Color <a name="alertColor"></a>
     * Change the colors of an `alert` by adding a class attribute and using one of the following class names.
     *
     * <en-alert class="">(default)</en-alert>
     *
     * <en-alert class="alert-primary">primary</en-alert>
     *
     * <en-alert class="alert-secondary">secondary</en-alert>
     *
     * <en-alert class="alert-info">info</en-alert>
     *
     * <en-alert class="alert-error">error</en-alert>
     *
     * <en-alert class="alert-success">success</en-alert>
     *
     * <en-alert class="alert-warn">warn</en-alert>
     *
     * <hljs lang="html"><en-alert class="[primary|secondary|info|error|success|warn]">alert content...</en-alert></hljs>
     *
     */

    //function AlertDirective($enTouch) {
    //    return {
    //        restrict    : 'E',
    //        link        : postLink
    //    };
    //
    //    function postLink($scope, $element, $attrs){
    //
    //    }
    //}

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.anchorScroll')
        .service('$enAnchorScroll', AnchorScrollService);


/**
* @ngdoc service
* @name $enAnchorScroll
* @module enspire.ui.components.anchorScroll
*
* @description
* Animated scroll to.
*
*/


    function AnchorScrollService($document, $window, $interval) {
        var document = $document[0];
        var window = $window;
        var speed = 25;

        function getCurrentPagePosition(window, document) {
            // Firefox, Chrome, Opera, Safari
            if (window.pageYOffset){
                return window.pageYOffset;
            }

            // Internet Explorer - standards mode
            if (document.documentElement && document.documentElement.scrollTop){
                return document.documentElement.scrollTop;
            }

            // Internet Explorer older
            if (document.body.scrollTop){
                return document.body.scrollTop;
            }

            return 0;
        }

        function getElementY(document, element) {
            var y = element.offsetTop;
            var node = element;
            while (node.offsetParent && node.offsetParent != document.body) {
                node = node.offsetParent;
                y += node.offsetTop;
            }
            return y;
        }

        this.scrollDown = function (startY, stopY, speed, distance) {
            var timer = 0;

            var step = Math.round(distance / 25);
            var leapY = startY + step;
            var elm = angular.element(document.querySelector('en-win-body'))[0];

            var stop;
            stop = $interval(function(){
                elm.scrollTop = leapY;
                if(leapY===stopY){
                    $interval.cancel(stop);
                }else{
                    leapY += step;
                    if (leapY > stopY){
                        leapY = stopY;
                    }
                }
            }, 10);
        };

        this.scrollUp = function (startY, stopY, speed, distance) {
            var timer = 0;

            var step = Math.round(distance / 25);
            var leapY = startY - step;
            var elm = angular.element(document.querySelector('en-win-body'))[0];

            var stop;
            stop = $interval(function(){
                elm.scrollTop = leapY;
                if(leapY===stopY){
                    $interval.cancel(stop);
                }else{
                    leapY -= step;
                    if (leapY < stopY){
                        leapY = stopY;
                    }
                }
            }, 10);

        };

        this.scrollToTop = function (stopY) {
            console.log('stopY: '+stopY);
            angular.element(document.querySelector('en-win-body'))[0].scrollTop = stopY;
        };

        this.scrollTo = function (elementId, speed) {
            var element = document.querySelector(elementId);

            console.log('scrollTo: ');
            if (element) {
                var startY = angular.element(document.querySelector('en-win-body'))[0].scrollTop;
                var stopY = getElementY(document, element)-150;

                console.log('startY: '+startY);
                console.log('stopY: '+stopY);

                var distance = stopY > startY ? stopY - startY : startY - stopY;

                console.log('distance: '+distance);

                //if (distance < 100) {
                 //   this.scrollToTop(stopY);
               // } else {

                    var defaultSpeed = Math.round(distance / 100);
                    speed = speed || (defaultSpeed > 20 ? 20 : defaultSpeed);

                    if (stopY > startY) {
                        this.scrollDown(startY, stopY, speed, distance);
                    } else {
                        this.scrollUp(startY, stopY, speed, distance);
                    }
               // }
            }

        };
    }
    AnchorScrollService.$inject = ["$document", "$window", "$interval"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
'use strict';

    angular.module('enspire.ui.components.api').directive('enApiObject', ApiDirective);

    /**
     * @ngdoc directive
     * @name enApiObject
     * @module enspire.ui.components.api
     * @restrict E
     * @element en-api-object
     *
     * @description
     * Pulls data from a REST API.
     *
     *
     * @param {string}          name               Reference name of the api object created by this directive.
     * @param {string}          path               API Path used by this directive to send/retrieve data.
     * @param {string}          [method=|LIST, GET, PUT, POST, DELETE]             HTTP method to be used. LIST method is a GET. LIST has built in pagination, filtering and sorting.
     * @param {number=}         [limit=0]          Sets the max number of results per page.
     * @param {string=}         [paging=server|server, local]    Defines where data paging will be handled.
     * @param {string=}         [sorting=server|server, local]   Defines where data sorting will be handled.
     * @param {object=}         params                           Parameters to be passed to the API server based on the method used. For
     *                                                     example, if `method=GET` the params object is output to the path as
     *                                                     `PATH?param1=param1Value&param2=param2Value`. If `method=POST`, the params are posted to the API path as would
     *                                                     be expected.
     * @param {string=}         fields             Comma-delimited list of field names, no spaces. When using this attribute, only the fields defined here will be returned. Alternatively, add a (-) minus sign before a field name to return all except the ones prefixed with the minus.
     * @param {string=}         sort               Name of field the results will be sorted by. To display results in descending order, prefix the field name with a minus (-). `sort="-fieldname"`
     * @param {boolean=}        [trigger]          Instructs the api-object to fire when ready.  If this option is not used, the api-object will default the trigger to true if the
     *                                       api-objects method equals GET or LIST and false for any other methods.
     * @param {boolean=}        disable                  Takes an expression that returns true or false. Generally used for permissions.
     * @param {string=}         data                Preload data
     * @param {boolean=}        [isolated=false]    When true it has an isolated scope and is only available within scope it resides in.
     * @param {boolean=}        [load-once=false]    Takes an expression that returns true or false. API Request can only be made once.
     * @param {object=}         config              Object describing the request to be made and how it should be processed. See https://docs.angularjs.org/api/ng/service/$http#usage for all available properties.
     * @param {string=}         filter              Passes query string with request
     * @param {expression=}     on-init                Callback function on init
     * @param {expression=}     on-list                Callback function on LIST request success
     * @param {expression=}     on-put                 Callback function on PUT request success
     * @param {expression=}     on-get                 Callback function on GET request success
     * @param {expression=}     on-post                Callback function on POST request success
     * @param {expression=}     on-delete              Callback function on DELETE request success
     * @param {expression=}     on-before-list          function before LIST request
     * @param {expression=}     on-before-put           function before PUT request
     * @param {expression=}     on-before-get           function before GET request
     * @param {expression=}     on-before-post          function before POST request
     * @param {expression=}     on-before-delete        function before DELETE request
     * @param {expression=}     on-error                Callback function when ERROR on request
     * @param {boolean=}        [search-shared=false]            Search will be shared on other pages. It must use same api-object name.
     * @param {boolean=}        [search-remembered=true]         Does not reset search when page is left.
     * @param {boolean=}        [search-local-storage=false]     Save search to localStorage indefinitely.
     * @param {boolean=}        [search-match-all=true]          Only results that match all criteria are returned.
     *
     * @usage
     * <hljs lang="html">
     *   <en-api-object method="list" name="objName" path="path/to/api/"></en-api-object>
     * </hljs>
     *
     */

    function ApiDirective($enApi) {
        return {
            restrict    : 'E',
            link        : postLink
        };

        function postLink($scope, $element, $attrs){
            var apiObject = $enApi.object({
                name:$attrs.name,
                path:$attrs.path,
                method:$attrs.method,
                limit: $attrs.limit || 0,
                paging: $attrs.paging || 'server',
                loadOnce: (angular.isDefined($attrs.loadOnce)) ? !!($scope.$eval($attrs.loadOnce)) : false,
                params: $scope.$eval($attrs.params) || {},
                config: $scope.$eval($attrs.config) || {},
                onInit: function(){ $scope.$eval($attrs.onList); } || undefined,
                onList: function(){ $scope.$eval($attrs.onList); } || undefined,
                onPut: function(){ $scope.$eval($attrs.onPut); } || undefined,
                onGet: function(){ $scope.$eval($attrs.onGet); } || undefined,
                onPost: function(){ $scope.$eval($attrs.onPost); } || undefined,
                onDelete: function(){ $scope.$eval($attrs.onDelete); } || undefined,
                onBeforeList: function(){ $scope.$eval($attrs.onBeforeList); } || undefined,
                onBeforePut: function(){ $scope.$eval($attrs.onBeforePut); } || undefined,
                onBeforeGet: function(){ $scope.$eval($attrs.onBeforeGet); } || undefined,
                onBeforePost: function(){ $scope.$eval($attrs.onBeforePost); } || undefined,
                onBeforeDelete: function(){ $scope.$eval($attrs.onBeforeDelete); } || undefined,
                onError: function(){ $scope.$eval($attrs.onError); } || undefined,
                fields: $attrs.fields || '',
                sort: $attrs.sort || '',
                sorting: $attrs.sorting || 'server',
                trigger: $scope.$eval($attrs.trigger),
                disable: $scope.$eval($attrs.disable),
                data: $scope.$eval($attrs.data),
                isolated: (angular.isDefined($attrs.isolated)) ? !!($scope.$eval($attrs.isolated)) : false,
                filter: $attrs.filter || '',
                search:{
                    shared: (angular.isDefined($attrs.searchShared)) ? !!($scope.$eval($attrs.searchShared)) : false,
                    remembered: (angular.isDefined($attrs.searchRemembered)) ? !!($scope.$eval($attrs.searchRemembered)) : true,
                    localStorage: (angular.isDefined($attrs.searchLocalStorage)) ? !!($scope.$eval($attrs.searchLocalStorage)) : false,
                    matchAll: (angular.isDefined($attrs.searchMatchAll)) ? !!($scope.$eval($attrs.searchMatchAll)) : true
                },
                filterMap: $scope.$eval($attrs.filterMap) || {},
                insideModal: (angular.isDefined($scope.isModal)) ? !!$scope.isModal : false,
                modalPath: $scope.modalPath || ''
            });

            $scope[$attrs.name] = apiObject;

            var obvPath = $attrs.$observe('path',function(){
                apiObject.path = $attrs.path;
            });

            var obvFilter = $attrs.$observe('filter',function(){
                apiObject.filter = $attrs.filter || '';
            });

            var watchFilterMap;
            var obvFilterMap = $attrs.$observe('filterMap',function(){
                apiObject.filterMap = $scope.$eval($attrs.filterMap);

                watchFilterMap = $scope.$watch(function(){ return $scope.$eval($attrs.filterMap); }, function (val) {
                    if(angular.isDefined(val)) apiObject.filterMap = $scope.$eval($attrs.filterMap);
                },true);
            });

            $element.bind('$destroy', function(){
                if(apiObject.loadOnce!==true){
                    apiObject.destroy();
                }
                obvPath();
                obvFilterMap();
                if(watchFilterMap!==undefined) watchFilterMap();
            });
        }
    }
    ApiDirective.$inject = ["$enApi"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.api')
        .provider('$enApi', ApiService);


    /**
     * @ngdoc service
     * @name $enApi
     * @module enspire.ui.components.api
     *
     * @usage
     * <hljs lang="js">

     * </hljs>
     *
     */


    function ApiService() {
        var self = this;

        var urlValidate = /^(f|ht)tps?:\/\//i;

        var domains = {
            default:''
        };

        var defaultDomain = 'default';

        self.paramLimitName = "length";

        var addDomain = function(name, baseUrl){
            domains[name] = baseUrl;
            //console.log('Domain Added');
        };

        var setDomain = function(name) {
            self.defaultDomain = name;
            //console.log('Default Domain Set: '+self.defaultDomain);
        };

        var setParamLimitName = function(name) {
            self.paramLimitName = name;
        };

        this.addDomain = addDomain;
        this.setDomain = setDomain;
        this.setParamLimitName = setParamLimitName;
        this.apis = {};
        this.defaultDomain = 'default';

        var allowedProtocols = ['http','https'];
        var allowedMethodValues = ['list','get','put','post','delete'];

        //default object
        var apiObject = {
            domain:self.defaultDomain,
            name:'', //required (name of the object)
            path:'', //required (server path - can be relative and absolute)
            method:'', //required [list,get,put,post,delete]
            config:{},
            data:{},
            segmentedData:{},
            header:{},
            loadOnce:false,
            isolated:true,
            limit:0,
            offset:0,
            page:0,
            pages:0, //read only
            total:0, //read only
            sort:'',
            defaultSort:'',
            q:'',
            filter:'', //overwritten by searches
            filterMap:{}, //depreciated
            search:{
                shared: false,
                remembered: false,
                localStorage: false,
                matchAll: true,
                criteria:[]
            },
            params:{},
            fields:'',
            typing:false, //read only
            loading:false, //read only
            getting:false, //read only
            putting:false, //read only
            posting:false, //read only
            deleting:false, //read only
            sorting:'server', //local OR server
            paging:'server', //local OR server
            pagingLimitParam:undefined,
            pagingOffsetParam:undefined,
            pagingUsesPageNumbers: false,
            trigger:undefined,
            disable:false,
            onList:undefined,
            onGet:undefined,
            onPut:undefined,
            onPost:undefined,
            onDelete:undefined,
            onError:undefined,
            onInit:undefined,
            onBeforeList:undefined,
            onBeforeGet:undefined,
            onBeforePut:undefined,
            onBeforePost:undefined,
            onBeforeDelete:undefined,
            localStorage:false,
            insideModal: false,
            modalPath: '',
            refresh:0,
            expires:0,
            lastRequestAt: 0,
            lastResponseAt: 0,
            lastRequestLatency: 0,
            errors:[],
            selected:[],
            rawData:{}, //read only
            $http:{}, //read only
            _runCount: 0, //private (counter for how many times a server was called)
            _errorCount: 0, //private (counter for how many times a server returned an error for this call)
            _errorConsecutiveCount: 0, //private (counter for how many times a server returned a consecutive error for this call)
            _successCount: 0, //private (counter for how many times a server returned a success for this call);
            _isApiObject:true
        };

        var getPath = function(path,domain){
            if(!domain) domain = '';
            if(!path) path = '';

            var urlPath = path;
            if(domains[domain]!=='' && urlValidate.test(path)===false && typeof domains[domain]!=='undefined'){
                urlPath = domains[domain]+path;
            }
            return urlPath;//.replace(/\/\//g, '/');
        };

        this.$get = ["$http", "$q", "$rootScope", "$interval", "$timeout", "$enApiSearch", function ($http,$q,$rootScope,$interval,$timeout,$enApiSearch) {

            var buildApiObject = function(o){

                var objTemp = angular.copy(apiObject);

                objTemp.domain = self.defaultDomain;

                // ANGULAR 1.4+
                if(angular.isArray(o.data)) {
                    objTemp.data = [];
                }
                var obj = angular.merge(objTemp,o);

                // ANGULAR 1.3-
                //var obj = angular.extend(objTemp,o); //depreciated

                if(self.apis[obj.name] !== undefined && self.apis[obj.name].loadOnce === true && self.apis[obj.name].isolated === false){
                    return self.apis[obj.name];
                }

                //Check required
                if(obj.name===''){
                    console.error('en-api: \'name\' property is not defined');
                    return false;
                }

                if(obj.path===''){
                    console.error('en-api: \'path\' property is not defined');
                    return false;
                }

                if(obj.method===''){
                    console.error('en-api: \'method\' property is not defined');
                    return false;
                }

                //validate method
                if(allowedMethodValues.indexOf(obj.method) === -1){
                    console.error('en-api: \''+ obj.method +'\' is not an allowed method');
                    return false;
                }

                obj.limit = parseInt(obj.limit);

                //allows tracking what the default sort was
                obj.defaultSort = obj.sort;

                obj = buildMethods(obj);

                if(typeof obj.onInit === 'function'){
                    obj.onInit(obj);
                }

                if(obj.isolated === false){
                    $rootScope[obj.name] = obj;
                    self.apis[obj.name] = obj;
                }

                 obj.search = $enApiSearch.loadSearch(obj);

                // Trigger Method (automatic for 'get' && 'list' method)
                if((obj.trigger === undefined || obj.trigger === true) && !obj.disable) {
                    switch (obj.method) {
                        case 'put':
                        case 'post':
                        case 'delete':
                            if (obj.trigger === true && typeof obj[obj.method] === 'function') {
                                obj[obj.method]();
                            }
                            break;
                        default:
                            if (typeof obj[obj.method] === 'function') {
                                obj[obj.method]();
                            }
                    }
                }

                obj.clearSearch = function(){
                    $enApiSearch.clearCriteria(obj)
                };

                return obj;
            };

            var filterMap = function(obj,strFilter){
                var filter = '';
                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        if(obj[key]!=='' && obj[key]!==undefined && obj[key]!==null){
                            if(filter!=='') filter += '&&';
                            filter += key +':'+obj[key]+'';
                        }
                    }
                }


                if(filter!==''){
                    if(strFilter!=='' && strFilter!==undefined){
                        return '('+strFilter+')&&('+filter+')';
                    }else{
                        return '('+filter+')';
                    }
                }else{
                    return strFilter;
                }
            };

            var lastAt = function(objApi,type){
                objApi['last'+type+'At'] = new Date().getTime();
                if(type==='Response') objApi.lastRequestLatency = objApi.lastResponseAt - objApi.lastRequestAt
            };

            var buildMethods = function(objApi){
                var method = objApi.method;

                var incrementServerCount = function(type){
                    objApi._runCount++;
                    if(type === 'success'){
                        objApi.errors = [];
                        objApi._successCount++;
                        objApi._errorConsecutiveCount = 0;
                    }else{
                        objApi._errorCount++;
                        objApi._errorConsecutiveCount++;
                    }
                };

                objApi.destroy = function(){
                    delete $rootScope[objApi.name];
                    delete self.apis[objApi.name];
                };

                var list = function(obj){
                    var passedObj = true;
                    var limit = 0;
                    var offset = 0;
                    var page = 0;
                    var refresh = false;

                    var localPaging = function(){
                        if(objApi.paging === 'local' && (limit>0 || offset>0)){
                            objApi.limit = limit;
                            objApi.total = objApi.rawData.length;
                            objApi.pages = Math.ceil(objApi.total/objApi.limit);
                            if(isNaN(objApi.pages)){
                                objApi.pages = 0;
                            }

                            if(offset >= (objApi.total-1)){
                                offset = objApi.pages*objApi.limit-objApi.limit;
                            }

                            if(offset < 0){
                                offset = 0;
                            }

                            if(objApi.limit>0){
                                objApi.data = objApi.rawData.slice(offset, offset+objApi.limit);
                            }else{
                                objApi.data = objApi.rawData.slice(offset);
                            }

                            objApi.offset = offset;

                        }else{
                            objApi.total = objApi.rawData.total;
                            objApi.offset = objApi.rawData.offset;
                            if(typeof objApi.rawData.limit !== 'undefined'){
                                objApi.limit = objApi.rawData.limit;
                            }else{
                                objApi.limit = objApi.rawData.length;
                            }
                            objApi.pages = Math.ceil(objApi.total/objApi.limit);
                            if(isNaN(objApi.pages)){
                                objApi.pages = 0;
                            }
                        }
                        objApi.page = Math.floor(objApi.pages-(objApi.total-objApi.offset)/objApi.limit+1);
                        if(isNaN(objApi.page)){
                            objApi.page = 0;
                        }
                    };

                    if(obj === undefined){
                        obj = {};
                        passedObj = false;
                    }

                    (obj.limit !== undefined) ? limit = obj.limit : limit = objApi.limit;
                    limit = (limit < 0) ? 0 : limit;
                    (obj.offset !== undefined) ? offset = obj.offset : offset = objApi.offset;
                    offset = (offset < 0) ? 0 : offset;

                    if(offset>objApi.total && objApi.total!==0 && objApi.pages>0){
                        if(objApi.limit !== limit){
                            offset = 0;
                        }else{
                            offset = objApi.pages*limit-1-limit;
                        }
                    }

                    if(obj.page !== undefined){
                        page = obj.page;
                    }
                    if(obj.refresh !== undefined){
                        refresh = obj.refresh;
                    }

                    var deferred = $q.defer();
                    if(objApi.disable === true){
                        deferred.reject();
                        return false;
                    }
                    if(((objApi.paging === 'local' && (objApi._successCount<1 || refresh === true)) || objApi.paging === 'server') && ((objApi.loadOnce === true && (objApi._successCount<1 || refresh === true)) || objApi.loadOnce === false)){
                        if(typeof objApi.onBeforeGet !== 'undefined'){
                            objApi.onBeforeGet();
                        }
                        if(objApi.onBeforeList!==undefined){
                            objApi.onBeforeList();
                        }

                        var config = angular.extend({},objApi.config);
                        config.params = angular.extend(config.params || {},objApi.params);
                        if(config.params === undefined) config.params = {};
                        if(objApi.fields !== '') config.params.fields = objApi.fields.replace(/^\s+|\s+$/g,'');
                        if(limit>0 && objApi.paging !== 'local') config.params[self.paramLimitName] = limit;
                        if(offset>0 && objApi.paging !== 'local') config.params.offset = offset;
                        if(objApi.filter!==''){
                            config.params.filter = objApi.filter;
                        }
                        config.params.filter = filterMap(objApi.filterMap,config.params.filter);
                        config.params.filter = $enApiSearch.buildFilter(objApi.search,config.params.filter);

                        if(objApi.sort!=='') config.params.sort = objApi.sort;

                        objApi.loading = true;
                        objApi.getting = true;

                        var urlPath = getPath(objApi.path,objApi.domain);

                        lastAt(objApi,'Request');
                        $http.get(urlPath,config).then(function(o){
                            lastAt(objApi,'Response');
                            objApi.$http = o;
                            objApi.rawData = o.data;
                            if(Array.isArray(o.data)){
                                objApi.data = o.data;
                            }else{
                                if(o.data.data !== undefined && Array.isArray(o.data.data)){
                                    objApi.data = o.data.data;
                                }else{
                                    if(o.data.items !== undefined && Array.isArray(o.data.items)){
                                        objApi.data = o.data.items;
                                    }else{
                                        objApi.data = o.data;
                                    }
                                }
                            }
                            localPaging();

                            if(objApi.onGet!==undefined){
                                objApi.onGet(objApi.data,objApi.$http);
                            }
                            if(objApi.onList!==undefined){
                                objApi.onList(objApi.data,objApi.$http);
                            }

                            incrementServerCount('success');
                            objApi.segmentedData = objApi.data;
                            objApi.loading = false;
                            objApi.getting = false;
                            deferred.resolve(objApi.data,objApi.$http);
                        },function(e){
                            lastAt(objApi,'Response');
                            objApi.$http = e;
                            objApi.rawData = e.data;
                            objApi.data = [];

                            if(e.data.errors===undefined){
                                objApi.errors = [];
                                objApi.errors.push(e.data);
                            }else{
                                objApi.errors = e.data.errors;
                            }

                            if(objApi.onError!==undefined){
                                objApi.onError(objApi.rawData,objApi.$http);
                            }

                            incrementServerCount('error');
                            objApi.loading = false;
                            objApi.getting = false;
                            deferred.reject(e);
                        });
                    }else{
                        if(passedObj){
                            localPaging();
                        }else{
                            $timeout(function(){
                                deferred.resolve(objApi.data,objApi.$http);
                            });
                        }
                    }
                    return deferred.promise;

                };

                switch(method){
                    case 'list':
                        objApi.list = list;
                        objApi.get = list;

                        objApi.refresh = function(bolResetOffset,delay){
                            var obj = {refresh:true};
                            if(bolResetOffset) obj.offset = 0;
                            if(typeof delay !== 'undefined'){
                                if(delay === true) delay = 0;
                                $timeout(function(){
                                    objApi.list(obj);
                                },delay);
                            }else{
                                return objApi.list(obj);
                            }
                        };

                        objApi.next = function(){
                            return objApi.list({offset:objApi.offset+objApi.limit});
                        };
                        objApi.previous = function(){
                            return objApi.list({offset:objApi.offset-objApi.limit});
                        };
                        objApi.first = function(){
                            return objApi.list({offset:0});
                        };
                        objApi.last = function(){
                            return objApi.list({offset:objApi.total-objApi.limit});
                        };
                        objApi.begin = function(){
                            return objApi.list({offset:0});
                        };
                        objApi.setSort = function(field){
                            if(field===''){
                                objApi.sort = obj.defaultSort;
                            }else{
                                objApi.sort = field;
                            }
                            return objApi.list({offset:0});
                        };
                        break;
                    case 'get':
                        objApi.get = function(obj){
                            if(obj === undefined){

                            }

                            if(objApi.onBeforeGet!==undefined){
                                objApi.onBeforeGet();
                            }

                            var config = angular.extend({},objApi.config);
                            config.params = angular.extend(config.params || {},objApi.params);
                            if(config.params === undefined) config.params = {};

                            var deferred = $q.defer();
                            if(objApi.disable === true){
                                deferred.reject();
                                return false;
                            }
                            objApi.getting = true;
                            objApi.loading = true;

                            var urlPath = getPath(objApi.path,objApi.domain);

                            lastAt(objApi,'Request');
                            $http.get(urlPath,config).then(function(o){
                                lastAt(objApi,'Response');
                                objApi.$http = o;
                                objApi.data = o.data;
                                objApi.rawData = o.data;

                                if(objApi.onGet!==undefined){
                                    objApi.onGet(objApi.data,objApi.$http);
                                }

                                objApi.getting = false;
                                objApi.loading = false;

                                incrementServerCount('success');
                                deferred.resolve(o.data,o);
                            },function(e){
                                lastAt(objApi,'Response');
                                objApi.$http = e;
                                objApi.rawData = e.data;
                                objApi.data = [];
                                objApi.getting = false;
                                objApi.loading = false;

                                if(e.data.errors===undefined){
                                    objApi.errors = [];
                                    objApi.errors.push(e.data);
                                }else{
                                    objApi.errors = e.data.errors;
                                }

                                if(objApi.onError!==undefined){
                                    objApi.onError(objApi.rawData,objApi.$http);
                                }

                                incrementServerCount('error');
                                deferred.reject(e);
                            });
                            return deferred.promise;
                        };
                        //NO BREAK SO DELETE & PUT GETS ADDED AS WELL
                    case 'delete':
                        objApi.delete = function(obj){

                            var deferred = $q.defer();
                            if(objApi.disable === true){
                                deferred.reject();
                                return false;
                            }
                            objApi.deleting = true;
                            objApi.loading = true;

                            if(objApi.onBeforeDelete!==undefined){
                                objApi.onBeforeDelete();
                            }

                            var config = angular.extend({},objApi.config);
                            config.params = angular.extend(config.params || {},objApi.params);
                            if(config.params === undefined) config.params = {};
                            config.data = objApi.data;

                            var urlPath = getPath(objApi.path,objApi.domain);

                            lastAt(objApi,'Request');
                            $http.delete(urlPath,config).then(function(o){
                                lastAt(objApi,'Response');
                                //console.log(o.data);
                                objApi.$http = o;
                                objApi.data = o.data;
                                objApi.rawData = o.data;

                                if(objApi.onDelete!==undefined){
                                    objApi.onDelete(objApi.data,objApi.$http);
                                }

                                objApi.deleting = false;
                                objApi.loading = false;
                                incrementServerCount('success');
                                deferred.resolve(o.data,o);
                            },function(e){
                                lastAt(objApi,'Response');
                                objApi.$http = e;
                                if(e.data.errors===undefined){
                                    objApi.errors = [];
                                    objApi.errors.push(e.data);
                                }else{
                                    objApi.errors = e.data.errors;
                                }

                                if(objApi.onError!==undefined){
                                    objApi.onError(objApi.rawData,objApi.$http);
                                }

                                objApi.deleting = false;
                                objApi.loading = false;
                                incrementServerCount('error');
                                deferred.reject(e);
                            });
                            return deferred.promise;
                        };

                        //ONLY BREAK IF CALL IS ONLY A DELETE AND NOT A GET, AS WE AUTOMATICALLY ADD DELETE & PUT ON GET CALLS
                        if(method==='delete') break;
                    case 'put':
                        objApi.put = function(obj){

                            var deferred = $q.defer();
                            if(objApi.disable === true){
                                deferred.reject();
                                return false;
                            }

                            objApi.putting = true;
                            objApi.loading = true;

                            if(objApi.onBeforePut!==undefined){
                                objApi.onBeforePut();
                            }

                            var config = angular.extend({},objApi.config);
                            config.params = angular.extend(config.params || {},objApi.params);
                            if(config.params === undefined) config.params = {};

                            var urlPath = getPath(objApi.path,objApi.domain);

                            lastAt(objApi,'Request');
                            $http.put(urlPath,objApi.data,config).then(function(o){
                                lastAt(objApi,'Response');
                                //console.log(o.data);
                                objApi.$http = o;
                                objApi.data = o.data;
                                objApi.rawData = o.data;

                                if(objApi.onPut!==undefined){
                                    objApi.onPut(objApi.data,objApi.$http);
                                }

                                objApi.putting = false;
                                objApi.loading = false;
                                incrementServerCount('success');
                                deferred.resolve(o.data,o);
                            },function(e){
                                lastAt(objApi,'Response');
                                objApi.$http = e;
                                if(e.data.errors===undefined){
                                    objApi.errors = [];
                                    objApi.errors.push(e.data);
                                }else{
                                    objApi.errors = e.data.errors;
                                }

                                if(objApi.onError!==undefined){
                                    objApi.onError(objApi.rawData,objApi.$http);
                                }

                                objApi.putting = false;
                                objApi.loading = false;
                                incrementServerCount('error');
                                deferred.reject(e);
                            });
                            return deferred.promise;
                        };
                        break;
                    case 'post':
                        objApi.post = function(obj){

                            var deferred = $q.defer();
                            if(objApi.disable === true){
                                deferred.reject();
                                return false;
                            }

                            objApi.posting = true;

                            if(objApi.onBeforePost!==undefined){
                                objApi.onBeforePost();
                            }

                            var config = angular.extend({},objApi.config);
                            config.params = angular.extend(config.params || {},objApi.params);
                            if(config.params === undefined) config.params = {};

                            var urlPath = getPath(objApi.path,objApi.domain);

                            lastAt(objApi,'Request');
                            $http.post(urlPath,objApi.data,config).then(function(o){
                                lastAt(objApi,'Response');
                                //console.log(o.data);
                                objApi.$http = o;
                                objApi.data = o.data;
                                objApi.rawData = o.data;

                                if(objApi.onPost!==undefined){
                                    objApi.onPost(objApi.data,objApi.$http);
                                }

                                objApi.posting = false;
                                objApi.loading = false;
                                incrementServerCount('success');
                                deferred.resolve(o.data,o);
                            },function(e){
                                lastAt(objApi,'Response');
                                objApi.$http = e;
                                if(e.data.errors===undefined){
                                    objApi.errors = [];
                                    objApi.errors.push(e.data);
                                }else{
                                    objApi.errors = e.data.errors;
                                }

                                if(objApi.onError!==undefined){
                                    objApi.onError(objApi.rawData,objApi.$http);
                                }

                                objApi.posting = false;
                                objApi.loading = false;
                                incrementServerCount('error');
                                deferred.reject(e);
                            });
                            return deferred.promise;
                        };
                        break;
                }

                return objApi;
            };

            var factory = {
                object: buildApiObject
            };
            return factory;
        }];
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
angular
    .module('enspire.ui.components.autocomplete')
    .controller('enAutocompleteCtrl', enAutocompleteCtrl);

function enAutocompleteCtrl($scope, $element, $attrs, $timeout, $enConfig, $enAutocomplete) {
    var self            = $scope,
        itemsArg        = $attrs.autocompleteItems.split(/ in /i),
        itemExpr        = itemsArg[1],
        cache           = {};

    self.itemKey        = itemsArg[0];
    self.itemText       = $attrs.autocompleteItemText || '';
    self.noCache        = $scope.$eval($attrs.autocompleteNoCache) || false;
    self.loading        = false;
    self.hidden         = true;
    self.index          = null;
    self.isDisabled     = null;
    self.isRequired     = null;
    self.hasFocus       = false;
    self.hasNotFound    = false;
    self.delay          = 300;
    self.searchText     = null;
    self.minLength      = $scope.$eval($attrs.autocompleteMinLength) ||  3;
    self.items          = [];
    self.matches        = [];
    self.selectedItems  = [];
    self.selectedItem   = null;
    self.onChange       = $scope.$eval($attrs.autocompleteOnChange);
    self.onSelect       = $attrs.autocompleteOnSelect || function(){};

    self.autocompleteResults = function(query) {
        var path = $attrs.autocompleteApi,
            fields  = $attrs.autocompleteSearchableFields,
            filterArr  = $attrs.autocompleteQueryFilters.split(','),
            filters = [],
            filterStr = '',
            limit  = $attrs.autocompleteLimit || 10;

        for(var i = 0, l = filterArr.length; i < l; i++) {
            filters.push(filterArr[i] + ':%' + query + '%');
        }

        filterStr = filters.join('||');

        //console.log('filterStr', filterStr);
        //console.log($enAutocomplete.getResults(query, path, fields, filterStr));
        return $enAutocomplete.getResults(query, path, fields, filterStr, limit);
    };

    self.clearCache = function() {
        cache = {};
    };
    self.inCache    = function(key){
        return cache.hasOwnProperty(key);
    };
    self.getCache   = function(key){
        return cache[key];
    };

    self.selectItem   = function(item) {
        self.selectedItem = item;
        self.hidden = shouldHide();
        self.selectedItemChanged();
    };

    self.selectedItemChanged = function() {
        $scope.$eval(self.onSelect)(self.selectedItem);
        if ($attrs.autocompleteClearText) {
            clearSearchText();
        }
        self.selectedItem = null;
    };

    function clearSearchText() {
        // Set the loading to true so we don't see flashes of content
        setLoading(true);

        // Reset our variables
        self.index        = null;
        self.matches      = [];
        //self.searchText   = '';
        self.$ngModel.$setViewValue('');
        self.$ngModel.$render();

        // Tell the select to fire and select nothing
        //select(-1);

        // Per http://www.w3schools.com/jsref/event_oninput.asp
        //var eventObj = document.createEvent('CustomEvent');
        //eventObj.initCustomEvent('input', true, true, {value: $scope.searchText});
        //elements.input.dispatchEvent(eventObj);

        //elements.input.focus();
    }

    function clearMatches() {
        self.matches = [];
        self.hidden  = true;
    }

    function hasMatches() {
        return self.matches.length > 0;
    }

    function hasSelection() {
        return self.selectedItem ? true : false;
    }

    self.setFocus = function() {
        //elements.input.focus();


        $timeout(function() {
            self.hasFocus = true;
            self.hidden = !shouldShow();
        });
    };

    self.removeFocus = function() {

        $timeout(function(){
            self.hasFocus = false;
            self.hidden = shouldHide();
            self.index = null;
        });


    };

    self.initialize = function() {

    };

    //self.filterList = function(){
    //    self.matches = self.items;
    //
    //};
    //
    //
    //self.updateSearchList = function(newList, oldList){
    //    if(!!Object.keys(new enObjectDiff({'leftObj': self.items, 'rightObj': newList})).length){
    //        self.items = newList;
    //    }
    //};

    function shouldHide() {
        if(self.loading && !hasMatches()) {
            return true;        // Hide while loading initial matches
            //}else if(hasSelection()){
            //     return true;        // Hide if there is already a selection
        }else if(!self.hasFocus){
            return true;        // Hide if the input does not have focus
        }else{
            return !shouldShow(); // Defer to standard show logic
        }
    }

    function shouldShow() {
        return (minLengthMet() && hasMatches());
    }

    function setLoading(value) {
        if(self.loading != value){
            self.loading = value;
        }
        self.hidden = shouldHide();
    }

    function notFoundVisible() {
        return self.hasNotFound && !hasMatches() && !self.loading && minLengthMet(self.searchText) && hasFocus && !hasSelection();
    }

    self.handleTextChange = function(newQuery, oldQuery) {
        if (newQuery === oldQuery) return;
        //self.onTextChange(newQuery);


        self.searchText = newQuery;

        if(!minLengthMet(newQuery)) {
            setLoading(false);
            clearMatches();
        }else{
            handleQuery();
            //$scope.$eval($attrs.autocompleteQuery);
        }
        //console.log(newQuery);
    };

    function handleQuery() {
        var searchText = self.searchText || '',
            term       = searchText.toLowerCase();

        if(!self.noCache && cache[term]){
            self.matches = cache[term];
        }else{
            fetchResults(searchText);
        }
        self.index = null;
        self.hidden = shouldHide();
    }

    //uses the last part (someExpression) of "item in someExpression" to fetch a fresh list of results.
    //the searchText argument is passed to the expressive function.
    function fetchResults(searchText) {
        var items = self.$eval(itemExpr),
            term  = searchText.toLowerCase();

        //if(angular.isFunction(items)){
        //    items = items(searchText);
        //}

        if(angular.isArray(items)) {
            handleResults(items);
        }else if(items){
            setLoading(true);

            $timeout(function(){
                if(items.success){
                    items.success(handleResults);
                }
                if(items.then){
                    items.then(handleResults);
                }
                if(items.finally){
                    items.finally(function(){
                        setLoading(false);
                    });
                }
            },0);
        }

        function handleResults(matches) {
            cache[term] = matches;
            if((searchText || '') !== (self.searchText || '')) {
                return;
            }

            self.matches = matches;

            $timeout(function() {
                self.hidden  = shouldHide();
            });

            //if($scope.selectOnMatch){
            //    selectItemOnMatch();
            //}
            //positionDropdown();
        }
    }

    self.setIndex = function(index) {
        $timeout(function(){
            self.index = index;
        });
    };

    self.keydown = function(event) {
        switch(event.keyCode){
            case $enConfig.KEY_CODE.DOWN_ARROW:
                if(self.loading){
                    return;
                }
                event.stopPropagation();
                event.preventDefault();
                //self.index = Math.min(self.index + 1, self.matches.length - 1);
                self.setIndex(Math.min(self.index !== null ? (self.index + 1) : 0, self.matches.length - 1));
                //updateScroll();
                //updateMessages();
                break;
            case $enConfig.KEY_CODE.UP_ARROW:
                if(self.loading) return;
                event.stopPropagation();
                event.preventDefault();

                self.setIndex(self.index < 0 ? self.matches.length - 1 : Math.max(0, self.index - 1));

                //self.index = self.index < 0 ? self.matches.length - 1 : Math.max(0, self.index - 1);
                //updateScroll();
                //updateMessages();
                break;
            case $enConfig.KEY_CODE.TAB:
                // If we hit tab, assume that we've left the list so it will close
                //onListLeave();

                if(self.hidden || self.loading || self.index < 0 || self.matches.length < 1) return;
                self.removeFocus();
                break;
            case $enConfig.KEY_CODE.ENTER:
                if(self.hidden || self.loading || self.index < 0 || self.matches.length < 1) return;
                if(hasSelection()) return;
                event.stopPropagation();
                event.preventDefault();
                self.selectItem(self.matches[self.index]);
                break;
            case $enConfig.KEY_CODE.ESCAPE:
                event.stopPropagation();
                event.preventDefault();
                clearSearchText();

                // Force the component to blur if they hit escape
                //doBlur(true);
                self.removeFocus();
                break;
            default:
        }
    };

    function positionDropdown() {}

    function configureWatchers () {
        //var wait = parseInt($scope.delay, 10) || 0;
        //$attrs.$observe('disabled', function (value) { ctrl.isDisabled = !!value; });
        //$attrs.$observe('required', function (value) { ctrl.isRequired = !!value; });
        //$scope.$watch('searchText', wait ? $mdUtil.debounce(handleTextChange, wait) : handleTextChange);
        //$scope.$watch('selectedItem', selectedItemChange);
        //angular.element($window).on('resize', positionDropdown);
        //$scope.$on('$destroy', cleanup);
    }

    function cleanup() {
        //angular.element($window).off('resize', positionDropdown);
        //if(elements){
        //    var items = 'ul scroller scrollContainer input'.split(' ');
        //    angular.forEach(items, function(key){
        //        elements.$[key].remove();
        //    });
        //}
    }

    function minLengthMet(text) {
        return ($scope.searchText || '').length >= getMinLength();
    }

    function getMinLength() {
        return angular.isNumber($scope.minLength) ? $scope.minLength : 1;
    }

}
enAutocompleteCtrl.$inject = ["$scope", "$element", "$attrs", "$timeout", "$enConfig", "$enAutocomplete"];

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
angular
    .module('enspire.ui.components.autocomplete')
    .directive('enAutocomplete', enAutocomplete);

/**
 * @ngdoc directive
 * @name enAutocomplete
 * @module enspire.ui.components.autocomplete
 *
 * @description
 * `<en-autocomplete>` is a special input component with a drop-down of all possible matches to a
 *     custom query. This component allows you to provide real-time suggestions as the user types
 *     in the input area.
 *
 *
 * @param {expression} md-items An expression in the format of `item in items` to iterate over
 *     matches for your search.
 *
 * @usage
 * ### Basic Example
 * <hljs lang="html">
 *   <en-autocomplete
 *       md-selected-item="selectedItem"
 *       md-search-text="searchText"
 *       md-items="item in getMatches(searchText)"
 *       md-item-text="item.display">
 *     <span md-highlight-text="searchText">{{item.display}}</span>
 *   </en-autocomplete>
 * </hljs>
 *
 */

function enAutocomplete($compile, $timeout, $templateCache){
    return {
        restrict    : 'A',
        require     : '^ngModel',
        controller  : 'enAutocompleteCtrl',
        link        : postLink
    };


    function postLink($scope, $element, $attrs, $ngModel){
        var self     = $scope;
        self.$ngModel   = $ngModel;

        $scope.resultsElement = $compile(resolveTemplate($element, $attrs))($scope);

        angular.element(document.querySelector('.autocomplete-wrapper')).append($scope.resultsElement);

        $scope.$watch($attrs.ngModel, self.delay ? debounce(self.handleTextChange, self.delay, self) : $scope.handleTextChange);
        $scope.$watch($attrs.autocompleteSearchText, self.delay ? debounce(self.handleTextChange, self.delay, self) : $scope.handleTextChange);

        $element.on('focus', function(){
            self.setFocus();
        });
        $element.on('blur', function(){
            self.removeFocus();
        });
        $element.on('keydown', function($event){
            self.keydown($event);
        });
    }

    function debounce(func, wait, scope, invokeApply) {
        var timer;

        return function debounced() {
            var context = scope,
                args = Array.prototype.slice.call(arguments);

            $timeout.cancel(timer);
            timer = $timeout(function() {
                timer = undefined;
                func.apply(context, args);
            }, wait || 10, invokeApply);
        };
    }

    function resolveTemplate($element, $attrs){
        var itemsArg        = $attrs.autocompleteItems.split(/ in /i);
        var itemKey        = itemsArg[0];
        var itemText       = $attrs.autocompleteItemText || '';

        var strTemplate = '<en-autocomplete-results class="ng-hide" ng-show="!hidden" style="width:' + ($attrs.autocompleteWidth || '250') + 'px;">' +
            '<en-body flex>' +
            '   <div>' +
            '       <en-autocomplete-item en-tap="selectItem(' + itemKey + ')" ng-repeat="' + itemKey + ' in matches" ' +
            'ng-class="{\'highlighted\':index===$index}">';

            if(angular.isDefined($attrs.autocompleteTemplate) && $attrs.autocompleteTemplate!=='' && $attrs.autocompleteTemplate!==true){
                strTemplate += $templateCache.get($attrs.autocompleteTemplate)
            }else {
                strTemplate += '<div>{{' + itemText + '}}</div>'
            }

            strTemplate += '' +
            '       </en-autocomplete-item>' +
            '   </div>' +
            '</en-body>' +
            '<div class="label-loader" layout="column" layout-align="center center" ng-show="loading">' +
            '    <div>' +
            '        <en-icon icon="spinner"></en-icon>' +
            '       <div class="label-loader-text">{{loadingText}}</div>' +
            '    </div>' +
            '</div>' +
            '</en-autocomplete-results>';

        return strTemplate;
    }
}
enAutocomplete.$inject = ["$compile", "$timeout", "$templateCache"];

//'<div class="margin-bottom autocomplete-wrapper">' +
//'<en-field><en-input><en-icon icon="search"></en-icon>' +
//'<input type="text" ng-model="ac.searchText" placeholder="Search/Scan Products & Services">' +
//'<en-icon icon="barcode-scan" style="font-size: 20px;"></en-icon>' +
//'</en-input></en-field></div>'

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.autocomplete').factory('$enAutocomplete', ComponentService);

    function ComponentService($enApi) {
        var self = this;

        self.mockData = {"data": [
            {
                "id": "a0ec2130-cf24-11e5-8b5d-d76d7fe5a23b",
                "refName": "a0ec2131-cf24-11e5-8b5d-d76d7fe5a23b",
                "refKey": "0d71a30c0dcd73033305f9033f421bf0",
                "dataDomains": [],
                "sequential": 14,
                "product": {
                    "name": "Blackstone Griddle Cooking Station, 28\"",
                    "tags": [
                        {
                            "text": "grill"
                        },
                        {
                            "text": "griddle"
                        }
                    ],
                    "type": "product",
                    "brand": {
                        "name": "Blackstone",
                        "refKey": "176e2c11e57a2ace124a2767d465000c"
                    },
                    "media": [
                        {
                            "url": "",
                            "tags": [],
                            "bytes": 0,
                            "width": 0,
                            "format": "",
                            "height": 0,
                            "refKey": "e96e249d09acde835a825ab34bfd5f5a",
                            "default": false,
                            "fileName": "",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": ""
                        },
                        {
                            "url": "",
                            "tags": [],
                            "bytes": 0,
                            "width": 0,
                            "format": "",
                            "height": 0,
                            "refKey": "deeab3887ef3679f83b5c085d3fd43dd",
                            "default": false,
                            "fileName": "",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": ""
                        }
                    ],
                    "origin": "US",
                    "refKey": "b4218ad4e1f4562273e2b62bfc79895a",
                    "subtype": "variants",
                    "taxCode": {
                        "name": "GEN_TAX",
                        "refKey": "5f3ce899dc0bc95ef7b6cf1c1dd12e17"
                    },
                    "updated": 1455056685000,
                    "metaTags": {
                        "title": "",
                        "keywords": "",
                        "description": ""
                    },
                    "shortName": "28\" Blackstone Griddle",
                    "attributes": {},
                    "serialized": false,
                    "description": "",
                    "inventoried": false,
                    "idVerification": false,
                    "containsAlcohol": false,
                    "customerRewards": true,
                    "productHierarchy": {
                        "name": "Grills & Smokers"
                    },
                    "shortDescription": "The Blackstone 28\" griddle cooking station offers a thick cold rolled steel griddle cooking surface. Offers 2 independently controlled burners with push button ignition. Folds up for easy transportation.",
                    "containsHazardousMaterial": false
                },
                "variant": {
                    "tags": [],
                    "matrix": {},
                    "refKey": "6551bf50c65880a5a11fa5dae4fa9d54",
                    "baseUOM": "ea",
                    "updated": 1451948351000,
                    "usesUom": false,
                    "attributes": {},
                    "defaultPurchaseUOM": "ea"
                },
                "sku": {
                    "uom": {
                        "name": "Each",
                        "abbreviation": "ea"
                    },
                    "code": "BSG79357",
                    "tags": [],
                    "lookups": {},
                    "uomBase": true,
                    "updated": 1451948351000,
                    "sellable": true,
                    "settings": {
                        "noLabelNeeded": false,
                        "promptPriceEntryWhenAddToOrder": false,
                        "promptQuantityEntryWhenAddToOrder": false
                    },
                    "attributes": {},
                    "dimensions": {
                        "depth": {
                            "units": "inches",
                            "value": "19"
                        },
                        "width": {
                            "units": "inches",
                            "value": "28"
                        },
                        "height": {
                            "units": "inches",
                            "value": "35"
                        },
                        "volume": {
                            "units": "fluid ounces",
                            "value": "0"
                        },
                        "weight": {
                            "units": "ounces",
                            "value": "1200"
                        },
                        "netWeight": {
                            "units": "ounces",
                            "value": "1200"
                        }
                    },
                    "purchasable": true,
                    "uomBaseUnits": 1,
                    "variantRefKey": "6551bf50c65880a5a11fa5dae4fa9d54"
                },
                "catalogs": {},
                "categories": {},
                "pricing": {
                    "defaults": {
                        "EUR": "012976626be18e897193be7a1f200ca2",
                        "USD": "8fb4554513934bc459807f086bb41ee6"
                    },
                    "priceBooks": {
                        "012976626be18e897193be7a1f200ca2": {
                            "msrp": 275,
                            "name": "Default Pricing - EUR",
                            "fixed": false,
                            "floor": 0,
                            "regular": 225,
                            "currency": "EUR",
                            "includesTax": true,
                            "systemDefault": true,
                            "priceBookRefKey": "012976626be18e897193be7a1f200ca2"
                        },
                        "8fb4554513934bc459807f086bb41ee6": {
                            "msrp": 199.99,
                            "name": "Default Pricing - USD",
                            "fixed": false,
                            "floor": 0,
                            "regular": 178.47,
                            "currency": "USD",
                            "includesTax": false,
                            "systemDefault": true,
                            "priceBookRefKey": "8fb4554513934bc459807f086bb41ee6"
                        }
                    }
                },
                "updated": 1455108406000,
                "archived": false,
                "inventory": {
                    "available": 0,
                    "reserved": 0,
                    "onOrder": 0,
                    "committed": 0,
                    "unavailable": 0
                }
            },
            {
                "id": "a0c51130-cf24-11e5-8b5d-d76d7fe5a23b",
                "refName": "a0c51131-cf24-11e5-8b5d-d76d7fe5a23b",
                "refKey": "339d137568ab3f02327807a8d03f1919",
                "dataDomains": [],
                "sequential": 13,
                "product": {
                    "name": "All-Clad® Stainless Steel Barbecue Tool Set",
                    "tags": [
                        {
                            "text": "grill-tools"
                        }
                    ],
                    "type": "product",
                    "brand": {
                        "name": "All-Clad",
                        "refKey": "2e2fd63e230dc5de7f3eba9a15fe2dca"
                    },
                    "media": [
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1452103954/d3f7a2ca2174552e4b8f93f8d827df0f.jpg",
                            "tags": [],
                            "bytes": 24338,
                            "width": 425,
                            "format": "jpg",
                            "height": 425,
                            "refKey": "d3f7a2ca2174552e4b8f93f8d827df0f",
                            "default": true,
                            "fileName": "main_variation_Default_view_1_425x425",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1452103954/d3f7a2ca2174552e4b8f93f8d827df0f.jpg"
                        }
                    ],
                    "origin": "China",
                    "refKey": "2eb6f20fa1084e9b55525f3101d422dc",
                    "subtype": "single",
                    "taxCode": {
                        "name": "GEN_TAX",
                        "refKey": "5f3ce899dc0bc95ef7b6cf1c1dd12e17"
                    },
                    "updated": 1447896786000,
                    "metaTags": {
                        "title": "",
                        "keywords": "",
                        "description": ""
                    },
                    "shortName": "Barbecue Tool Set",
                    "attributes": {},
                    "serialized": false,
                    "description": "",
                    "inventoried": false,
                    "idVerification": false,
                    "containsAlcohol": false,
                    "customerRewards": true,
                    "productHierarchy": {
                        "name": "Grilling Tools"
                    },
                    "shortDescription": "",
                    "containsHazardousMaterial": false
                },
                "variant": {
                    "tags": [],
                    "matrix": {},
                    "refKey": "4eb62b3fee3282f12fe0db77992ddab5",
                    "baseUOM": "ea",
                    "updated": 1448066725000,
                    "usesUom": false,
                    "attributes": {},
                    "defaultPurchaseUOM": "ea"
                },
                "sku": {
                    "uom": {
                        "name": "Each",
                        "abbreviation": "ea"
                    },
                    "code": "298679",
                    "tags": [],
                    "lookups": {},
                    "uomBase": true,
                    "updated": 1447896786000,
                    "sellable": true,
                    "settings": {
                        "noLabelNeeded": false,
                        "promptPriceEntryWhenAddToOrder": false,
                        "promptQuantityEntryWhenAddToOrder": false
                    },
                    "attributes": {},
                    "dimensions": {
                        "depth": {
                            "units": "inches",
                            "value": "0"
                        },
                        "width": {
                            "units": "inches",
                            "value": "0"
                        },
                        "height": {
                            "units": "inches",
                            "value": "0"
                        },
                        "volume": {
                            "units": "fluid ounces",
                            "value": "0"
                        },
                        "weight": {
                            "units": "pounds",
                            "value": "0"
                        },
                        "netWeight": {
                            "units": "pounds",
                            "value": "0"
                        }
                    },
                    "purchasable": true,
                    "uomBaseUnits": 1,
                    "variantRefKey": "4eb62b3fee3282f12fe0db77992ddab5"
                },
                "catalogs": {
                    "015bc55b01e32eecac0b2500229cb92a": {
                        "name": "Ecommerce",
                        "refKey": "015bc55b01e32eecac0b2500229cb92a",
                        "priceBook": "79cc841936a65cb393f7c07bad2473f8",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "7ad12efa0d503b104f337bcea070d03b": {
                        "name": "Retail - San Francisco",
                        "refKey": "7ad12efa0d503b104f337bcea070d03b",
                        "priceBook": "413c54c7eeaae2aa60d0d8fc6a45f656",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "bb4644a89b3c9d0ab9300b8d2a14cbd5": {
                        "name": "Retail - Spain",
                        "refKey": "bb4644a89b3c9d0ab9300b8d2a14cbd5",
                        "priceBook": "336dda8d3be833d74bba07e0878b2c7e",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "d52aefadd57e1070160c10795fe29533": {
                        "name": "Retail",
                        "refKey": "d52aefadd57e1070160c10795fe29533",
                        "priceBook": "8fb4554513934bc459807f086bb41ee6",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "db5549e9ab9cad7eee9ddb36406c8da3": {
                        "name": "Retail - Miami",
                        "refKey": "db5549e9ab9cad7eee9ddb36406c8da3",
                        "priceBook": "8fb4554513934bc459807f086bb41ee6",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    }
                },
                "categories": {
                    "4e71fb7c0a12a7e4b41e71db1655a057": {
                        "name": "Cooking",
                        "path": "Cooking",
                        "refKey": "4e71fb7c0a12a7e4b41e71db1655a057",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "8a80a801c20ccf42647038a47fc3bc9b": {
                        "name": "Grilling",
                        "path": "Cooking > Grilling",
                        "refKey": "8a80a801c20ccf42647038a47fc3bc9b",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "b4e7d242302dc4a4d5d2e6c91db8f400": {
                        "name": "Cookware",
                        "path": "Cooking > Cookware",
                        "refKey": "b4e7d242302dc4a4d5d2e6c91db8f400",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    }
                },
                "pricing": {
                    "defaults": {
                        "EUR": "012976626be18e897193be7a1f200ca2",
                        "USD": "8fb4554513934bc459807f086bb41ee6"
                    },
                    "priceBooks": {
                        "012976626be18e897193be7a1f200ca2": {
                            "msrp": 144,
                            "name": "Default Pricing - EUR",
                            "fixed": false,
                            "floor": 0,
                            "regular": 119.95,
                            "currency": "EUR",
                            "includesTax": true,
                            "systemDefault": true,
                            "priceBookRefKey": "012976626be18e897193be7a1f200ca2"
                        },
                        "8fb4554513934bc459807f086bb41ee6": {
                            "msrp": 144,
                            "name": "Default Pricing - USD",
                            "fixed": false,
                            "floor": 0,
                            "regular": 119.95,
                            "currency": "USD",
                            "includesTax": false,
                            "systemDefault": true,
                            "priceBookRefKey": "8fb4554513934bc459807f086bb41ee6"
                        }
                    }
                },
                "updated": 1455108406000,
                "archived": false,
                "inventory": {
                    "available": 0,
                    "reserved": 0,
                    "onOrder": 0,
                    "committed": 0,
                    "unavailable": 0
                }
            },
            {
                "id": "a1886130-cf24-11e5-8b5d-d76d7fe5a23b",
                "refName": "a1886131-cf24-11e5-8b5d-d76d7fe5a23b",
                "refKey": "c8ff81bb45d0340cebfe570bd986fdd6",
                "dataDomains": [],
                "sequential": 16,
                "product": {
                    "name": "Grill tool2",
                    "tags": [
                        {
                            "text": "grill-tool"
                        }
                    ],
                    "type": "product",
                    "brand": {
                        "name": "All-Clad",
                        "refKey": "2e2fd63e230dc5de7f3eba9a15fe2dca"
                    },
                    "media": [],
                    "origin": "USA",
                    "refKey": "315337bab5d29c05901bf2bdff9e0566",
                    "subtype": "single",
                    "taxCode": {
                        "name": "GEN_TAX",
                        "refKey": "5f3ce899dc0bc95ef7b6cf1c1dd12e17"
                    },
                    "updated": 1455055763000,
                    "metaTags": {
                        "title": "",
                        "keywords": "",
                        "description": ""
                    },
                    "shortName": "grill tool",
                    "attributes": {},
                    "serialized": false,
                    "description": "",
                    "inventoried": false,
                    "idVerification": false,
                    "containsAlcohol": false,
                    "customerRewards": true,
                    "productHierarchy": {
                        "name": "Grilling Tools"
                    },
                    "shortDescription": "",
                    "containsHazardousMaterial": false
                },
                "variant": {
                    "tags": [],
                    "matrix": {},
                    "refKey": "1439c382e568685dd32624301215b210",
                    "baseUOM": "ea",
                    "updated": 1452204451000,
                    "usesUom": true,
                    "attributes": {},
                    "defaultPurchaseUOM": "ea"
                },
                "sku": {
                    "uom": {
                        "name": "Case",
                        "abbreviation": "ca"
                    },
                    "code": "GRILL_TOOL_CASE",
                    "tags": [],
                    "lookups": {},
                    "uomBase": false,
                    "updated": 1452204927000,
                    "sellable": false,
                    "settings": {
                        "noLabelNeeded": false,
                        "promptPriceEntryWhenAddToOrder": false,
                        "promptQuantityEntryWhenAddToOrder": false
                    },
                    "attributes": {},
                    "dimensions": {
                        "depth": {
                            "units": "inches",
                            "value": "0"
                        },
                        "width": {
                            "units": "inches",
                            "value": "0"
                        },
                        "height": {
                            "units": "inches",
                            "value": "0"
                        },
                        "volume": {
                            "units": "fluid ounces",
                            "value": "0"
                        },
                        "weight": {
                            "units": "pounds",
                            "value": "0"
                        },
                        "netWeight": {
                            "units": "pounds",
                            "value": "0"
                        }
                    },
                    "purchasable": true,
                    "uomBaseUnits": 12,
                    "variantRefKey": "1439c382e568685dd32624301215b210"
                },
                "catalogs": {},
                "categories": {},
                "pricing": {
                    "defaults": {
                        "EUR": "012976626be18e897193be7a1f200ca2",
                        "USD": "8fb4554513934bc459807f086bb41ee6"
                    },
                    "priceBooks": {
                        "012976626be18e897193be7a1f200ca2": {
                            "msrp": 0,
                            "name": "Default Pricing - EUR",
                            "fixed": false,
                            "floor": 0,
                            "regular": 0,
                            "currency": "EUR",
                            "includesTax": true,
                            "systemDefault": true,
                            "priceBookRefKey": "012976626be18e897193be7a1f200ca2"
                        },
                        "8fb4554513934bc459807f086bb41ee6": {
                            "msrp": 0,
                            "name": "Default Pricing - USD",
                            "fixed": false,
                            "floor": 0,
                            "regular": 0,
                            "currency": "USD",
                            "includesTax": false,
                            "systemDefault": true,
                            "priceBookRefKey": "8fb4554513934bc459807f086bb41ee6"
                        }
                    }
                },
                "updated": 1455108406000,
                "archived": false,
                "inventory": {
                    "available": 0,
                    "reserved": 0,
                    "onOrder": 0,
                    "committed": 0,
                    "unavailable": 0
                }
            },
            {
                "id": "a1b03480-cf24-11e5-8b5d-d76d7fe5a23b",
                "refName": "a1b03481-cf24-11e5-8b5d-d76d7fe5a23b",
                "refKey": "5890c8fafb113f73b7be5316f6376c3e",
                "dataDomains": [],
                "sequential": 17,
                "product": {
                    "name": "demo product long title",
                    "tags": [
                        {
                            "text": "demo"
                        },
                        {
                            "text": "product"
                        }
                    ],
                    "type": "product",
                    "brand": {
                        "name": "All-Clad",
                        "refKey": "2e2fd63e230dc5de7f3eba9a15fe2dca"
                    },
                    "media": [],
                    "origin": "USA",
                    "refKey": "1d20dd21dc27e31caf8b29709b1e1bc4",
                    "subtype": "single",
                    "taxCode": {
                        "name": "FOOD_GEN",
                        "refKey": "8a47e0d972d632b791744b77f5150854"
                    },
                    "updated": 1452122604000,
                    "metaTags": {
                        "title": "",
                        "keywords": "",
                        "description": ""
                    },
                    "shortName": "demo products",
                    "attributes": {},
                    "serialized": false,
                    "description": "",
                    "inventoried": false,
                    "idVerification": false,
                    "containsAlcohol": false,
                    "customerRewards": true,
                    "productHierarchy": {
                        "name": "Saute Pans"
                    },
                    "shortDescription": "",
                    "containsHazardousMaterial": false
                },
                "variant": {
                    "tags": [],
                    "matrix": {},
                    "refKey": "e08cf2f666ddffb1b76e4e36a536bff3",
                    "baseUOM": "ea",
                    "updated": 1452122604000,
                    "usesUom": true,
                    "attributes": {},
                    "defaultPurchaseUOM": "ea"
                },
                "sku": {
                    "uom": {
                        "name": "Case",
                        "abbreviation": "ca"
                    },
                    "code": "DEMO_CASE",
                    "tags": [],
                    "lookups": {},
                    "uomBase": false,
                    "updated": 1452122789000,
                    "sellable": false,
                    "settings": {
                        "noLabelNeeded": false,
                        "promptPriceEntryWhenAddToOrder": false,
                        "promptQuantityEntryWhenAddToOrder": false
                    },
                    "attributes": {},
                    "dimensions": {
                        "depth": {
                            "units": "inches",
                            "value": "0"
                        },
                        "width": {
                            "units": "inches",
                            "value": "0"
                        },
                        "height": {
                            "units": "inches",
                            "value": "0"
                        },
                        "volume": {
                            "units": "fluid ounces",
                            "value": "0"
                        },
                        "weight": {
                            "units": "pounds",
                            "value": "0"
                        },
                        "netWeight": {
                            "units": "pounds",
                            "value": "0"
                        }
                    },
                    "purchasable": true,
                    "uomBaseUnits": 6,
                    "variantRefKey": "e08cf2f666ddffb1b76e4e36a536bff3"
                },
                "catalogs": {},
                "categories": {},
                "pricing": {
                    "defaults": {
                        "EUR": "012976626be18e897193be7a1f200ca2",
                        "USD": "8fb4554513934bc459807f086bb41ee6"
                    },
                    "priceBooks": {
                        "012976626be18e897193be7a1f200ca2": {
                            "msrp": 0,
                            "name": "Default Pricing - EUR",
                            "fixed": false,
                            "floor": 0,
                            "regular": 0,
                            "currency": "EUR",
                            "includesTax": true,
                            "systemDefault": true,
                            "priceBookRefKey": "012976626be18e897193be7a1f200ca2"
                        },
                        "8fb4554513934bc459807f086bb41ee6": {
                            "msrp": 75,
                            "name": "Default Pricing - USD",
                            "fixed": false,
                            "floor": 0,
                            "regular": 0,
                            "currency": "USD",
                            "includesTax": false,
                            "systemDefault": true,
                            "priceBookRefKey": "8fb4554513934bc459807f086bb41ee6"
                        }
                    }
                },
                "updated": 1455108405000,
                "archived": false,
                "inventory": {
                    "available": 0,
                    "reserved": 0,
                    "onOrder": 0,
                    "committed": 0,
                    "unavailable": 0
                }
            },
            {
                "id": "a112e310-cf24-11e5-8b5d-d76d7fe5a23b",
                "refName": "a112e311-cf24-11e5-8b5d-d76d7fe5a23b",
                "refKey": "a69afd6ca7d2c56310715afdce3cec6e",
                "dataDomains": [],
                "sequential": 15,
                "product": {
                    "name": "demo product long title",
                    "tags": [
                        {
                            "text": "demo"
                        },
                        {
                            "text": "product"
                        }
                    ],
                    "type": "product",
                    "brand": {
                        "name": "All-Clad",
                        "refKey": "2e2fd63e230dc5de7f3eba9a15fe2dca"
                    },
                    "media": [],
                    "origin": "USA",
                    "refKey": "1d20dd21dc27e31caf8b29709b1e1bc4",
                    "subtype": "single",
                    "taxCode": {
                        "name": "FOOD_GEN",
                        "refKey": "8a47e0d972d632b791744b77f5150854"
                    },
                    "updated": 1452122604000,
                    "metaTags": {
                        "title": "",
                        "keywords": "",
                        "description": ""
                    },
                    "shortName": "demo products",
                    "attributes": {},
                    "serialized": false,
                    "description": "",
                    "inventoried": false,
                    "idVerification": false,
                    "containsAlcohol": false,
                    "customerRewards": true,
                    "productHierarchy": {
                        "name": "Saute Pans"
                    },
                    "shortDescription": "",
                    "containsHazardousMaterial": false
                },
                "variant": {
                    "tags": [],
                    "matrix": {},
                    "refKey": "e08cf2f666ddffb1b76e4e36a536bff3",
                    "baseUOM": "ea",
                    "updated": 1452122604000,
                    "usesUom": true,
                    "attributes": {},
                    "defaultPurchaseUOM": "ea"
                },
                "sku": {
                    "uom": {
                        "name": "Each",
                        "abbreviation": "ea"
                    },
                    "code": "DEMO_PRODUCT",
                    "tags": [],
                    "lookups": {},
                    "uomBase": true,
                    "updated": 1452122708000,
                    "sellable": true,
                    "settings": {
                        "noLabelNeeded": false,
                        "promptPriceEntryWhenAddToOrder": false,
                        "promptQuantityEntryWhenAddToOrder": false
                    },
                    "attributes": {},
                    "dimensions": {
                        "depth": {
                            "units": "inches",
                            "value": "0"
                        },
                        "width": {
                            "units": "inches",
                            "value": "0"
                        },
                        "height": {
                            "units": "inches",
                            "value": "0"
                        },
                        "volume": {
                            "units": "fluid ounces",
                            "value": "0"
                        },
                        "weight": {
                            "units": "pounds",
                            "value": "0"
                        },
                        "netWeight": {
                            "units": "pounds",
                            "value": "0"
                        }
                    },
                    "purchasable": false,
                    "uomBaseUnits": 1,
                    "variantRefKey": "e08cf2f666ddffb1b76e4e36a536bff3"
                },
                "catalogs": {
                    "015bc55b01e32eecac0b2500229cb92a": {
                        "name": "Ecommerce",
                        "refKey": "015bc55b01e32eecac0b2500229cb92a",
                        "priceBook": "79cc841936a65cb393f7c07bad2473f8",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "7ad12efa0d503b104f337bcea070d03b": {
                        "name": "Retail - San Francisco",
                        "refKey": "7ad12efa0d503b104f337bcea070d03b",
                        "priceBook": "413c54c7eeaae2aa60d0d8fc6a45f656",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "bb4644a89b3c9d0ab9300b8d2a14cbd5": {
                        "name": "Retail - Spain",
                        "refKey": "bb4644a89b3c9d0ab9300b8d2a14cbd5",
                        "priceBook": "336dda8d3be833d74bba07e0878b2c7e",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "d52aefadd57e1070160c10795fe29533": {
                        "name": "Retail",
                        "refKey": "d52aefadd57e1070160c10795fe29533",
                        "priceBook": "8fb4554513934bc459807f086bb41ee6",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "db5549e9ab9cad7eee9ddb36406c8da3": {
                        "name": "Retail - Miami",
                        "refKey": "db5549e9ab9cad7eee9ddb36406c8da3",
                        "priceBook": "8fb4554513934bc459807f086bb41ee6",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    }
                },
                "categories": {
                    "297a5f49f7b95d182b42a42961e117ff": {
                        "name": "Kitchen Tools & Prep",
                        "path": "Cooking > Kitchen Tools & Prep",
                        "refKey": "297a5f49f7b95d182b42a42961e117ff",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "4e71fb7c0a12a7e4b41e71db1655a057": {
                        "name": "Cooking",
                        "path": "Cooking",
                        "refKey": "4e71fb7c0a12a7e4b41e71db1655a057",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    }
                },
                "pricing": {
                    "defaults": {
                        "EUR": "012976626be18e897193be7a1f200ca2",
                        "USD": "8fb4554513934bc459807f086bb41ee6"
                    },
                    "priceBooks": {
                        "012976626be18e897193be7a1f200ca2": {
                            "msrp": 0,
                            "name": "Default Pricing - EUR",
                            "fixed": false,
                            "floor": 0,
                            "regular": 0,
                            "currency": "EUR",
                            "includesTax": true,
                            "systemDefault": true,
                            "priceBookRefKey": "012976626be18e897193be7a1f200ca2"
                        },
                        "8fb4554513934bc459807f086bb41ee6": {
                            "msrp": 15,
                            "name": "Default Pricing - USD",
                            "fixed": false,
                            "floor": 0,
                            "regular": 10,
                            "currency": "USD",
                            "includesTax": false,
                            "systemDefault": true,
                            "priceBookRefKey": "8fb4554513934bc459807f086bb41ee6"
                        }
                    }
                },
                "updated": 1455108407000,
                "archived": false,
                "inventory": {
                    "available": 0,
                    "reserved": 0,
                    "onOrder": 0,
                    "committed": 0,
                    "unavailable": 0
                }
            },
            {
                "id": "8f91afd0-a504-11e5-b6b0-0b1263e0576c",
                "refName": "8f91afd1-a504-11e5-b6b0-0b1263e0576c",
                "refKey": "8cdaf92c187e31a8e3ccf56e0734a211",
                "dataDomains": [],
                "sequential": 10,
                "product": {
                    "name": "Bob Kramer Meiji 10\" Bread Knife by Zwilling J.A. Henckels",
                    "tags": [
                        {
                            "text": "bread-knives"
                        },
                        {
                            "text": "cutting"
                        },
                        {
                            "text": "Bob-Kramer"
                        }
                    ],
                    "type": "product",
                    "brand": {
                        "name": "Kramer",
                        "refKey": "18fd1c3c21c37ca77a5ad03e2ec14e9b"
                    },
                    "media": [
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447855998/82bb011a12391620d8a63de86f676d1d.jpg",
                            "tags": [],
                            "bytes": 188100,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "82bb011a12391620d8a63de86f676d1d",
                            "default": true,
                            "fileName": "zoom_variation_Default_view_1_1275x1275 (1)",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447855998/82bb011a12391620d8a63de86f676d1d.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447855998/12753f6347f350dd1684cebea4cf5e0f.jpg",
                            "tags": [],
                            "bytes": 181225,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "12753f6347f350dd1684cebea4cf5e0f",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_5_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447855998/12753f6347f350dd1684cebea4cf5e0f.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447855998/1a9e73a1fd146ea6f99dd141837852cb.jpg",
                            "tags": [],
                            "bytes": 263623,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "1a9e73a1fd146ea6f99dd141837852cb",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_6_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447855998/1a9e73a1fd146ea6f99dd141837852cb.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447855999/f2e22a09a8c13013b796f0011fe3e9bd.jpg",
                            "tags": [],
                            "bytes": 60101,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "f2e22a09a8c13013b796f0011fe3e9bd",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_2_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447855999/f2e22a09a8c13013b796f0011fe3e9bd.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447855998/b214a2e595431d73889b7717f6a4e9e4.jpg",
                            "tags": [],
                            "bytes": 313126,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "b214a2e595431d73889b7717f6a4e9e4",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_8_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447855998/b214a2e595431d73889b7717f6a4e9e4.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447855998/f416d5cb16ec20ba5a3d392da76292fe.jpg",
                            "tags": [],
                            "bytes": 148952,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "f416d5cb16ec20ba5a3d392da76292fe",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_7_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447855998/f416d5cb16ec20ba5a3d392da76292fe.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447855998/cd5dba20d0ea4f315c3e3e85bc123c21.jpg",
                            "tags": [],
                            "bytes": 291226,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "cd5dba20d0ea4f315c3e3e85bc123c21",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_4_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447855998/cd5dba20d0ea4f315c3e3e85bc123c21.jpg"
                        }
                    ],
                    "origin": "USA",
                    "refKey": "fe5f6912e40053f32befc76c392efa91",
                    "subtype": "single",
                    "taxCode": {
                        "name": "GEN_TAX",
                        "refKey": "5f3ce899dc0bc95ef7b6cf1c1dd12e17"
                    },
                    "updated": 1447874326000,
                    "metaTags": {
                        "title": "Bob Kramer Meiji 10\" Bread Knife by Zwilling J.A. Henckels",
                        "keywords": "knives, Bob Kramer Meiji",
                        "description": "Bob Kramer Meiji 10\" Bread Knife by Zwilling J.A. Henckels"
                    },
                    "shortName": "Meiji 10\" Bread Knife",
                    "attributes": {},
                    "serialized": false,
                    "description": "Combine Japanese aesthetics, the ease and familiarity of Western-style blades and legendary bladesmith Bob Kramer, and the result is the revolutionary Meiji collection. A true fusion of Eastern and Western knifemaking philosophies, Bob Kramer Meiji offers the impeccable style of Japanese knives paired with the performance and accessibility of Western blade shapes optimized for kitchen use. Bob Kramer Meiji is only available at Sur La Table. \n\nPerfect for slicing everything from crusty baguettes to moist, airy brioche, this bread features an extra-long, serrated blade that won’t crush delicate loaves. Razor-sharp right out of the box, it’s a versatile and eye-catching addition to any kitchen.",
                    "inventoried": false,
                    "idVerification": false,
                    "containsAlcohol": false,
                    "customerRewards": true,
                    "productHierarchy": {
                        "name": "Knives & Cutting Boards"
                    },
                    "shortDescription": "Perfect for slicing everything from crusty baguettes to moist, airy brioche, this bread features an extra-long, serrated blade that won’t crush delicate loaves.",
                    "containsHazardousMaterial": false
                },
                "variant": {
                    "tags": [],
                    "matrix": {},
                    "refKey": "8f1f51e511c2c9d3a7e27ee19db6c00e",
                    "baseUOM": "ea",
                    "updated": 1448071840000,
                    "usesUom": false,
                    "attributes": {},
                    "defaultPurchaseUOM": "ea"
                },
                "sku": {
                    "uom": {
                        "name": "Each",
                        "abbreviation": "ea"
                    },
                    "code": "2138865",
                    "tags": [],
                    "lookups": {},
                    "uomBase": true,
                    "updated": 1447873302000,
                    "sellable": true,
                    "settings": {
                        "noLabelNeeded": false,
                        "promptPriceEntryWhenAddToOrder": false,
                        "promptQuantityEntryWhenAddToOrder": false
                    },
                    "attributes": {},
                    "dimensions": {
                        "depth": {
                            "units": "inches",
                            "value": "12"
                        },
                        "width": {
                            "units": "inches",
                            "value": "3"
                        },
                        "height": {
                            "units": "inches",
                            "value": "3"
                        },
                        "volume": {
                            "units": "fluid ounces",
                            "value": "0"
                        },
                        "weight": {
                            "units": "pounds",
                            "value": "2"
                        },
                        "netWeight": {
                            "units": "pounds",
                            "value": "1"
                        }
                    },
                    "purchasable": true,
                    "uomBaseUnits": 1,
                    "variantRefKey": "8f1f51e511c2c9d3a7e27ee19db6c00e"
                },
                "catalogs": {},
                "categories": {},
                "pricing": {
                    "defaults": {
                        "EUR": "012976626be18e897193be7a1f200ca2",
                        "USD": "8fb4554513934bc459807f086bb41ee6"
                    },
                    "priceBooks": {
                        "012976626be18e897193be7a1f200ca2": {
                            "msrp": 440,
                            "name": "Default Pricing - EUR",
                            "fixed": false,
                            "floor": 0,
                            "regular": 349.95,
                            "currency": "EUR",
                            "includesTax": true,
                            "systemDefault": true,
                            "priceBookRefKey": "012976626be18e897193be7a1f200ca2"
                        },
                        "8fb4554513934bc459807f086bb41ee6": {
                            "msrp": 440,
                            "name": "Default Pricing - USD",
                            "fixed": false,
                            "floor": 0,
                            "regular": 349.95,
                            "currency": "USD",
                            "includesTax": false,
                            "systemDefault": true,
                            "priceBookRefKey": "8fb4554513934bc459807f086bb41ee6"
                        }
                    }
                },
                "updated": 1455108405000,
                "archived": false,
                "inventory": {
                    "available": 0,
                    "reserved": 0,
                    "onOrder": 0,
                    "committed": 0,
                    "unavailable": 0
                }
            },
            {
                "id": "8f445320-a504-11e5-b6b0-0b1263e0576c",
                "refName": "8f447a30-a504-11e5-b6b0-0b1263e0576c",
                "refKey": "df496cc151f1ca6532e1560d500190d8",
                "dataDomains": [],
                "sequential": 9,
                "product": {
                    "name": "All-Clad® D5 Brushed Stainless Steel 10-Piece Set",
                    "tags": [
                        {
                            "text": "cooking"
                        },
                        {
                            "text": "cookware"
                        },
                        {
                            "text": "cookware-sets"
                        }
                    ],
                    "type": "product",
                    "brand": {
                        "name": "All-Clad",
                        "refKey": "2e2fd63e230dc5de7f3eba9a15fe2dca"
                    },
                    "media": [
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447851930/ec56dc89303d5aeeea231e382a929ecc.jpg",
                            "tags": [],
                            "bytes": 149298,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "ec56dc89303d5aeeea231e382a929ecc",
                            "default": true,
                            "fileName": "zoom_variation_Default_view_1_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447851930/ec56dc89303d5aeeea231e382a929ecc.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447851920/fc1042ac57736416ed255dc4536c4d06.jpg",
                            "tags": [],
                            "bytes": 184961,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "fc1042ac57736416ed255dc4536c4d06",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_4_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447851920/fc1042ac57736416ed255dc4536c4d06.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447851925/8265bc636144f7ab8e1589986275b786.jpg",
                            "tags": [],
                            "bytes": 112164,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "8265bc636144f7ab8e1589986275b786",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_2_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447851925/8265bc636144f7ab8e1589986275b786.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447851905/1773ff6affa9c2ce8dd2ee3a4e01b23d.jpg",
                            "tags": [],
                            "bytes": 118658,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "1773ff6affa9c2ce8dd2ee3a4e01b23d",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_5_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447851905/1773ff6affa9c2ce8dd2ee3a4e01b23d.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447851983/3056d4e6bd584c6baa026b9826625d03.jpg",
                            "tags": [],
                            "bytes": 113803,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "3056d4e6bd584c6baa026b9826625d03",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_6_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447851983/3056d4e6bd584c6baa026b9826625d03.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447851986/0c2a3c2640a5fe95972452c11fc595b8.jpg",
                            "tags": [],
                            "bytes": 159499,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "0c2a3c2640a5fe95972452c11fc595b8",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_7_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447851986/0c2a3c2640a5fe95972452c11fc595b8.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447851990/ac8c1db4329037eac58a265e29df2a29.jpg",
                            "tags": [],
                            "bytes": 122093,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "ac8c1db4329037eac58a265e29df2a29",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_8_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447851990/ac8c1db4329037eac58a265e29df2a29.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447851994/59d6806a4adff7eb817ea8f9424809e9.jpg",
                            "tags": [],
                            "bytes": 137586,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "59d6806a4adff7eb817ea8f9424809e9",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_9_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447851994/59d6806a4adff7eb817ea8f9424809e9.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447852044/fd7b301afcb2adb44c854791275570a7.jpg",
                            "tags": [],
                            "bytes": 68084,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "fd7b301afcb2adb44c854791275570a7",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_11_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447852044/fd7b301afcb2adb44c854791275570a7.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447852048/b66f069d9234fa103439e50b5df37313.jpg",
                            "tags": [],
                            "bytes": 85013,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "b66f069d9234fa103439e50b5df37313",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_12_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447852048/b66f069d9234fa103439e50b5df37313.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447852051/7886f41acfe39ed45ae67c8ff9513ddf.jpg",
                            "tags": [],
                            "bytes": 76438,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "7886f41acfe39ed45ae67c8ff9513ddf",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_13_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447852051/7886f41acfe39ed45ae67c8ff9513ddf.jpg"
                        },
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1447852055/9225a4bc37f8fd2741e85032fdd9b06e.jpg",
                            "tags": [],
                            "bytes": 128900,
                            "width": 1275,
                            "format": "jpg",
                            "height": 1275,
                            "refKey": "9225a4bc37f8fd2741e85032fdd9b06e",
                            "default": false,
                            "fileName": "zoom_variation_Default_view_14_1275x1275",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1447852055/9225a4bc37f8fd2741e85032fdd9b06e.jpg"
                        }
                    ],
                    "origin": "USA",
                    "refKey": "edcc7305b71226e5477c693488524680",
                    "subtype": "single",
                    "taxCode": {
                        "name": "GEN_TAX",
                        "refKey": "5f3ce899dc0bc95ef7b6cf1c1dd12e17"
                    },
                    "updated": 1451947597000,
                    "metaTags": {
                        "title": "All-Clad® D5 Brushed Stainless Steel 10-Piece Set",
                        "keywords": "cookware, cookware set, all-clad, brushed",
                        "description": "Perfect for everything from frying eggs to braising a roast or whipping up a delicious vegetable purée, this versatile cookware set is a welcome addition to any kitc..."
                    },
                    "shortName": "Stainless Steel 10-Piece Set",
                    "attributes": {},
                    "serialized": false,
                    "description": "Perfect for everything from frying eggs to braising a roast or whipping up a delicious vegetable purée, this versatile cookware set is a welcome addition to any kitchen. A revolution in cookware technology, d5 cookware is the most advanced collection to bear the legendary All-Clad name. \n\nFeaturing five-layer construction with a patented stainless-steel core for unmatched heat stability and exceptional heating performance, All-Clad d5 virtually eliminates hot spots for precise control while cooking. All-Clad d5 is optimized for induction cooking and features chef-friendly features such as drip-free rims and ergonomic handles that offer precise control. \n\nDeveloped over years of extensive testing and refinement, d5 cookware delivers the results that professional chefs demand, yet is forgiving enough for even novice cooks.",
                    "inventoried": false,
                    "idVerification": false,
                    "containsAlcohol": false,
                    "customerRewards": true,
                    "productHierarchy": {
                        "name": "Cookware Sets"
                    },
                    "shortDescription": "This 10-piece D5 Brushed Set provides the pieces you need for most day-to-day cooking tasks. Ideal as a wedding gift or as a high-performance addition to kitchens, this collection is constructed for a lifetime of use and culinary performance.",
                    "containsHazardousMaterial": false
                },
                "variant": {
                    "tags": [],
                    "matrix": {},
                    "refKey": "b91836352211df86aca088acac0843fc",
                    "baseUOM": "ea",
                    "updated": 1453513806000,
                    "usesUom": true,
                    "attributes": {},
                    "defaultPurchaseUOM": "ea"
                },
                "sku": {
                    "uom": {
                        "name": "Each",
                        "abbreviation": "ea"
                    },
                    "code": "1526268",
                    "tags": [],
                    "lookups": {},
                    "uomBase": true,
                    "updated": 1447869683000,
                    "sellable": true,
                    "settings": {
                        "noLabelNeeded": false,
                        "promptPriceEntryWhenAddToOrder": false,
                        "promptQuantityEntryWhenAddToOrder": false
                    },
                    "attributes": {},
                    "dimensions": {
                        "depth": {
                            "units": "inches",
                            "value": "24"
                        },
                        "width": {
                            "units": "inches",
                            "value": "24"
                        },
                        "height": {
                            "units": "inches",
                            "value": "12"
                        },
                        "volume": {
                            "units": "fluid ounces",
                            "value": "0"
                        },
                        "weight": {
                            "units": "pounds",
                            "value": "50"
                        },
                        "netWeight": {
                            "units": "pounds",
                            "value": "35"
                        }
                    },
                    "purchasable": true,
                    "uomBaseUnits": 1,
                    "variantRefKey": "b91836352211df86aca088acac0843fc"
                },
                "catalogs": {
                    "015bc55b01e32eecac0b2500229cb92a": {
                        "name": "Ecommerce",
                        "refKey": "015bc55b01e32eecac0b2500229cb92a",
                        "priceBook": "79cc841936a65cb393f7c07bad2473f8",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "7ad12efa0d503b104f337bcea070d03b": {
                        "name": "Retail - San Francisco",
                        "refKey": "7ad12efa0d503b104f337bcea070d03b",
                        "priceBook": "413c54c7eeaae2aa60d0d8fc6a45f656",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "bb4644a89b3c9d0ab9300b8d2a14cbd5": {
                        "name": "Retail - Spain",
                        "refKey": "bb4644a89b3c9d0ab9300b8d2a14cbd5",
                        "priceBook": "336dda8d3be833d74bba07e0878b2c7e",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "d52aefadd57e1070160c10795fe29533": {
                        "name": "Retail",
                        "refKey": "d52aefadd57e1070160c10795fe29533",
                        "priceBook": "8fb4554513934bc459807f086bb41ee6",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "db5549e9ab9cad7eee9ddb36406c8da3": {
                        "name": "Retail - Miami",
                        "refKey": "db5549e9ab9cad7eee9ddb36406c8da3",
                        "priceBook": "8fb4554513934bc459807f086bb41ee6",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    }
                },
                "categories": {
                    "05307411a3528c7f65d7960dce6a34e6": {
                        "name": "Coffee",
                        "path": "Coffee & Tea > Coffee",
                        "refKey": "05307411a3528c7f65d7960dce6a34e6",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "182ccb9c6be5e1081486b859777637a4": {
                        "name": "Small Appliances",
                        "path": "Cooking > Small Appliances",
                        "refKey": "182ccb9c6be5e1081486b859777637a4",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "43e490fb95448b19994425296c20b4d8": {
                        "name": "Food",
                        "path": "Cooking > Food",
                        "refKey": "43e490fb95448b19994425296c20b4d8",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "469b4cd0332b8fc5b5f41c801860b8f8": {
                        "name": "Jam, Honey & Syrup",
                        "path": "Food > Jam, Honey & Syrup",
                        "refKey": "469b4cd0332b8fc5b5f41c801860b8f8",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "4e71fb7c0a12a7e4b41e71db1655a057": {
                        "name": "Cooking",
                        "path": "Cooking",
                        "refKey": "4e71fb7c0a12a7e4b41e71db1655a057",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "649bedabc16933f5d434e722d18a61d2": {
                        "name": "Coffee Ingredients",
                        "path": "Coffee & Tea > Coffee > Coffee Ingredients",
                        "refKey": "649bedabc16933f5d434e722d18a61d2",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "7afac02985501815e97ee59c728ca7b5": {
                        "name": "Coffee & Tea",
                        "path": "Coffee & Tea",
                        "refKey": "7afac02985501815e97ee59c728ca7b5",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "b4e7d242302dc4a4d5d2e6c91db8f400": {
                        "name": "Cookware",
                        "path": "Cooking > Cookware",
                        "refKey": "b4e7d242302dc4a4d5d2e6c91db8f400",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "ef2ee4e45aab8baae1acdeb49dc9ead9": {
                        "name": "Food",
                        "path": "Food",
                        "refKey": "ef2ee4e45aab8baae1acdeb49dc9ead9",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "f7d161f82f76636778590e29c1dc232d": {
                        "name": "Coffee Beans & Pods",
                        "path": "Coffee & Tea > Coffee > Coffee Beans & Pods",
                        "refKey": "f7d161f82f76636778590e29c1dc232d",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "f7f86b46b993fda96b485b3040d5149f": {
                        "name": "Knives & Cutting Boards",
                        "path": "Cooking > Knives & Cutting Boards",
                        "refKey": "f7f86b46b993fda96b485b3040d5149f",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    }
                },
                "pricing": {
                    "defaults": {
                        "EUR": "012976626be18e897193be7a1f200ca2",
                        "USD": "8fb4554513934bc459807f086bb41ee6"
                    },
                    "priceBooks": {
                        "012976626be18e897193be7a1f200ca2": {
                            "msrp": 1425,
                            "name": "Default Pricing - EUR",
                            "fixed": false,
                            "floor": 0,
                            "regular": 749.96,
                            "currency": "EUR",
                            "includesTax": true,
                            "systemDefault": true,
                            "priceBookRefKey": "012976626be18e897193be7a1f200ca2"
                        },
                        "8fb4554513934bc459807f086bb41ee6": {
                            "msrp": 1425,
                            "name": "Default Pricing - USD",
                            "fixed": false,
                            "floor": 0,
                            "regular": 799.96,
                            "currency": "USD",
                            "includesTax": false,
                            "systemDefault": true,
                            "priceBookRefKey": "8fb4554513934bc459807f086bb41ee6"
                        }
                    }
                },
                "updated": 1455108407000,
                "archived": false,
                "inventory": {
                    "available": 35,
                    "reserved": 0,
                    "onOrder": 0,
                    "committed": 0,
                    "unavailable": 0
                }
            },
            {
                "id": "a09e0130-cf24-11e5-8b5d-d76d7fe5a23b",
                "refName": "a09e0131-cf24-11e5-8b5d-d76d7fe5a23b",
                "refKey": "5fa266f36f2a6f8fffc634e4b6764789",
                "dataDomains": [],
                "sequential": 12,
                "product": {
                    "name": "All-Clad Unison Nonstick 3 Qt. Sear Covered Saute Pan",
                    "tags": [
                        {
                            "text": "Cookware"
                        }
                    ],
                    "type": "product",
                    "brand": {
                        "name": "All-Clad",
                        "refKey": "2e2fd63e230dc5de7f3eba9a15fe2dca"
                    },
                    "media": [
                        {
                            "url": "http://res.cloudinary.com/futch/image/upload/v1452104053/10bf7611392274f42078dc58ac3bc4d9.jpg",
                            "tags": [],
                            "bytes": 163055,
                            "width": 1320,
                            "format": "jpg",
                            "height": 1616,
                            "refKey": "10bf7611392274f42078dc58ac3bc4d9",
                            "default": true,
                            "fileName": "534002_fpx",
                            "metadata": {
                                "title": "",
                                "public": false,
                                "altText": "",
                                "caption": "",
                                "description": ""
                            },
                            "secureUrl": "https://res.cloudinary.com/futch/image/upload/v1452104053/10bf7611392274f42078dc58ac3bc4d9.jpg"
                        }
                    ],
                    "origin": "",
                    "refKey": "7a299e6c21d90cadbd4de760fa7bf7a0",
                    "subtype": "single",
                    "taxCode": {
                        "name": "GEN_TAX",
                        "refKey": "5f3ce899dc0bc95ef7b6cf1c1dd12e17"
                    },
                    "updated": 1451527809000,
                    "metaTags": {
                        "title": "",
                        "keywords": "",
                        "description": ""
                    },
                    "shortName": "All-Clad 3 Qt.  Saute Pan",
                    "attributes": {},
                    "serialized": false,
                    "description": "",
                    "inventoried": false,
                    "idVerification": false,
                    "containsAlcohol": false,
                    "customerRewards": true,
                    "productHierarchy": {
                        "name": "Saute Pans"
                    },
                    "shortDescription": "For flavor that goes on forever, Calphalon's exclusive Sear sauté pan features a specially textured nonstick surface that helps seal in the essence of every recipe. The end result? Meat, fish, poultry and vegetables that taste anything but ordinary.",
                    "containsHazardousMaterial": false
                },
                "variant": {
                    "tags": [],
                    "matrix": {},
                    "refKey": "f0cf2152432652ec3f5ba6b1a996cfba",
                    "baseUOM": "ea",
                    "updated": 1451527809000,
                    "usesUom": false,
                    "attributes": {},
                    "defaultPurchaseUOM": "ea"
                },
                "sku": {
                    "uom": {
                        "name": "Each",
                        "abbreviation": "ea"
                    },
                    "code": "11445566",
                    "tags": [],
                    "lookups": {},
                    "uomBase": true,
                    "updated": 1451527809000,
                    "sellable": true,
                    "settings": {
                        "noLabelNeeded": false,
                        "promptPriceEntryWhenAddToOrder": false,
                        "promptQuantityEntryWhenAddToOrder": false
                    },
                    "attributes": {},
                    "dimensions": {
                        "depth": {
                            "units": "inches",
                            "value": "5"
                        },
                        "width": {
                            "units": "inches",
                            "value": "5"
                        },
                        "height": {
                            "units": "inches",
                            "value": "0"
                        },
                        "volume": {
                            "units": "fluid ounces",
                            "value": "0"
                        },
                        "weight": {
                            "units": "pounds",
                            "value": "5"
                        },
                        "netWeight": {
                            "units": "pounds",
                            "value": "0"
                        }
                    },
                    "purchasable": true,
                    "uomBaseUnits": 1,
                    "variantRefKey": "f0cf2152432652ec3f5ba6b1a996cfba"
                },
                "catalogs": {
                    "015bc55b01e32eecac0b2500229cb92a": {
                        "name": "Ecommerce",
                        "refKey": "015bc55b01e32eecac0b2500229cb92a",
                        "priceBook": "79cc841936a65cb393f7c07bad2473f8",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "7ad12efa0d503b104f337bcea070d03b": {
                        "name": "Retail - San Francisco",
                        "refKey": "7ad12efa0d503b104f337bcea070d03b",
                        "priceBook": "413c54c7eeaae2aa60d0d8fc6a45f656",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "bb4644a89b3c9d0ab9300b8d2a14cbd5": {
                        "name": "Retail - Spain",
                        "refKey": "bb4644a89b3c9d0ab9300b8d2a14cbd5",
                        "priceBook": "336dda8d3be833d74bba07e0878b2c7e",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "d52aefadd57e1070160c10795fe29533": {
                        "name": "Retail",
                        "refKey": "d52aefadd57e1070160c10795fe29533",
                        "priceBook": "8fb4554513934bc459807f086bb41ee6",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "db5549e9ab9cad7eee9ddb36406c8da3": {
                        "name": "Retail - Miami",
                        "refKey": "db5549e9ab9cad7eee9ddb36406c8da3",
                        "priceBook": "8fb4554513934bc459807f086bb41ee6",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    }
                },
                "categories": {
                    "4e71fb7c0a12a7e4b41e71db1655a057": {
                        "name": "Cooking",
                        "path": "Cooking",
                        "refKey": "4e71fb7c0a12a7e4b41e71db1655a057",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "b4e7d242302dc4a4d5d2e6c91db8f400": {
                        "name": "Cookware",
                        "path": "Cooking > Cookware",
                        "refKey": "b4e7d242302dc4a4d5d2e6c91db8f400",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    }
                },
                "pricing": {
                    "defaults": {
                        "EUR": "012976626be18e897193be7a1f200ca2",
                        "USD": "8fb4554513934bc459807f086bb41ee6"
                    },
                    "priceBooks": {
                        "012976626be18e897193be7a1f200ca2": {
                            "msrp": 129,
                            "name": "Default Pricing - EUR",
                            "fixed": false,
                            "floor": 0,
                            "regular": 89,
                            "currency": "EUR",
                            "includesTax": true,
                            "systemDefault": true,
                            "priceBookRefKey": "012976626be18e897193be7a1f200ca2"
                        },
                        "8fb4554513934bc459807f086bb41ee6": {
                            "msrp": 129,
                            "name": "Default Pricing - USD",
                            "fixed": false,
                            "floor": 0,
                            "regular": 89,
                            "currency": "USD",
                            "includesTax": false,
                            "systemDefault": true,
                            "priceBookRefKey": "8fb4554513934bc459807f086bb41ee6"
                        }
                    }
                },
                "updated": 1455108406000,
                "archived": false,
                "inventory": {
                    "available": 0,
                    "reserved": 0,
                    "onOrder": 0,
                    "committed": 0,
                    "unavailable": 0
                }
            },
            {
                "id": "a1d7b9b0-cf24-11e5-8b5d-d76d7fe5a23b",
                "refName": "a1d7b9b1-cf24-11e5-8b5d-d76d7fe5a23b",
                "refKey": "db6fb2e01ce74d24e53692b1ae8f5fef",
                "dataDomains": [],
                "sequential": 18,
                "product": {
                    "name": "Grill tool2",
                    "tags": [
                        {
                            "text": "grill-tool"
                        }
                    ],
                    "type": "product",
                    "brand": {
                        "name": "All-Clad",
                        "refKey": "2e2fd63e230dc5de7f3eba9a15fe2dca"
                    },
                    "media": [],
                    "origin": "USA",
                    "refKey": "315337bab5d29c05901bf2bdff9e0566",
                    "subtype": "single",
                    "taxCode": {
                        "name": "GEN_TAX",
                        "refKey": "5f3ce899dc0bc95ef7b6cf1c1dd12e17"
                    },
                    "updated": 1455055763000,
                    "metaTags": {
                        "title": "",
                        "keywords": "",
                        "description": ""
                    },
                    "shortName": "grill tool",
                    "attributes": {},
                    "serialized": false,
                    "description": "",
                    "inventoried": false,
                    "idVerification": false,
                    "containsAlcohol": false,
                    "customerRewards": true,
                    "productHierarchy": {
                        "name": "Grilling Tools"
                    },
                    "shortDescription": "",
                    "containsHazardousMaterial": false
                },
                "variant": {
                    "tags": [],
                    "matrix": {},
                    "refKey": "1439c382e568685dd32624301215b210",
                    "baseUOM": "ea",
                    "updated": 1452204451000,
                    "usesUom": true,
                    "attributes": {},
                    "defaultPurchaseUOM": "ea"
                },
                "sku": {
                    "uom": {
                        "name": "Each",
                        "abbreviation": "ea"
                    },
                    "code": "GRILL_TOOL",
                    "tags": [],
                    "lookups": {},
                    "uomBase": true,
                    "updated": 1452204451000,
                    "sellable": true,
                    "settings": {
                        "noLabelNeeded": false,
                        "promptPriceEntryWhenAddToOrder": false,
                        "promptQuantityEntryWhenAddToOrder": false
                    },
                    "attributes": {},
                    "dimensions": {
                        "depth": {
                            "units": "inches",
                            "value": "1"
                        },
                        "width": {
                            "units": "inches",
                            "value": "3"
                        },
                        "height": {
                            "units": "inches",
                            "value": "12"
                        },
                        "volume": {
                            "units": "fluid ounces",
                            "value": "0"
                        },
                        "weight": {
                            "units": "pounds",
                            "value": "1"
                        },
                        "netWeight": {
                            "units": "pounds",
                            "value": "0"
                        }
                    },
                    "purchasable": true,
                    "uomBaseUnits": 1,
                    "variantRefKey": "1439c382e568685dd32624301215b210"
                },
                "catalogs": {
                    "015bc55b01e32eecac0b2500229cb92a": {
                        "name": "Ecommerce",
                        "refKey": "015bc55b01e32eecac0b2500229cb92a",
                        "priceBook": "79cc841936a65cb393f7c07bad2473f8",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "7ad12efa0d503b104f337bcea070d03b": {
                        "name": "Retail - San Francisco",
                        "refKey": "7ad12efa0d503b104f337bcea070d03b",
                        "priceBook": "413c54c7eeaae2aa60d0d8fc6a45f656",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "bb4644a89b3c9d0ab9300b8d2a14cbd5": {
                        "name": "Retail - Spain",
                        "refKey": "bb4644a89b3c9d0ab9300b8d2a14cbd5",
                        "priceBook": "336dda8d3be833d74bba07e0878b2c7e",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "d52aefadd57e1070160c10795fe29533": {
                        "name": "Retail",
                        "refKey": "d52aefadd57e1070160c10795fe29533",
                        "priceBook": "8fb4554513934bc459807f086bb41ee6",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "db5549e9ab9cad7eee9ddb36406c8da3": {
                        "name": "Retail - Miami",
                        "refKey": "db5549e9ab9cad7eee9ddb36406c8da3",
                        "priceBook": "8fb4554513934bc459807f086bb41ee6",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    }
                },
                "categories": {
                    "4e71fb7c0a12a7e4b41e71db1655a057": {
                        "name": "Cooking",
                        "path": "Cooking",
                        "refKey": "4e71fb7c0a12a7e4b41e71db1655a057",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "67376824ded6b140f4a22f46e8b1c58e": {
                        "name": "Grilling",
                        "path": "Home > Grilling",
                        "refKey": "67376824ded6b140f4a22f46e8b1c58e",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "6bf9c258c7c355e4418701e76dad01e1": {
                        "name": "Home",
                        "path": "Home",
                        "refKey": "6bf9c258c7c355e4418701e76dad01e1",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "8a80a801c20ccf42647038a47fc3bc9b": {
                        "name": "Grilling",
                        "path": "Cooking > Grilling",
                        "refKey": "8a80a801c20ccf42647038a47fc3bc9b",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    }
                },
                "pricing": {
                    "defaults": {
                        "EUR": "012976626be18e897193be7a1f200ca2",
                        "USD": "8fb4554513934bc459807f086bb41ee6"
                    },
                    "priceBooks": {
                        "012976626be18e897193be7a1f200ca2": {
                            "msrp": 14,
                            "name": "Default Pricing - EUR",
                            "fixed": false,
                            "floor": 0,
                            "regular": 11,
                            "currency": "EUR",
                            "includesTax": true,
                            "systemDefault": true,
                            "priceBookRefKey": "012976626be18e897193be7a1f200ca2"
                        },
                        "8fb4554513934bc459807f086bb41ee6": {
                            "msrp": 15,
                            "name": "Default Pricing - USD",
                            "fixed": false,
                            "floor": 0,
                            "regular": 12,
                            "currency": "USD",
                            "includesTax": false,
                            "systemDefault": true,
                            "priceBookRefKey": "8fb4554513934bc459807f086bb41ee6"
                        }
                    }
                },
                "updated": 1455108407000,
                "archived": false,
                "inventory": {
                    "available": 0,
                    "reserved": 0,
                    "onOrder": 0,
                    "committed": 0,
                    "unavailable": 0
                }
            },
            {
                "id": "8fbe8c30-a504-11e5-b6b0-0b1263e0576c",
                "refName": "8fbe8c31-a504-11e5-b6b0-0b1263e0576c",
                "refKey": "9de146b6a62732918bce9ffbf57bdd17",
                "dataDomains": [],
                "sequential": 11,
                "product": {
                    "name": "Special Curved Butcher Knife",
                    "tags": [
                        {
                            "text": "butcher-knife"
                        }
                    ],
                    "type": "product",
                    "brand": {
                        "name": "All-Clad",
                        "refKey": "2e2fd63e230dc5de7f3eba9a15fe2dca"
                    },
                    "media": [],
                    "origin": "USA",
                    "refKey": "65738345a8d8ee7596a9fa4ce326a4c1",
                    "subtype": "single",
                    "taxCode": {
                        "name": "GEN_TAX",
                        "refKey": "5f3ce899dc0bc95ef7b6cf1c1dd12e17"
                    },
                    "updated": 1449275929000,
                    "metaTags": {
                        "title": "",
                        "keywords": "",
                        "description": ""
                    },
                    "shortName": "SC Butcher Knife",
                    "attributes": {},
                    "serialized": false,
                    "description": "",
                    "inventoried": false,
                    "idVerification": false,
                    "containsAlcohol": false,
                    "customerRewards": true,
                    "productHierarchy": {
                        "name": "Carving Knives"
                    },
                    "shortDescription": "",
                    "containsHazardousMaterial": false
                },
                "variant": {
                    "tags": [],
                    "matrix": {},
                    "refKey": "b8851921cd9a15cbcec275e194b7185d",
                    "baseUOM": "ea",
                    "updated": 1449275929000,
                    "usesUom": true,
                    "attributes": {},
                    "defaultPurchaseUOM": "ea"
                },
                "sku": {
                    "uom": {
                        "name": "Each",
                        "abbreviation": "ea"
                    },
                    "code": "SCBKN12345",
                    "tags": [],
                    "lookups": {},
                    "uomBase": true,
                    "updated": 1449275929000,
                    "sellable": true,
                    "settings": {
                        "noLabelNeeded": false,
                        "promptPriceEntryWhenAddToOrder": false,
                        "promptQuantityEntryWhenAddToOrder": false
                    },
                    "attributes": {},
                    "dimensions": {
                        "depth": {
                            "units": "inches",
                            "value": "0"
                        },
                        "width": {
                            "units": "inches",
                            "value": "0"
                        },
                        "height": {
                            "units": "inches",
                            "value": "0"
                        },
                        "volume": {
                            "units": "fluid ounces",
                            "value": "0"
                        },
                        "weight": {
                            "units": "pounds",
                            "value": "0"
                        },
                        "netWeight": {
                            "units": "pounds",
                            "value": "0"
                        }
                    },
                    "purchasable": true,
                    "uomBaseUnits": 1,
                    "variantRefKey": "b8851921cd9a15cbcec275e194b7185d"
                },
                "catalogs": {
                    "015bc55b01e32eecac0b2500229cb92a": {
                        "name": "Ecommerce",
                        "refKey": "015bc55b01e32eecac0b2500229cb92a",
                        "priceBook": "79cc841936a65cb393f7c07bad2473f8",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "7ad12efa0d503b104f337bcea070d03b": {
                        "name": "Retail - San Francisco",
                        "refKey": "7ad12efa0d503b104f337bcea070d03b",
                        "priceBook": "413c54c7eeaae2aa60d0d8fc6a45f656",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "bb4644a89b3c9d0ab9300b8d2a14cbd5": {
                        "name": "Retail - Spain",
                        "refKey": "bb4644a89b3c9d0ab9300b8d2a14cbd5",
                        "priceBook": "336dda8d3be833d74bba07e0878b2c7e",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "d52aefadd57e1070160c10795fe29533": {
                        "name": "Retail",
                        "refKey": "d52aefadd57e1070160c10795fe29533",
                        "priceBook": "8fb4554513934bc459807f086bb41ee6",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    },
                    "db5549e9ab9cad7eee9ddb36406c8da3": {
                        "name": "Retail - Miami",
                        "refKey": "db5549e9ab9cad7eee9ddb36406c8da3",
                        "priceBook": "8fb4554513934bc459807f086bb41ee6",
                        "categorySet": {
                            "name": "Retail Categories",
                            "refKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                        }
                    }
                },
                "categories": {
                    "4e71fb7c0a12a7e4b41e71db1655a057": {
                        "name": "Cooking",
                        "path": "Cooking",
                        "refKey": "4e71fb7c0a12a7e4b41e71db1655a057",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "b4e7d242302dc4a4d5d2e6c91db8f400": {
                        "name": "Cookware",
                        "path": "Cooking > Cookware",
                        "refKey": "b4e7d242302dc4a4d5d2e6c91db8f400",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    },
                    "f7f86b46b993fda96b485b3040d5149f": {
                        "name": "Knives & Cutting Boards",
                        "path": "Cooking > Knives & Cutting Boards",
                        "refKey": "f7f86b46b993fda96b485b3040d5149f",
                        "categorySetRefKey": "80f4bed1a6b4b9725f3b19cd224129ac"
                    }
                },
                "pricing": {
                    "defaults": {
                        "EUR": "012976626be18e897193be7a1f200ca2",
                        "USD": "8fb4554513934bc459807f086bb41ee6"
                    },
                    "priceBooks": {
                        "012976626be18e897193be7a1f200ca2": {
                            "msrp": 0,
                            "name": "Default Pricing - EUR",
                            "fixed": false,
                            "floor": 0,
                            "regular": 0,
                            "currency": "EUR",
                            "includesTax": true,
                            "systemDefault": true,
                            "priceBookRefKey": "012976626be18e897193be7a1f200ca2"
                        },
                        "8fb4554513934bc459807f086bb41ee6": {
                            "msrp": 34.99,
                            "name": "Default Pricing - USD",
                            "fixed": false,
                            "floor": 0,
                            "regular": 28.99,
                            "currency": "USD",
                            "includesTax": false,
                            "systemDefault": true,
                            "priceBookRefKey": "8fb4554513934bc459807f086bb41ee6"
                        }
                    }
                },
                "updated": 1455108407000,
                "archived": false,
                "inventory": {
                    "available": 40,
                    "reserved": 0,
                    "onOrder": 0,
                    "committed": 0,
                    "unavailable": 0
                }
            }
        ]};

        self.getResults = function(query, apiPath, fields, filter, limit) {
            query = query.toLowerCase();
            return $enApi.object({
                name    : 'autocompleteSearch',
                path    : apiPath,
                method  : 'list',
                fields  : fields,
                filter  : filter,
                limit   : limit,
                trigger : false,
                isolated: true
            }).get();
        };

        return self;
    }
    ComponentService.$inject = ["$enApi"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.autofocus').directive('enAutofocus', ComponentDirective);

    /**
     * @ngdoc directive
     * @name enAutofocus
     * @module enspire.ui.components.autofocus
     * @restrict A
     * @description
     * Gives focus to input.
     *
     * @usage
     * ### Basic Example
     * <hljs lang="html">
     *   <input type="text" value="Hello World" en-auto-focus />
     * </hljs>
     */

    function ComponentDirective($timeout) {
        return {
            restrict: 'A',
            link: function($scope, $element, $attrs) {
                $timeout(function(){
                    var elem = $element[0];
                    if (elem.value) {
                        elem.select();
                    } else {
                        elem.focus();
                    }
                }, 300);
            }
        }
    }
    ComponentDirective.$inject = ["$timeout"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.button').directive('enButton', ButtonDirective);

    /**
     * @ngdoc directive
     * @name enButton
     * @module enspire.ui.components.button
     * @restrict E
     * @description
     * `en-button` creates a styled button element.
     *
     * @element en-button
     *
     * @param {string=}    type             Causes `en-button` to become a form submit button. 
     * @param {string=}    ng-href          Buttons label text.
     * @param {function=}  ng-click         Function to call when the button is clicked.
     * @param {boolean=}   ng-disabled      Expression that evaluates to true|false and disables or enables the button element.
     *
     * @usage
     * ### As Link Button
     * <hljs lang="html">
     *   <en-button ng-href="http://www.someexternalwebsite.com" target="_blank">
     *       Link Text
     *   </en-button>
     * </hljs>
     * 
     * 
     * ### As Submit Button
     * <hljs lang="html">
     *   <!-- To function as a submit button this must be inside a form. -->
     *   <en-button type="submit">
     *       Submit
     *   </en-button>
     * </hljs>
     * 
     */
    
    function ButtonDirective(){
        return {
            restrict    : 'E',
            transclude  : true,
            replace     : true,
            template    : resolveTemplate,
            link        : postLink
        };
        
        function postLink($scope, $element, $attrs){
            
        }
        
        //Outputs the template to use based on resolveType
        function resolveTemplate($element, $attrs){
            var tmpl = null;
            if(angular.isDefined($attrs.href) || angular.isDefined($attrs.ngHref)){
                return '<a class="en-button" ng-transclude></a>';
            } else {
                if (angular.isDefined($attrs.type) && $attrs.type!=='') {
                    return '<button type="' + $attrs.type + '" class="en-button" ng-transclude></button>';
                } else {
                    return '<button type="button" class="en-button" ng-transclude></button>';
                }
            }
        }
        
    }
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.buttonGroup').directive('enButtonGroup', ButtonGroupDirective);


    /**
     * @ngdoc directive
     * @name enButtonGroup
     * @module enspire.ui.components.buttonGroup
     * @restrict E
     * @description
     * `en-button-group` is used to group, and style, multiple `<en-button>` elements together.
     *
     * @element en-button-group
     *
     * @usage
     * <hljs lang="html">
     *   <en-button-group>
     *       <en-button>Left</en-button>
     *       <en-button>Center</en-button>
     *       <en-button>Right</en-button>
     *   </en-button-group>
     * </hljs>
     * 
     */
    
    function ButtonGroupDirective(){
        return {
            restrict    : 'E',
            link        : postLink
        };
        
        function postLink($scope, $element, $attrs){
            
        }
    }
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * Checklist-model
 * AngularJS directive for list of checkboxes
 */

angular.module('enspire.ui.components.checklistModel').directive('enChecklistModel', ['$parse', '$compile', function($parse, $compile) {

        var attrSingle;
        // contains
        function contains(arr, item, comparator) {
            if (angular.isArray(arr)) {
                for (var i = arr.length; i--;) {
                    if (comparator(arr[i], item)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // add
        function add(arr, item, comparator) {
            if(attrSingle){
                arr = [];
            }else{
                arr = angular.isArray(arr) ? arr : [];
            }
            if(!contains(arr, item, comparator)) {
                arr.push(item);
            }
            return arr;
        }

        // remove
        function remove(arr, item, comparator) {
            if (angular.isArray(arr)) {
                for (var i = arr.length; i--;) {
                    if (comparator(arr[i], item)) {
                        arr.splice(i, 1);
                        break;
                    }
                }
            }
            return arr;
        }

        // http://stackoverflow.com/a/19228302/1458162
        function postLinkFn(scope, elem, attrs) {

            attrSingle = attrs.enChecklistSingle;
            // compile with `ng-model` pointing to `checked`
            $compile(elem)(scope);

            // getter / setter for original model
            var getter = $parse(attrs.enChecklistModel);
            var setter = getter.assign;
            var checklistChange = $parse(attrs.enChecklistChange);

            // value added to list
            var value = $parse(attrs.enChecklistValue)(scope.$parent);


            var comparator = angular.equals;

            if (attrs.hasOwnProperty('enChecklistComparator')){
                comparator = $parse(attrs.enChecklistComparator)(scope.$parent);
            }

            // watch UI checked change
            scope.$watch('checked', function(newValue, oldValue) {
                if (newValue === oldValue) {
                    return;
                }
                var current = getter(scope.$parent);
                if (newValue === true) {
                    setter(scope.$parent, add(current, value, comparator));
                } else {
                    setter(scope.$parent, remove(current, value, comparator));
                }

                if (checklistChange) {
                    checklistChange(scope);
                }
            });

            // declare one function to be used for both $watch functions
            function setChecked(newArr, oldArr) {
                scope.checked = contains(newArr, value, comparator);
            }

            // watch original model change
            // use the faster $watchCollection method if it's available
            if (angular.isFunction(scope.$parent.$watchCollection)) {
                scope.$parent.$watchCollection(attrs.enChecklistModel, setChecked);
            } else {
                scope.$parent.$watch(attrs.enChecklistModel, setChecked, true);
            }
        }

        return {
            restrict: 'A',
            priority: 1000,
            terminal: true,
            scope: true,
            compile: function(tElement, tAttrs) {
                if (tElement[0].tagName !== 'INPUT' || tAttrs.type !== 'checkbox') {
                    throw 'en-checklist-model should be applied to `input[type="checkbox"]`.';
                }

                if (!tAttrs.enChecklistValue) {
                    throw 'You should provide `en-checklist-value`.';
                }

                // exclude recursion
                tElement.removeAttr('en-checklist-model');

                // local scope var storing individual checkbox model
                tElement.attr('ng-model', 'checked');

                return postLinkFn;
            }
        };
    }]);

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
 
(function() {
    'use strict';


    /**
     * @ngdoc directive
     * @name enClipboard
     * @module enspire.ui.components.clipboard
     *
     * @restrict A
     *
     * @description
     * en-clipboard provides the ability to copy the text content to clipboard.
     *
     *
     * @param {string=}    text      to bind the text from any element.
     * @param {function=}  on-copy   on-copy can be used to notify on successful copying to clipboard.
     * @param {function=}  on-error  on-error can be used to notify on unsuccessful attempts at copying
     * 
     */

    angular.module('enspire.ui.components.clipboard')
           .directive('enClipboard', ['$document', function ($document) {
        return {
            restrict: 'A',
            scope: {
                onCopy: '&',
                onError: '&',
                text: '='
            },
            link: postLink
        };


        function postLink($scope, $element) {
                function createNode(text) {
                    var node = $document[0].createElement('textarea');
                    node.style.position = 'absolute';
                    node.style.left = '-10000px';
                    node.textContent = text;
                    return node;
                }

                function copyNode(node) {
                    // Set inline style to override css styles
                    $document[0].body.style.webkitUserSelect = 'initial';

                    var selection = $document[0].getSelection();
                    selection.removeAllRanges();
                    node.select();

                    $document[0].execCommand('copy');
                    selection.removeAllRanges();

                    // Reset inline style
                    $document[0].body.style.webkitUserSelect = '';
                }

                function copyText(text) {
                    var node = createNode(text);
                    $document[0].body.appendChild(node);
                    copyNode(node);
                    $document[0].body.removeChild(node);
                }

               $element.on('click', function (event) {
                    try {

                        copyText($scope.text);
                        if ($scope.onCopy) {
                            $scope.onCopy();
                        }
                    } catch (err) {
                        if ($scope.onError) {
                            $scope.onError({err: err});
                        }
                    }
                });

             
            }
        
    }]);

 })();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.collapse')
        .directive('enCollapse', collapseDirective);

    /**
     * @ngdoc directive
     * @name enCollapse
     * @module enspire.ui.components.collapse
     *
     * @restrict A
     *
     * @description
     * en-collapse will allow any component to become a collapsible one.  To ensure it works correctly, the parent element requires, and should
     * only contain, an `en-header` and `en-body` element. The en-collapse directive uses the en-header as the collapsible trigger and en-body as the
     * content to collapse.
     *
     *
     * @param {string=}   collapse-icon-open      Icon name to use when the collapsible component is expanded.
     * @param {string=}   collapse-icon-close     Icon name to use when the collapsible component is collapsed.
     * @param {string=}   collapse-icon-class     Styling class to add to the icon.. good for changing size of icon.
     * @param {boolean=}   collapse-trigger       For setting the trigger of the collapse, can be 'header' or 'icon'.
     * @param {string=}   collapse-name           Give a name to monitor the state of the collapsable area.
     *
     */
    function collapseDirective($compile, $timeout, $enTouch, $enCollapse) {
        return {
            restrict: 'A',
            link: postLink
        };


        function postLink($scope, $element, $attrs, $controller) {
            var children    = $element.children();
            var header      = angular.element(children[0]);
            var content     = angular.element(children[1]);
            var iconOpen    = $attrs.collapseIconOpen  || $attrs.iconOpen  || 'plus';
            var iconClose   = $attrs.collapseIconClose || $attrs.iconClose || 'minus';
            var iconClass   = $attrs.collapseIconClass || $attrs.iconClass || '';
            var collapseTrigger = $attrs.collapseTrigger || 'header' || 'icon';

            var collapsed   = $scope.$eval($attrs.enCollapse) || false;
            var area = $attrs.collapseName;

            if(angular.isDefined(area) && area!==''){
                $enCollapse.setCollapseArea(area,collapsed);
            }

            var trigger     = angular.element(header.find('en-collapse-trigger')[0]);
            var triggerIcon = angular.element('<en-icon class="'+iconClass+'" icon="'+(collapsed ? iconOpen : iconClose)+'"></en-icon>');

            // Check to see if a trigger already exists.
            // Create one and prepend it to the header if not.

            if(!angular.isDefined(trigger[0])){
                trigger = angular.element('<en-collapse-trigger></en-collapse-trigger>');
                header.prepend(trigger);
            }

            // Create the toggle icon indicator and insert into the trigger.
            trigger.empty();
            trigger.append(triggerIcon);

            var touch;
            switch(collapseTrigger){
                case 'icon':
                    touch = $enTouch.element(trigger);
                    break;
                default:
                    touch = $enTouch.element(header);
            }

            $scope.$on('$destroy', function(){
                touch.destroy();
            });

            touch.on('tap', function(){
                toggle();
            });

            $element[collapsed ? 'addClass' : 'removeClass']('collapsed');
            triggerIcon.attr('icon',(collapsed ? iconOpen : iconClose));

            function toggle(){
                $timeout(function(){
                    collapsed = !collapsed;
                    $element[collapsed ? 'addClass' : 'removeClass']('collapsed');
                    triggerIcon.attr('icon',(collapsed ? iconOpen : iconClose));
                    if(angular.isDefined(area) && area!==''){
                        $enCollapse.setCollapseArea(area,collapsed);
                    }
                });
            }

        }
    }
    collapseDirective.$inject = ["$compile", "$timeout", "$enTouch", "$enCollapse"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.collapse')
        .provider('$enCollapse', CollapseService);


/**
* @ngdoc service
* @name $enCollapse
* @module enspire.ui.components.collapse
*
* @description
* Manages collapsable areas.
*
*/


    function CollapseService() {
        var self = this;

        var areas = {};

        self.$get = ['$rootScope',function $enCollapseFactory($rootScope) {
             var obj = {
                /**
                 * @ngdoc method
                 * @name $enCollapse#setCollapseArea
                 *
                 * @description
                 * Sets a collapsable area state to monitor
                 *
                 * @param {string} collapseAreaName The name of the collapse area to be added.
                 * @param {boolean} isCollapsed The current state of the collapsable area.
                 */
                setCollapseArea: function (name,isCollapsed) {
                    areas[name] = !!isCollapsed;
                },
                /**
                 * @ngdoc method
                 * @name $enCollapse#CollapseArea
                 *
                 * @description
                 * Removes a collapsable area from state monitor.
                 *
                 * @param {string} collapseAreaName The name of the collapse area to be removed.
                 */
                removeCollapseArea: function (name) {
                    delete areas[name];
                },
                /**
                 * @ngdoc method
                 * @name $enCollapse#collapsed
                 *
                 * @description
                 * Closed state of collapsable area.
                 *
                 * @param {string} collapseAreaName    The name of the collapse area that the selected pane resides in.
                 *
                 * @returns {boolean} If found, returns the isCollapsed state. Otherwise it returns `undefined`.
                 */
                collapsed: function (name) {
                    if(typeof areas[name] === 'undefined'){
                        return undefined;
                    }else{
                        return !!areas[name];
                    }
                }
            };

            $rootScope.$enCollapse = obj;
            return obj;
        }];
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.collection')
        .controller('enCollectionController', CollectionController);

    /*
     * @private
     * @ngdoc controller
     * @name CollectionController
     * @module enspire.ui.components.collection
     *
     */
    function CollectionController($scope, $element) {
        var self = this;

        self.columns = [];
        self.gallery = {
            attrs:{},
            attrString:'',
            item:'',
            itemAttrs:{},
            itemAttrString:'',
            header:'',
            headerAttrs:{},
            headerAttrString:''
        };
        self.expandContents = {
            item:''
        };
        $scope.expandState = {};

        self.addColumn = function(obj){
            self.columns.push(obj);
        };

        self.setGallery = function(obj){
            self.gallery = obj;
        };

        self.setExpandContents = function(obj){
            self.expandContents = obj;
        };

        $scope.toggleExpand = function(row){
            if($scope.expandState[row]){
                $scope.expandState[row] = false;
            }else{
                $scope.expandState[row] = true;
            }
        };

        $scope.collectionCheckRow = function(collectionObj,item){
            var bolFound = false;
            var col = 0;
            var aryNewData = [];

            if(typeof collectionObj.selected === 'undefined') collectionObj.selected = [];

            var lngData = collectionObj.selected.length;
            var tempScope = $scope.$new();
            var column = self.columns[col];
            var strItem = JSON.stringify(item);
            for(var i=0;i<lngData;i++) {
                var objCurrent = collectionObj.selected[i];
                if(strItem!==JSON.stringify(objCurrent)){
                    if (column.checkboxDisabled){
                        tempScope.item = objCurrent;
                        if(!tempScope.$eval(column.checkboxDisabled)){
                            aryNewData.push(objCurrent);
                        }
                    }else{
                        aryNewData.push(objCurrent);
                    }
                }else{
                    bolFound = true;
                }
            }

            if(bolFound===false){
                aryNewData.push(angular.copy(item));
            }

            tempScope.$destroy();
            collectionObj.selected = aryNewData;

        };

        $scope.collectionCheckAll = function(collectionObj,col){
            if(collectionObj.checkAllModel){
                collectionObj.selected = [];
                var data = angular.copy(collectionObj.segmentedData);

                var lngData = data.length;
                var lngColumns = self.columns.length;
                var tempScope = $scope.$new();
                for(var i=0;i<lngData;i++) {
                    var column = self.columns[col];
                    if (column.checkboxDisabled){
                        tempScope.item = data[i];
                        if(!tempScope.$eval(column.checkboxDisabled)){
                            collectionObj.selected.push(data[i]);
                        }
                    }else{
                        collectionObj.selected.push(data[i]);
                    }
                }
                tempScope.$destroy();
            }else{
                collectionObj.selected = [];
            }
        };

        $scope.resizeColumn = function(el,cls) {
            //var startingWidth = 0;
            //var column = angular.element(document.querySelector('#'+cls));
            //
            //el.on('dragStart', function () {
            //    startingWidth = column[0].clientWidth;
            //});
            //
            //el.on('dragMove', function () {
            //    var self = this,
            //        pos = self.position,
            //        width = startingWidth,
            //        movement = Math.round(pos.x);
            //
            //    console.log(width);
            //
            //    if(movement===0){
            //        startingWidth++;
            //        width++;
            //    }else{
            //        width = width + movement;
            //    }
            //    column.css({"width":width + "px","min-width":width + "px","max-width":width + "px"});
            //    //$timeout(function () {
            //    //    $scope.slider.value = Math.round(pos.x);
            //    //});
            //    console.log(Math.round(pos.x));
            //});
        }
    }
    CollectionController.$inject = ["$scope", "$element"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.collection').directive('enCollection', CollectionDirective);
    angular.module('enspire.ui.components.collection').directive('enCollectionColumn', CollectionColumnDirective);
    angular.module('enspire.ui.components.collection').directive('enCollectionExpand', CollectionExpandDirective);
    angular.module('enspire.ui.components.collection').directive('enCollectionGallery', CollectionGalleryDirective);

    /**
     * @ngdoc directive
     * @name enCollection
     * @module enspire.ui.components.collection
     * @restrict E
     * @element en-collection
     *
     * @description
     * Use css class="collection-borderless" to remove a collections borders.  Useful when placing a collection inside of other layout elements such as `en-panels` which already contain borders and styling.
     *
     *
     * @usage
     * <hljs lang="html">
     *     <en-collection object="myDataObj" name="myCollectionName" url-enabled="true" view="list" list="" row-click="[function]" on-init="[function]">
     *         ...
     *     </en-collection>
     * </hljs>
     *
     * @param {object}    object                        The data object the collection uses to build itself out.
     * @param {string}    name                          Name of the collection.  This will be used elsewhere to reference this specific collection.
     * @param {boolean}   url-enabled                   When set, the collection will get data based on the parameters found in the browsers address bar. Useful for returning to search with browser back or sharing search url. `trigger=false` must be set on en-api-object corresponding to collection, otherwise, request will be duplicated.
     * @param {string}    [view=list|list, gallery]     Sets the view of the collection.
     * @param {boolean}   list                         When changed this property will force a collection rebuild. [deprecated: use en-list-object]
     * @param {function|expression}   row-click         A callback attached to all rows in a collection.  Uses `en-tap` directive as the event handler.
     * @param {object}    row-class                     Like ng-class, dynamically set CSS classes on an HTML element by databinding an expression that represents all classes to be added. Ex: row-class="{'row-info': item.status === 'draft'}". Available predefined classes: row-success, row-warn, row-error, row-info
     * @param {string=}   [empty-message=No results found.] Allows the developer to customize the message displayed to a user when no results are available for the collection to display.
     * @param {function|expression}   on-init           A callback that is fired once the collection has been initialized.
     *
     */

    function CollectionDirective($interpolate,$compile,$rootScope,$location) {
        var randomName = function () {
            var length = 32;
            var chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
            var result = '';
            for (var i = length; i > 0; --i){
                result += chars[Math.round(Math.random() * (chars.length - 1))];
            }
            return result;
        };

        //Outputs the template to use based on resolveType
        function resolveTemplate($element, $attrs){
            var collectionName = $attrs.name || randomName();
            //var collectionScroller = ($attrs.scrolling==='true' ? ' en-scrollbar' : '');
            var collectionScroller = ' en-scrollbar';
            var flexible = ($attrs.hasOwnProperty('flex')  ? ' flex' : '');

            $attrs.collectionName = collectionName;



            return  '<div class="en-collection" layout="column" ng-class="{\'collection-gallery\':'+collectionName+'.view===\'gallery\'}" en-loader="'+collectionName+'.loading" loader-text="loading" loader-size="lg">'+
                        '<div class="en-collection-header" layout="row" id="'+collectionName+'_collectionHeader" ng-class="{blur: '+collectionName+'.loading}">'+
                        '</div>'+
                        '<div class="en-collection-body"' + collectionScroller + '' + flexible + ' id="'+collectionName+'_collectionBody" ng-class="{blur: '+collectionName+'.loading}" style="'+(($attrs.minHeight) ? 'min-height:'+$attrs.minHeight+'px !important;' : '')+'">'+
                        '</div>'+
                        '<div class="en-collection-overlay" ng-if="'+collectionName+'.loading || '+collectionName+'.typing || '+collectionName+'.data.length===0">'+
                            '<div class="en-collection-overlay-bg"></div>'+
                            '<div class="en-collection-overlay-empty" ng-if="'+collectionName+'.data && '+collectionName+'.data.length===0 && '+collectionName+'.typing===false && '+collectionName+'.loading===false">'+((angular.isDefined($attrs.emptyMessage)) ? $attrs.emptyMessage+'' : 'No results found.')+'</div>'+
                            '<div class="en-collection-buffer-overlay" ng-if="'+collectionName+'.typing===true"><div class="en-grid-buffer-overlay-typing"></div><div class="en-collection-buffer-overlay-typing-text">typing</div></div>'+
                            // '<div class="en-collection-buffer-overlay" ng-if="'+collectionName+'.loading"><div class="en-collection-buffer-overlay-loader"></div><div class="en-collection-buffer-overlay-loader-text">loading</div></div>'+
                            '<div class="en-collection-buffer-overlay en-collection-error" ng-if="'+collectionName+'.errors.length===true&&'+collectionName+'.loading!==true"><b>Hmm..</b> Looks like a {{errorStatus}} code ({{errorStatusText}}) - {{errorMessage}}</div>'+
                        '</div>'+
                    '</div>';
        }

        return {
            restrict    : 'E',
            controller  : 'enCollectionController',
            compile     : compile,
            replace     : true,
            transclude  : true,
            template    : resolveTemplate
        };

        function compile($element, $attrs, $transclude) {

            return function postLink($scope, $element, $attrs, $enCollectionCtrl) {
                $transclude($scope, function (clone) {
                    $element.append(clone);
                });

                var collectionName = $attrs.collectionName;
                var collectionHeader = $element[0].querySelector('.en-collection-header');
                var collectionBody = $element[0].querySelector('.en-collection-body');
                //var collectionScroller = ($attrs.scrolling==='true' ? ' en-scrollbar' : '');
                var collectionScroller = ' en-scrollbar';

                var getColumnHeader = function (column) {
                    if (column.header) {
                        return column.header;
                    } else {
                        return (column.name !== undefined) ? column.name : '';
                    }
                };

                var getColumnCell = function (column) {
                    if (column.cell) {
                        return column.cell;
                    } else {
                        return '{{:: item' + dotNotationToObject(column.field) + '+\' \' }}';
                    }
                };

                var dotNotationToObject = function (str) {
                    if (!str) str += '';
                    var aryStr = str.split('.');
                    var lngStr = aryStr.length;
                    var newString = '';

                    for (var i = 0; i < lngStr; i++) {
                        newString += '[\'' + aryStr[i] + '\']';
                    }
                    return newString;
                };

                var watchData, watchPage, watchSort, watchView, lastResponseAt;

                $scope[collectionName] = $scope.$eval($attrs.object) || {};

                if (typeof $scope[collectionName] === 'string') {
                    $scope[collectionName] = $scope[$scope[collectionName]];
                }



                if ($scope[collectionName] !== undefined) {

                    //Sets the initial view and caches it for later use.
                    $scope[collectionName].defaultView =
                        $scope[collectionName].view =
                            $attrs.view || 'list';

                    if ($scope[collectionName]._isListObject) {
                        watchData = $scope.$watch(function () {
                            return $scope[collectionName].segmentedData;
                        }, function (val) {
                            if(typeof val !== 'undefined') {
                                build();
                            }
                        }, true);
                    } else {
                        watchData = $scope.$watch(function () {
                            return $scope[collectionName].lastResponseAt;
                        }, function (val,oldval) {
                            if(typeof val !== 'undefined' && val!==oldval){
                                lastResponseAt = val;
                                build();
                            }
                        }, true);
                    }

                    $scope[collectionName + '_sort'] = function (sw, f) {
                        var field;
                        if (sw !== undefined && sw !== 'undefined') {
                            field = sw;
                        } else {
                            if (f === undefined || f === 'undefined') return false;
                            field = f;
                        }

                        var currentSort = $scope[collectionName].sort;
                        if (currentSort === field) {
                            if (currentSort.substring(0, 1) === '-') {
                                $scope[collectionName].setSort(field);
                            } else {
                                $scope[collectionName].setSort('-' + field);
                            }
                        } else {
                            $scope[collectionName].setSort(field);
                        }
                    };

                    if ($attrs.urlEnabled === 'true' && !$scope.isModal) {

                        watchPage = $scope.$watch(function () {
                                return $scope[collectionName].page;
                            },
                            function (val, old) {
                                if (old !== val) {
                                    if (val + '' !== $location.search().page + '') {
                                        if (val > 1) {
                                            $location.search('page', val);
                                        } else {
                                            $location.search('page', null);
                                        }
                                    }
                                }
                            });


                        watchSort = $scope.$watch(function () {
                                return $scope[collectionName].sort;
                            },
                            function (val, old) {
                                if (old !== val) {
                                    if (val !== $location.search().sort) {
                                        if (val !== '') {
                                            $location.search('sort', val);
                                        } else {
                                            $location.search('sort', null);
                                        }
                                    }
                                }
                            });


                        watchView = $scope.$watch(function () {
                                return $scope[collectionName].view;
                            },
                            function (val, old) {
                                if (old !== val) {
                                    if (val !== $location.search().view) {
                                        if (val !== '' && val !== $scope[collectionName].defaultView) {
                                            $location.search('view', val);
                                        } else {
                                            $location.search('view', null);
                                        }
                                    }
                                }
                            });
                    }
                }

                var watchList = $scope.$watch($attrs.list, function (val) {
                    $scope[collectionName + '_list'] = $scope.$eval($attrs.list);

                    watchData = $scope.$watch(function () {
                        return $scope[collectionName + '_list'];
                    }, function (val) {
                        if(typeof val !== 'undefined'){
                            build();
                        }
                    }, true);
                });

                var watchColumns = $scope.$watch($enCollectionCtrl.columns, function (val) {
                    $scope[collectionName+'_columns'] = $enCollectionCtrl.columns;

                    var initialized = false;
                    watchSort = $scope.$watch(function(){ return $scope[collectionName+'_columns']; }, function (val) {
                        if(initialized===false){
                            initialized = true;
                        }else{
                            build();
                        }
                    },true);
                });

                var previousHeader = '';
                var build = function(){
                    var header;
                    var filterString = '';
                    var source = collectionName+'.data';

                    if($scope[collectionName].view === undefined){
                        $scope[collectionName].view = $scope[collectionName].defaultView;
                    }
                    $scope[collectionName].setView = function(str){
                        $scope[collectionName].view = str;
                        build();
                    };

                    if($scope[collectionName]._isListObject){
                        //    source = collectionName+'.segmentedData';
                        if($scope[collectionName].q!==''){
                            filterString += ' | filter:\''+$scope[collectionName].q+'\'';
                        }

                        if($scope[collectionName].sort!==''){
                            filterString += ' | orderBy:\''+$scope[collectionName].sort+'\'';
                        }
                        if($scope[collectionName].limit>0){
                            filterString += ' | limitTo:'+$scope[collectionName].limit+':'+$scope[collectionName].offset+'';
                        }
                    }

                    if(angular.isDefined($attrs.list)){
                        source = collectionName+'_list';
                    }

                    var flexible = ($attrs.hasOwnProperty('flex')  ? ' flex' : '');

                    var body = '<div class="en-collection-body"'+collectionScroller+''+flexible+' id="'+collectionName+'_collectionBody" ng-class="{blur: '+collectionName+'.loading}" style="'+(($attrs.minHeight) ? 'min-height:'+$attrs.minHeight+'px !important;' : '')+(($attrs.height) ? 'height:'+$attrs.height+'px !important;' : '')+'"';

                    if($scope[collectionName].view==='list'){
                        var lngColumns = $enCollectionCtrl.columns.length;

                        //header = '<div en-sortable-root en-sortable-part="'+collectionName+'_columns">';
                        header = '<div layout="row" flex>';

                        body += '><div'+((angular.isDefined($attrs.enSortable)) ? ' en-sortable-root en-sortable-part="'+source+'"' : '')+'><div ng-repeat="item in '+source+''+filterString+' track by $index" '+((angular.isDefined($attrs.enSortable)) ? 'en-sortable-element="{containment:\'.en-collection-body\'}"' : '')+'><div class="en-collection-row" layout="row" layout-align="start stretch"';
                        if($attrs.rowClick!==undefined){
                            body += ' en-tap="'+$attrs.rowClick+'"';
                        }
                        if($attrs.rowClass !== undefined){
                            body += ' ng-class="' + $attrs.rowClass + '"';
                        }
                        body += '>';

                        for(var x=0;x<lngColumns;x++) {
                            var column = $enCollectionCtrl.columns[x];

                            if(!column.columnHide()) {
                                if (column.checkbox === 'true' || column.checkbox === 'single' || column.checkbox === 'multiple') {
                                    header += '<div style="width:36px; min-width:36px; max-width:36px;" ' + column.cellAttrString + ' layout layout-align="center">';
                                    if (column.checkbox !== 'single')header += '<input type="checkbox" ng-model="' + collectionName + '.checkAllModel" ng-change="collectionCheckAll(' + collectionName + ','+x+')"/>';
                                    header += '</div>';
                                    body += '<div layout layout-align="center center" ' + column.cellAttrString + ' en-tap="$event.stopPropagation();';
                                    if (angular.isDefined(column.columnClick)) {
                                        body += column.columnClick;
                                    }
                                    body += '" style="width:36px; min-width:36px; max-width:36px;"><input id="'+collectionName+'_checkbox_{{$index}}_'+x+'" type="checkbox" en-checklist-model="' + collectionName + '.selected"';
                                    if (column.checkboxDisabled) body += ' ng-disabled="'+column.checkboxDisabled+'"';
                                    if (column.checkbox === 'single') body += ' en-checklist-single="true';
                                    body += '" en-checklist-value="item" en-tap="$event.stopPropagation();';
                                    if (angular.isDefined(column.columnClick)) {
                                        body += column.columnClick;
                                    }
                                    body += '"/></div>';
                                }else if(column.expandable === 'true'){
                                    header += '<div style="width:36px; min-width:36px; max-width:36px;" ' + column.cellAttrString + ' layout layout-align="center"></div>';
                                    body += '<div layout layout-align="center center" ' + column.cellAttrString + ' en-tap="$event.stopPropagation();toggleExpand($index);';
                                    if (angular.isDefined(column.columnClick)) {
                                        body += column.columnClick;
                                    }
                                    body += '" style="width:36px; min-width:36px; max-width:36px;">';
                                    body += '<en-icon icon="'+column.iconOpened+'" class="collection-expand-icon" ng-if="expandState[$index]"></en-icon>';
                                    body += '<en-icon icon="'+column.iconClosed+'" class="collection-expand-icon" ng-if="!expandState[$index]"></en-icon>';
                                    body += '</div>';
                                }else {
                                    var width = column.width || '180';
                                    var align = column.align || 'start';
                                    switch (align) {
                                        case 'left':
                                            align = 'start';
                                            break;
                                        case 'center':
                                            align = 'center';
                                            break;
                                        case 'right':
                                            align = 'end';
                                            break;
                                        default:
                                            align = 'start';
                                    }

                                    var style = '';
                                    if (angular.isDefined(column.width) || column.cellAttrs['flex'] === undefined) {
                                        style = 'width: ' + width + 'px; min-width: ' + width + 'px; max-width: ' + width + 'px;';
                                    }
                                    body += '<div layout layout-align="' + align + ' center" style="' + style + '" ' + column.cellAttrString + '';

                                    if ((column.stopPropagation + '' === 'true') || (angular.isDefined(column.columnClick))) {
                                        body += ' en-tap="';

                                        if (column.stopPropagation + '' === 'true') {
                                            body += '$event.stopPropagation();';
                                        }

                                        if (angular.isDefined(column.columnClick)) {
                                            body += column.columnClick;
                                        }
                                        body += '"';
                                    }


                                    body += '>' + getColumnCell(column) + '</div>';


                                    header += '<div id="'+collectionName+'_column_'+x+'" layout' +
                                        ' style="' + style + '" ' + column.cellAttrString + ' ' +
                                        ' ng-class="::{sortable: \'' + column.sortWith + '\'!==\'undefined\', sorted: (' + collectionName + '.sort === \'' + column.sortWith + '\'  || ' + collectionName + '.sort===\'-' + column.sortWith + '\')}" ' +
                                        ' data-field="' + column.field + '" ' +
                                        ' en-tap="(\'' + column.sortWith + '\'!==\'undefined\') ? ' + collectionName + '_sort(\'' + column.sortWith + '\',\'' + column.field + '\') : \'\'"' +
                                        '>' +
                                        '   <div layout layout-align="' + align + ' center" flex class="en-collection-title">' + getColumnHeader(column) + '</div>' +
                                        '   <div class="en-collection-sort">' +
                                        '       <en-icon icon="sort" ' +
                                        '           ng-class="::{desc: ' + collectionName + '.sort.substring(0, 1) === \'-\'}"' +
                                        '           ng-show="::\'' + column.sortWith + '\'!==\'undefined\'">' +
                                        '       </en-icon>' +
                                        '   </div>' +
                                        //'   <div class="en-collection-resize" en-draggable drag-axis="x" drag-containment="true" drag-complete="resizeColumn(dragEl,\''+collectionName+'_column_'+x+'\')"></div>' +
                                        '</div>';
                                }
                            }
                        }


                        header += '<en-flex></en-flex>';

                        body += '<en-flex></en-flex>';
                        body += '</div>'; //close row
                        if($enCollectionCtrl.expandContents.item!==''){
                            body += '<div class="en-collection-expand" ng-if="expandState[$index]">'+$enCollectionCtrl.expandContents.item+'</div>';
                        }
                    }else{

                        body += '>';

                        body += '<div layout="row" layout-wrap'+$enCollectionCtrl.gallery.attrString+'>';

                        // Gallery Wrapper

                        // Repeatable Gallery Tile
                        body += '<div class="en-collection-tile '+$enCollectionCtrl.gallery.itemAttrs.class+'" ng-repeat="item in '+source+''+filterString+' track by $index" en-tap="'+$attrs.rowClick+'" '+$enCollectionCtrl.gallery.itemAttrString+'>';
                        body += $enCollectionCtrl.gallery.item;
                        body += '</div>';

                        body += '</div>';

                        header = $enCollectionCtrl.gallery.header+'';
                    }
                    body += '</div></div>';

                    if(header){
                        if(previousHeader != header){
                            previousHeader = header;
                            var elHeader = $compile(header)($scope,function(el){
                                angular.element($element[0].querySelector('#'+collectionName+'_collectionHeader')).html('').append(el);
                            });
                        }
                    }else{
                        angular.element($element[0].querySelector('#'+collectionName+'_collectionHeader')).html('');
                    }

                    if(body){

                        var elBody = $compile(body)($scope,function(el){
                            angular.element($element[0].querySelector('#'+collectionName+'_collectionBody')).remove(el);
                            angular.element($element[0].querySelector('.en-collection-header')).after(el);
                            collectionBody = $element[0].querySelector('.en-collection-body');
                            angular.element(collectionBody).on('scroll', function(e) {
                                try {
                                    collectionHeader.querySelector('div').scrollLeft = collectionBody.scrollLeft;
                                }catch(e){}
                            });
                            angular.element(collectionBody).on('scroll', function(e) {
                                try {
                                    collectionHeader.scrollLeft = collectionBody.scrollLeft;
                                }catch(e){}
                            });

                        });

                    }else{
                        angular.element($element[0].querySelector('#'+collectionName+'_collectionBody')).html('');
                    }
                };

                $scope[collectionName].rebuild = build;


                $scope.$on('$destroy', function () {
                    //watchApiObject(); //clear $watch
                    watchColumns();
                    watchData();
                });

                var hasRan = false;
                if($attrs.urlEnabled === 'true' && !$scope.isModal){
                    var locationSearch = $location.search();

                    if(angular.isDefined(locationSearch.page)){
                        $scope[collectionName].offset = parseInt(locationSearch.page)*$scope[collectionName].limit-$scope[collectionName].limit;
                    }
                    if(angular.isDefined(locationSearch.sort)){
                        $scope[collectionName].sort = locationSearch.sort;
                    }
                    if(angular.isDefined(locationSearch.view)){
                        $scope[collectionName].view = locationSearch.view;
                    }

                    var checkLocation = function(){
                        var locationSearch = $location.search();

                        var refresh = false;
                        if(angular.isDefined(locationSearch.page)){
                            if(locationSearch.page+''!==$scope[collectionName].page+''){
                                $scope[collectionName].offset = parseInt(locationSearch.page)*$scope[collectionName].limit-$scope[collectionName].limit;
                                refresh = true;
                            }
                        }else{
                            if('1'!==$scope[collectionName].page+'' && $scope[collectionName].page!==0){
                                $scope[collectionName].offset = parseInt(locationSearch.page)*$scope[collectionName].limit-$scope[collectionName].limit;
                                refresh = true;
                            }
                        }
                        if(angular.isDefined(locationSearch.sort)){
                            if($scope[collectionName].sort !== locationSearch.sort){
                                $scope[collectionName].sort = locationSearch.sort;
                                refresh = true;
                            }
                        }else{
                            if($scope[collectionName].sort!=='' && $scope[collectionName].sort !== $scope[collectionName].defaultSort){
                                refresh = true;
                            }else{
                                $scope[collectionName].sort = $scope[collectionName].defaultSort;
                            }
                        }

                        if(angular.isDefined(locationSearch.view)){
                            if($scope[collectionName].view !== locationSearch.view){
                                $scope[collectionName].view = locationSearch.view;
                                build();
                            }
                        }else{
                            // NO VIEW SET IN URL SO USE defaultView
                            if($scope[collectionName].view !== $scope[collectionName].defaultView){
                                $scope[collectionName].view = $scope[collectionName].defaultView;
                                build();
                            }else{
                                $scope[collectionName].view = $scope[collectionName].defaultView;
                            }
                        }
                        if(refresh && $scope[collectionName].refresh !== undefined){
                            $scope[collectionName].refresh();
                            hasRan = true;
                        }
                        return refresh;
                    };

                    var currentPath = $location.path();
                    $scope.$on('$locationChangeSuccess', function(){
                        if(currentPath===$location.path()) checkLocation();
                    });

                    /*Fix for page refresh*/
                    var initWatch = $scope.$watch(function(){ return $location.search(); },function(newVal,oldVal){
                        if(!checkLocation()){
                            if(angular.isDefined($attrs.trigger)===false || $attrs.trigger===true || $attrs.trigger==='true'){
                                if($scope[collectionName].refresh !== undefined){
                                    $scope[collectionName].refresh();
                                    hasRan = true;
                                }
                            }
                        }
                        initWatch();
                    });
                }else{
                    build();
                }

                if(angular.isDefined($attrs.onInit)){
                    $scope.$eval($attrs.onInit);
                }
            };
        }
    }
    CollectionDirective.$inject = ["$interpolate", "$compile", "$rootScope", "$location"];




    /**
     * @ngdoc directive
     * @name enCollectionColumn
     * @module enspire.ui.components.collection
     * @restrict E
     * @requires enCollection
     * @element en-collection-column
     *
     * @description
     *
     *
     *
     * @usage
     * <hljs lang="html">
     *     <en-collection-column name="PRICE" sort-with="fieldToSortBy">
     {{item.price}}
     </en-collection-column>
     * </hljs>
     *
     * @param {string}    field                    The name of the object property a column will be assigned to.
     * @param {string=}    name                       Title of the column.  Used as the column header name in the outputted collection grid.
     * @param {string=}   [sort-with=value of field]  Name of the property to sort a column with.  This is only needed when you want to sort a
     *                                                column based on a property other than the one defined in the `field` param.
     * @param {string=}   [align=left]             Sets a columns text alignment. Options are left | right | center.
     * @param {number=}  width                     When changed this property will force a collection rebuild. TODO: Jason, please check param description for this property.
     * @param {function=|expression=}   column-click    A callback attached to all cells in a column.  Uses `en-tap` directive as the event handler.
     * @param {string=}   [checkbox=false]      Turns on/off the checkbox column. Options are multiple | single | true | false.
     * @param {boolean=}   [stop-propagation=false]      Stops events fired inside a column from propagating up the dom.
     * @param {expression=}   column-hide      If evals to true the column will not show .
     * @param {expression=}   column-if        Same as ng-if.
     * @param {expression=}   column-repeat      Same as ng-repeat.
     * @param {expression=}   checkbox-disabled      Works just like ng-disabled.
     */

    function CollectionColumnDirective() {

        return {
            restrict    : 'E',
            require     : '^enCollection',
            compile     : compile,
            priority    : 99999
        };

        function compile($element, $attrs) {
            //capture raw contents and remove from element before it is compiled

            var columnHeader = $element.find('en-collection-column-header');
            var columnHeaderContents = '';
            if(columnHeader.length > 0){
                columnHeaderContents = columnHeader.html();
                columnHeader.remove();
            }

            var columnCell = $element.find('en-collection-column-cell');
            var columnCellContents = '';
            //var columnCellContainerAttributes;
            var columnHeaderAttrs = {};
            var columnHeaderAttrString = '';
            var columnCellAttrs = {};
            var columnCellAttrString = '';
            if(columnCell.length > 0){
                columnCellContents = columnCell.html();
                //columnCellContainerAttributes = columnCell[0].attributes;
                columnCell.remove();
            }else{
                //columnCellContainerAttributes = $element[0].attributes;
                columnCellContents = $element.html();
            }

            for (var att, i = 0, atts = $element[0].attributes, n = atts.length; i < n; i++){
                att = atts[i];
                columnCellAttrs[att.nodeName] = att.nodeValue;
                columnHeaderAttrs[att.nodeName] = att.nodeValue;
                switch(att.nodeName){
                    case 'column-if':
                        columnCellAttrString += ' ng-if="'+att.nodeValue+'"';
                        break;
                    case 'column-repeat':
                        columnCellAttrString += ' ng-repeat="'+att.nodeValue+'"';
                        break;
                    case 'layout':
                    case 'layout-align':
                    case 'field':
                    case 'sort-with':
                    case 'align':
                    case 'name':
                    case 'width':
                    case 'column-click':
                    case 'expandable':
                    case 'icon-opened':
                    case 'icon-closed':
                    case 'column-hide':
                    case 'stop-propagation':
                    case 'checkbox':
                    case 'checkbox-disabled':

                        break;
                    default:
                        columnCellAttrString += ' '+att.nodeName+'="'+att.nodeValue+'"';
                        columnHeaderAttrString += ' '+att.nodeName+'="'+att.nodeValue+'"';
                }
            }

            $element.html('');

            return function postLink($scope, $element, $attrs, $enCollectionCtrl) {
                var column = {
                    name:$attrs.name,
                    field:$attrs.field,
                    sortWith:$attrs.sortWith,
                    width:$attrs.width,
                    align:$attrs.align,
                    columnHide: function(){ return $scope.$eval($attrs.columnHide) || false},
                    checkboxDisabled: $attrs.checkboxDisabled,
                    columnClick:$attrs.columnClick,
                    checkbox: $attrs.checkbox || false,
                    expandable: $attrs.expandable || false,
                    iconOpened: $attrs.iconOpened || 'minus-block',
                    iconClosed: $attrs.iconClosed || 'plus-block',
                    onCheckbox: $attrs.checkbox || false,
                    stopPropagation:$attrs.stopPropagation || false,
                    cellAttrs:columnCellAttrs,
                    cellAttrString:columnCellAttrString
                };

                //If sortWith is undefined then populate with field name, if it is defined.
                if(!angular.isDefined($attrs.sortWith) && angular.isDefined($attrs.field)){
                    column.sortWith = column.field;
                }

                if($attrs.sortWith===''){
                    delete column.sortWith;
                }

                if(columnCellContents!=='' && columnCellContents!==undefined){
                    column.cell = columnCellContents;
                }
                if(columnHeaderContents!=='' && columnHeaderContents!==undefined){
                    column.header = columnHeaderContents;
                }

                $enCollectionCtrl.addColumn(column);

                //remove element, as it is no longer needed
                $element.remove();
            };
        }
    }

    function CollectionGalleryDirective() {

        return {
            restrict    : 'E',
            require     : '^enCollection',
            compile     : compile
        };

        function compile($element, $attrs) {
            //capture raw contents and remove from element before it is compiled
            var columnGalleryAttrs = $attrs;
            var columnGalleryAttrString = '';

            var columnGalleryHeaderContents = '';
            var columnGalleryHeaderAttrs = {};
            var columnGalleryHeaderAttrString = '';
            var columnGalleryHeader = $element.find('en-collection-gallery-header');
            if(columnGalleryHeader.length > 0){
                for (var att, i = 0, atts = columnGalleryHeader[0].attributes, n = atts.length; i < n; i++){
                    att = atts[i];
                    columnGalleryHeaderAttrs[att.nodeName] = att.nodeValue;
                    switch(att.nodeName){
                        case 'class': case 'ng-repeat':case 'layout':case 'layout-wrap':
                        break;
                        default:
                            columnGalleryHeaderAttrString += ' '+att.nodeName+'="'+att.nodeValue+'"';
                    }
                }
                columnGalleryHeaderContents = columnGalleryHeader.html();
                columnGalleryHeader.remove();
            }

            var columnGalleryItemContents = '';
            var columnGalleryItemAttrs = {};
            var columnGalleryItemAttrString = '';
            var columnGalleryItem = $element.find('en-collection-gallery-item');
            if(columnGalleryItem.length > 0){
                for (var att, i = 0, atts = columnGalleryItem[0].attributes, n = atts.length; i < n; i++){
                    att = atts[i];
                    columnGalleryItemAttrs[att.nodeName] = att.nodeValue;
                    switch(att.nodeName){
                        case 'class': case 'ng-repeat':case 'layout':case 'layout-wrap':
                        break;
                        default:
                            columnGalleryItemAttrString += ' '+att.nodeName+'="'+att.nodeValue+'"';
                    }
                }
                columnGalleryItemContents = columnGalleryItem.html();
                columnGalleryItem.remove();
            }else{
                columnGalleryItemContents = $element.html();
            }
            $element.html('');

            return function postLink($scope, $element, $attrs, $enCollectionCtrl) {
                $enCollectionCtrl.setGallery({
                    attrs:columnGalleryAttrs,
                    attrString:columnGalleryAttrString,
                    item:columnGalleryItemContents,
                    itemAttrs:columnGalleryItemAttrs,
                    itemAttrString:columnGalleryItemAttrString,
                    header:columnGalleryHeaderContents,
                    headerAttrs:columnGalleryHeaderAttrs,
                    headerAttrString:columnGalleryHeaderAttrString
                });

                //remove element, as it is no longer needed
                $element.remove();
            };
        }
    }

    function CollectionExpandDirective() {

        return {
            restrict    : 'E',
            require     : '^enCollection',
            compile     : compile
        };

        function compile($element, $attrs) {
            //capture raw contents and remove from element before it is compiled
            var expandItemContents = $element.html();

            $element.html('');

            return function postLink($scope, $element, $attrs, $enCollectionCtrl) {
                $enCollectionCtrl.setExpandContents({
                    item:expandItemContents
                });

                //remove element, as it is no longer needed
                $element.remove();
            };
        }
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.collection')
        .provider('$enCollection', collectionService);

    function collectionService() {
        var self = this;

        var objEmptyGrid = {
            name:'',
            path:'',
            page:0,
            limit:0,
            selected:[],
            object:undefined,
            search:{
                mode:'basic',
                basic:{
                    term:'',
                    fields:[]
                },
                advanced:{}
            }
        };


        var collectionServiceData = {
            collections:{} //holds collection's data
        };

        self.$get = [function $enCollectionFactory() {
            return self.defaults;
        }];
    }
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.collectionRepeat').directive('enCollectionRepeat', CollectionRepeat);

    /**
     * @ngdoc directive
     * @name enCollectionRepeat
     * @module enspire.ui.components.collectionRepeat
     * @restrict A
     * @description
     * Minimalist "collection-repeat" using built-in ng-repeat. Small code footprint. Allows a large recordset to be scrolled without a performance penalty.
     *
     *
     * @usage
     * ### As attribute
     * <hljs lang="html">
     *   <div en-collection-repeat="item in items">
     *      ...
     *   </div>
     * </hljs>
     *
     * <br />
     * <br />
     * Be sure to have a root element. In the example below, the `<div>` tag is the root element and wraps the content that will be repeated. See https://docs.angularjs.org/api/ng/directive/ngRepeat for more details.
     * 
     * <hljs lang="html">
     *   <div en-collection-repeat="item in items">
     *      <div class="your-row-class-here">
     *           <img ng-src="{{item.image}}" />
     *           <a href="#">Item {{item.value}}</a>
     *      </div>
     *   </div>
     * </hljs>
     *
     *
     * ## Available Options
     *
     * Attribute         | Default | Required     | Description
     * ------------------|---------|--------------|------------
     * <span style="white-space: nowrap">en-collection-repeat</span> |         | **Required** | The expression indicating how to enumerate a collection. Can be `variable in expression` or `(key, value) in expression`.
     * items-per-row     | 1       | Optional     | Set the `items-per-row` only for repeating items that are inline-block or floating. Defaults to 1 item per row.
     * order-by          |         | Optional     | **Only works if collection is an array.** - A predicate to be used by the comparator to determine the order of elements. See https://docs.angularjs.org/api/ng/filter/orderBy
     * reverse-order     |         | Optional     | *Boolean*. Reverse the order of the array.
     * track-by          |         | Optional     | An optional tracking expression which can be used to associate the objects in the collection with the DOM elements. If no tracking expression is specified, ng-repeat associates elements by identity.
     *
     *
     * ## Additional notes:
     * The directive assumes that each row will be the same height and uses the height of the first row. 
     * <br />
     * <br />
     * Tips: 
     *   - If loading images use `ng-src`.
     *   - When using ajax or if content of row loads dynamically, assign the row a fixed height via CSS.
     */

    function CollectionRepeat($timeout){

        /**
         * Calculate inner height of an element
         */

        function innerHeight(el) {
            var style = window.getComputedStyle(el, null),
                height = style.getPropertyValue("height");
            return parseInt(height);
        }
        
        return {
            restrict: 'A',
            scope: true,
            compile: function(element, attrs, transclude) {
                var repeatExpression = attrs.enCollectionRepeat,
                    collection = repeatExpression.split(' ')[2],
                    dirEl = element,
                    childEl = element.children().eq(0),
                    childElHeight = innerHeight(childEl[0]),
                    itemsPerRow = (attrs.itemsPerRow) ? parseInt(attrs.itemsPerRow): 1,
                    startAt = 0,
                    dimensions = {},
                    limitTo;
                    
                    
                // Full underlying Syntax:
                // ng-repeat="item in items | orderBy: orderProp : orderReverse | limitTo: limitCount: startAtIndex track by item.id"
                    
                
                // Order collection?
                if (attrs.orderBy) {
                    repeatExpression += '|orderBy:' + attrs.orderBy;
                }
                
                // Reverse order?
                if (attrs.reverseOrder) {
                    repeatExpression += ':' + attrs.reverseOrder;
                }
                
                // Setup ng-repeat limits
                repeatExpression += '|limitTo:limitCount:startAt';
                
                // Add optional track by
                if (attrs.trackBy) {
                    repeatExpression += ' track by ' + attrs.trackBy;
                }
                
                childEl.attr('ng-repeat', repeatExpression);
                
                // Wrap repeating items in a container
                childEl.wrap('<div class="content-wrapper"></div>');
                
                // Figure out how many items to display
                limitTo = innerHeight(element[0]) / innerHeight(childEl[0]);
                limitTo *= itemsPerRow;
                
                
                return {
                    pre: function preLink(scope, element, attrs, crtl, transclude) {
                        var contentWrapper = angular.element(element[0].querySelector('.content-wrapper')),
                            totalItems,
                            newHeight,
                            clearWatch;       
                        
                        clearWatch = scope.$watch(collection, function(newValue, oldValue) {
                            if (!newValue) {
                                return;
                            }

                            //totalItems = scope[collection].length || 0;
                            totalItems = newValue.length || oldValue.length || 0;

                            newHeight = (totalItems / itemsPerRow) * childElHeight;

                            // Limit repeat to x number of items
                            scope.limitCount = limitTo + itemsPerRow;
                            
                            // Start repeat at specified index
                            scope.startAt = startAt;
                            
                            // Calulate if we loaded all items, how long would
                            // the container be. Set that height for wrapper div.
                            dimensions.containerHeight = newHeight; 
                            contentWrapper.css('height', newHeight + 'px'); 

                            // If collection is updated while scrolling fix offset
                            element[0].scrollTop = 0;                           
                        });

                        scope.$on('$destroy', function(){
                            // clear the watch
                            clearWatch();
                        });
                    },
                    
                    post: function postLink(scope, element, attrs, crtl) {
                        var el = element[0],
                            contentWrapper = angular.element(el.querySelector('.content-wrapper')),
                            prevScrollAmount = 0,
                            scrollAmount;
                            
                        // Bind to scroll event
                        element.on('scroll', function(e) {
                            var adjustedHeight;
                            scrollAmount = parseInt(el.scrollTop / childElHeight);
                            
                            // Offset needed to keep items visible when scrolling
                            dimensions.offsetTop = scrollAmount * childElHeight;
                            
                            // Adjustments so when we scroll to top we at starting index
                            // when we scroll to bottom we are at last index of collection.
                            adjustedHeight = dimensions.containerHeight - dimensions.offsetTop;
                            
                            // true if we scrolled the height of one whole item
                            if (prevScrollAmount !== scrollAmount) {
                                $timeout(function(){
                                    
                                    // Start ng-repeat at next index
                                    scope.startAt = (scrollAmount * itemsPerRow);
                                    
                                    // Add new item to bottom of list for visual scrolling purposes
                                    scope.limitCount += itemsPerRow;
                                    
                                    // Adjust offsets to keep list visible when scrolling
                                    contentWrapper.css('padding-top', dimensions.offsetTop + 'px');
                                    contentWrapper.css('height', adjustedHeight + 'px');
                                    
                                    // Remove extra item added
                                    scope.limitCount -= itemsPerRow;
                                });
                                
                                // Keep track of last item we scrolled so we only
                                // take action once per item scrolled
                                prevScrollAmount = scrollAmount;
                            }
                        });
                    }
                }
            }
            
        }
    }
    CollectionRepeat.$inject = ["$timeout"];
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.colorwheel')
        .directive('enColorwheel', ComponentDirective);

    /**
     * @ngdoc directive
     * @name enColorwheel
     * @module enspire.ui.components.colorwheel
     * @restrict E
     * @description
     * `en-colorwheel` creates an interactive color wheel.
     *
     * @element en-colorwheel
     *
     * @param {string}      ng-model      Binds the value of the color wheel instance to the view. Expects a color value in hex format (Ex: #000000)
     * @param {number=}     [width=260]   Sets the size of the color wheel.  Since color wheels are square, the width also controls the height.
     * @param {string=}     [color='#3bc173']      Sets the initial color ONLY if there is no color value set by ngModel.
     *
     * @usage
     * ### Simple
     * <hljs lang="html">
     *   <en-colorwheel ng-model="data.myColorModel"></en-colorwheel>
     * </hljs>
     *
     */

    function ComponentDirective($compile, $timeout, $parse, $filter){
        return {
            restrict: 'E',
            require: '^ngModel',
            link    : postLink
        };

        function postLink($scope, $element, $attrs, $ngModel){
            var colorWheel;

            var defaults = {
                width: $attrs.width   || 260,
                color: $attrs.color   || '#3bc173'
            };

            $ngModel.$render = function(){
                if(!colorWheel) {
                    colorWheel = new ColorWheel($element, function(color){
                        safeApply($scope, function() {
                            $ngModel.$setViewValue(color);
                        });
                    }, {
                        color: $ngModel.$viewValue || defaults.color,
                        width: defaults.width
                    });
                }else{
                    colorWheel.setColor($ngModel.$viewValue);
                }
            };
        }
    }
    ComponentDirective.$inject = ["$compile", "$timeout", "$parse", "$filter"];

    var ColorWheel = function($container, callback, options) {
        var self = this;

        this.options = angular.extend({
            width: 260,
            wheelWidth: (options.width || 260) / 10,
            color: '#808080'
        }, options);

        this.$container = $container;
        // Initialize.
        this.initWidget();

        // Set linked elements/callback
        this.callback = callback;

        this.setColor(this.options.color);

        var HammerColorWheel = new Hammer(this.cnvOverlay[0]);

        HammerColorWheel.get('pan').set({
            direction: Hammer.DIRECTION_ALL,
            threshold: 5
        });

        HammerColorWheel.on('panstart tap press', function(event){
            self.mousedown(event);
        });

        HammerColorWheel.on('panmove', function(event){
            //ColorWheel.prototype.mousemove.call(self, event);
            self.mousemove(event);
        });

        HammerColorWheel.on('panend pressup', function(event){
            //ColorWheel.prototype.mouseup.call(self, event);
            self.mouseup(event);
        });

        $container.on('$destroy', function(){
            if(angular.isDefined(HammerColorWheel)){
                HammerColorWheel.destroy();
            }
        });

    };

    ColorWheel.prototype.updateValue = function() {
        if (this.value && this.value !== this.color) {
            this.setColor(this.value);
        }
        return this;
    };

    /**
     * Change color with HTML syntax #123456
     */
    ColorWheel.prototype.setColor = function(color) {
        var unpacked = unpack(color);
        if (this.color !== color && unpacked) {
            this.color = color;
            this.rgb = unpacked;
            this.hsl = RGBToHSL(this.rgb);
            this.updateDisplay();
        }
        return this;
    };

    /**
     * Change color with HSL triplet [0..1, 0..1, 0..1]
     */
    ColorWheel.prototype.setHSL = function(hsl) {
        this.hsl = hsl;
        this.rgb = HSLToRGB(hsl);
        this.color = pack(this.rgb);
        this.updateDisplay();
        return this;
    };

    /////////////////////////////////////////////////////

    /**
     * Initialize the color wheel.
     */
    ColorWheel.prototype.initWidget = function() {

        // Insert markup and size accordingly.
        var dim = {
            width: this.options.width+'px',
            height: this.options.width+'px'
        };

        this.wheelHtml    = angular.element('<div class="colorwheel" style="height:'+dim.height+'; width:'+dim.width+'; position: relative"></div>');
        this.solidFill   =  angular.element('<div class="colorwheel-solid" style="position:absolute;"></div>');
        this.cnvMask     =  angular.element('<canvas class="colorwheel-mask" height="'+dim.height+'" width="'+dim.width+'" style="height:'+dim.height+'; width:'+dim.width+'; position:absolute;"></canvas>');
        this.cnvOverlay  =  angular.element('<canvas class="colorwheel-overlay" height="'+dim.height+'" width="'+dim.width+'" style="height:'+dim.height+'; width:'+dim.width+'; position:absolute;"></canvas>');

        this.wheelHtml
            .append(this.solidFill)
            .append(this.cnvMask)
            .append(this.cnvOverlay);

        this.$container
            .empty()
            .append(this.wheelHtml);

        // Determine layout
        this.radius = (this.options.width - this.options.wheelWidth) / 2 - 1;
        this.square = Math.floor((this.radius - this.options.wheelWidth / 2) * 0.7) - 1;
        this.mid = Math.floor(this.options.width / 2);

        this.markerSize = this.options.wheelWidth * 0.3;

        this.solidFill.css({
            width: (this.square * 2 - 1)+'px',
            height: (this.square * 2 - 1)+'px',
            left: (this.mid - this.square)+'px',
            top: (this.mid - this.square)+'px'
        });

        // Set up drawing context.
        this.ctxMask = this.cnvMask[0].getContext('2d');
        this.ctxOverlay = this.cnvOverlay[0].getContext('2d');
        this.ctxMask.translate(this.mid, this.mid);
        this.ctxOverlay.translate(this.mid, this.mid);

        // Draw base layers.
        this.drawCircle();
        this.drawMask();

        return this;
    };

    /**
     * Draw the color wheel.
     */
    ColorWheel.prototype.drawCircle = function() {
        var tm = +(new Date());
        // Draw a hue circle with a bunch of gradient-stroked beziers.
        // Have to use beziers, as gradient-stroked arcs don't work.
        var n = 24,
                r = this.radius,
                w = this.options.wheelWidth,
                nudge = 8 / r / n * Math.PI, // Fudge factor for seams.
                m = this.ctxMask,
                angle1 = 0, color1, d1;
        m.save();
        m.lineWidth = w / r;
        m.scale(r, r);
        // Each segment goes from angle1 to angle2.
        for (var i = 0; i <= n; ++i) {
            var d2 = i / n,
                    angle2 = d2 * Math.PI * 2,
                    // Endpoints
                    x1 = Math.sin(angle1), y1 = -Math.cos(angle1),
                    x2 = Math.sin(angle2), y2 = -Math.cos(angle2),
                    // Midpoint chosen so that the endpoints are tangent to the circle.
                    am = (angle1 + angle2) / 2,
                    tan = 1 / Math.cos((angle2 - angle1) / 2),
                    xm = Math.sin(am) * tan, ym = -Math.cos(am) * tan,
                    // New color
                    color2 = pack(HSLToRGB([d2, 1, 0.5]));
            if (i > 0) {
                var grad = m.createLinearGradient(x1, y1, x2, y2);
                grad.addColorStop(0, color1);
                grad.addColorStop(1, color2);
                m.strokeStyle = grad;
                // Draw quadratic curve segment.
                m.beginPath();
                m.moveTo(x1, y1);
                m.quadraticCurveTo(xm, ym, x2, y2);
                m.stroke();
            }
            // Prevent seams where curves join.
            angle1 = angle2 - nudge;
            color1 = color2;
            d1 = d2;
        }
        m.restore();
        return this;
    };

    /**
     * Draw the saturation/luminance mask.
     */
    ColorWheel.prototype.drawMask = function() {
        // Iterate over sat/lum space and calculate appropriate mask pixel values.
        var size = this.square * 2, sq = this.square;
        function calculateMask(sizex, sizey, outputPixel) {
            var isx = 1 / sizex, isy = 1 / sizey;
            for (var y = 0; y <= sizey; ++y) {
                var l = 1 - y * isy;
                for (var x = 0; x <= sizex; ++x) {
                    var s = 1 - x * isx;
                    // From sat/lum to alpha and color (grayscale)
                    var a = 1 - 2 * Math.min(l * s, (1 - l) * s);
                    var c = (a > 0) ? ((2 * l - 1 + a) * .5 / a) : 0;
                    outputPixel(x, y, c, a);
                }
            }
        }

        // Method #1: direct pixel access (new Canvas).
        if (this.ctxMask.getImageData) {
            // Create half-resolution buffer.
            var sz = Math.floor(size / 2);
            var buffer = document.createElement('canvas');
            buffer.width = buffer.height = sz + 1;
            var ctx = buffer.getContext('2d');
            var frame = ctx.getImageData(0, 0, sz + 1, sz + 1);

            var i = 0;
            calculateMask(sz, sz, function(x, y, c, a) {
                frame.data[i++] = frame.data[i++] = frame.data[i++] = c * 255;
                frame.data[i++] = a * 255;
            });

            ctx.putImageData(frame, 0, 0);
            this.ctxMask.drawImage(buffer, 0, 0, sz + 1, sz + 1, -sq, -sq, sq * 2, sq * 2);
        }
        // Method #2: vertical DXImageTransform gradient strips (IE).
        else {
            var cache_last, cache, w = 6; // Each strip is 6 pixels wide.
            var sizex = Math.floor(size / w);
            // 6 vertical pieces of gradient per strip.
            calculateMask(sizex, 6, function(x, y, c, a) {
                if (x === 0) {
                    cache_last = cache;
                    cache = [];
                }
                c = Math.round(c * 255);
                a = Math.round(a * 255);
                // We can only start outputting gradients once we have two rows of pixels.
                if (y > 0) {
                    var c_last = cache_last[x][0],
                            a_last = cache_last[x][1],
                            color1 = packDx(c_last, a_last),
                            color2 = packDx(c, a),
                            y1 = Math.round(this.mid + ((y - 1) * .333 - 1) * sq),
                            y2 = Math.round(this.mid + (y * .333 - 1) * sq);
                    var cnvMaskInner = angular.element('<div>').css({
                        position: 'absolute',
                        filter: "progid:DXImageTransform.Microsoft.Gradient(StartColorStr=" + color1 + ", EndColorStr=" + color2 + ", GradientType=0)",
                        top: y1+'px',
                        height: (y2 - y1)+'px',
                        // Avoid right-edge sticking out.
                        left: (this.mid + (x * w - sq - 1))+'px',
                        width: (w - (x === sizex ? Math.round(w / 2) : 0))+'px'
                    }).appendTo(this.cnvMask);

                    this.cnvMask.append(cnvMaskInner);
                }
                cache.push([c, a]);
            });
        }
        return this;
    };

    /**
     * Draw the selection markers.
     */
    ColorWheel.prototype.drawMarkers = function() {
        // Determine marker dimensions
        var sz = this.options.width, lw = Math.ceil(this.markerSize / 4), r = this.markerSize - lw + 1;
        var angle = this.hsl[0] * 6.28,
                x1 = Math.sin(angle) * this.radius,
                y1 = -Math.cos(angle) * this.radius,
                x2 = 2 * this.square * (.5 - this.hsl[1]),
                y2 = 2 * this.square * (.5 - this.hsl[2]),
                c1 = this.invert ? '#fff' : '#000',
                c2 = this.invert ? '#000' : '#fff';
        var circles = [
            {x: x1, y: y1, r: r, c: '#000', lw: lw + 1},
            {x: x1, y: y1, r: this.markerSize, c: '#fff', lw: lw},
            {x: x2, y: y2, r: r, c: c2, lw: lw + 1},
            {x: x2, y: y2, r: this.markerSize, c: c1, lw: lw}
        ];

        // Update the overlay canvas.
        this.ctxOverlay.clearRect(-this.mid, -this.mid, sz, sz);
        for (var i = 0; i < circles.length; i++) {
            var c = circles[i];
            this.ctxOverlay.lineWidth = c.lw;
            this.ctxOverlay.strokeStyle = c.c;
            this.ctxOverlay.beginPath();
            this.ctxOverlay.arc(c.x, c.y, c.r, 0, Math.PI * 2, true);
            this.ctxOverlay.stroke();
        }
        return this;
    };

    /**
     * Update the markers and styles
     */
    ColorWheel.prototype.updateDisplay = function() {
        // Determine whether labels/markers should invert.
        this.invert = (this.rgb[0] * 0.3 + this.rgb[1] * .59 + this.rgb[2] * .11) <= 0.6;

        // Update the solid background fill.
        this.solidFill.css('backgroundColor', pack(HSLToRGB([this.hsl[0], 1, 0.5])));

        // Draw markers
        this.drawMarkers();

        // Linked callback
        this.callback.call(this, this.color);

        return this;
    };

    /**
     * Helper for returning coordinates relative to the center.
     */
    ColorWheel.prototype.widgetCoords = function(event) {
        return {
            x: event.srcEvent.layerX - this.mid,
            y: event.srcEvent.layerY - this.mid
        };
    };

    /**
     * Mousedown handler
     */
    ColorWheel.prototype.mousedown = function(event) {
        // Capture mouse
        if (!this.dragging) {
            this.dragging = true;
        }

        // Update the stored offset for the widget.
        //this.offset = this.$container.offset();
        this.offset = {
            top: this.$container[0].offsetTop,
            left:this.$container[0].offsetLeft
        };

        // Check which area is being dragged
        var pos = this.widgetCoords(event);
        this.circleDrag = Math.max(Math.abs(pos.x), Math.abs(pos.y)) > (this.square + 2);

        // Process
        this.mousemove(event);
        return false;
    };

    /**
     * Mousemove handler
     */
    ColorWheel.prototype.mousemove = function(event) {
        // Get coordinates relative to color picker center
        var pos = this.widgetCoords(event);

        // Set new HSL parameters
        if (this.circleDrag) {
            var hue = Math.atan2(pos.x, -pos.y) / 6.28;
            this.setHSL([(hue + 1) % 1, this.hsl[1], this.hsl[2]]);
        }
        else {
            var sat = Math.max(0, Math.min(1, -(pos.x / this.square / 2) + .5));
            var lum = Math.max(0, Math.min(1, -(pos.y / this.square / 2) + .5));
            this.setHSL([this.hsl[0], sat, lum]);
        }
        return false;
    };

    /**
     * Mouseup handler
     */
    ColorWheel.prototype.mouseup = function() {
        this.dragging = false;
    };


    /* Various color utility functions */
    function dec2hex(x) {
        return (x < 16 ? '0' : '') + x.toString(16);
    }

    function packDx(c, a) {
        return '#' + dec2hex(a) + dec2hex(c) + dec2hex(c) + dec2hex(c);
    }

    function pack(rgb) {
        var r = Math.round(rgb[0] * 255);
        var g = Math.round(rgb[1] * 255);
        var b = Math.round(rgb[2] * 255);
        return '#' + dec2hex(r) + dec2hex(g) + dec2hex(b);
    }

    function unpack(color) {
        var x;
        if (color.length === 7) {
            x = function(i) {
                return parseInt(color.substring(i, i + 2), 16) / 255;
            };
            return [x(1), x(3), x(5)];
        }
        else if (color.length === 4) {
            x = function(i) {
                return parseInt(color.substring(i, i + 1), 16) / 15;
            };
            return [x(1), x(2), x(3)];
        }
    }

    function HSLToRGB(hsl) {
        var m1, m2;
        var h = hsl[0], s = hsl[1], l = hsl[2];
        m2 = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
        m1 = l * 2 - m2;
        return [
            hueToRGB(m1, m2, h + 0.33333),
            hueToRGB(m1, m2, h),
            hueToRGB(m1, m2, h - 0.33333)
        ];
    }

    function hueToRGB(m1, m2, h) {
        h = (h + 1) % 1;
        if (h * 6 < 1)
            return m1 + (m2 - m1) * h * 6;
        if (h * 2 < 1)
            return m2;
        if (h * 3 < 2)
            return m1 + (m2 - m1) * (0.66666 - h) * 6;
        return m1;
    }

    function RGBToHSL(rgb) {
        var r = rgb[0], g = rgb[1], b = rgb[2],
                min = Math.min(r, g, b),
                max = Math.max(r, g, b),
                delta = max - min,
                h = 0,
                s = 0,
                l = (min + max) / 2;
        if (l > 0 && l < 1) {
            s = delta / (l < 0.5 ? (2 * l) : (2 - 2 * l));
        }
        if (delta > 0) {
            if (max === r && max !== g)
                h += (g - b) / delta;
            if (max === g && max !== b)
                h += (2 + (b - r) / delta);
            if (max === b && max !== r)
                h += (4 + (r - g) / delta);
            h /= 6;
        }
        return [h, s, l];
    }

    var safeApply = function($scope, fn) {
        var phase = $scope.$root.$$phase;
        if (phase === '$apply' || phase === '$digest') {
            if (fn && (typeof (fn) === 'function')) {
                fn();
            }
        } else {
            $scope.$root.$apply(fn);
        }
    };
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.content')
        .directive('enContent', contentDirective);

    /**
     * @ngdoc directive
     * @name enContent
     * @module enspire.ui.components.content
     *
     * @restrict E
     *
     * @description
     * The `<en-content>` directive...
     *
     * ## CSS Themes
     *
     * Class            | Property          | Variable
     * -----------------| ------------------| ----------------------
     * highlight-dark   | background-color  | $content-highlight-dark-bg-color
     *                  | padding           | $content-highlight-dark-padding
     * highlight-light  | background-color  | $content-highlight-light-bg-color
     *                  | padding           | $content-highlight-light-padding
     *
     */
    function contentDirective() {
        return {
            restrict: 'E',
            link: postLink
        };

        function postLink($scope, $element, $attrs, $controller) {
            angular.isDefined($attrs.theme) ? $element.addClass($attrs.theme) : "";
        }
    }

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    //angular.module('enspire.ui.components.control').directive('enControl', ControlDirective);

    /**
     * @ngdoc directive
     * @name enControl
     * @module enspire.ui.components.control
     * @restrict E
     * @element en-control
     * @description
     * `en-control` is a wrapper for form controls and their standard HTML `<label>` elements.  
     *
     * @usage
     * 
     * ### Standard Control
     * <hljs lang="html">
     *  <en-control>
     *      <label>Control Label</label>
     *      <input type="text" name="demoControl" ng-model="demoControlValue" />
     *  </en-control>
     * </hljs>
     *
     * 
     * ### Inline Control
     * <hljs lang="html">
     *  <en-control class="inline">
     *      <label>Control Label</label>
     *      <input type="text" name="demoControl" ng-model="demoControlValue" />
     *  </en-control>
     * </hljs>
     *
     */
    
    //function ControlDirective(){
    //    return {
    //        restrict    : 'E',
    //        link        : postLink
    //    };
    //    
    //    function postLink($scope, $element, $attrs){
    //        
    //    }
    //}
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';
    angular.module('enspire.ui.components.correlation').directive('enCorrelation', CorrelationDirective);

    /**
     * @ngdoc directive
     * @name enCorrelation
     * @module enspire.ui.components.correlation
     * @restrict E
     * @description
     * `en-correlation` creates a style correlation input drop down.
     *
     * @element en-correlation
     *
     * @param {src=}    src      Causes `en-correlation` to display an correlation drop down returned by apiObject. 
     *
     * @usage
     * ### As Link correlation
     * <hljs lang="html">
     *   <en-correlation src="correlationName" ngModel="">
     *   </en-correlation>
     * </hljs>
     * 
     * 
     * 
     */
    
    function CorrelationDirective($enApi, $http, $correlationService){

        return {
            replace: true,
            template :' <select name="correlationName.id" '+
                            'ng-options="cVal as correlationName.key[$index] for ($index,cVal) in correlationName.value"'+
                            '> <option value="">Select Item</option> </select>',
               require:'ngModel',
               scope:{
                src:'@'
                
            },

            link: function (scope, element, attrs, ngModel) {

                var correlationServiceHttp =  $enApi.object({
                            name: 'correlationName',
                            path: '/api/v1/correlation/'+scope.src,
                            method: 'get'
                });
            
                correlationServiceHttp.get().then(function(data){
                  scope.correlationName = data;
                  if (scope.correlationName.type !== 'ManyToMany'){
                    console.log('##Correlation Error: Sorry only the type ManyToMany is supported at this time');
                  }
                },function(){
                
                });

                element.on('change', function(){
                    ngModel.$setViewValue(ngModel.$viewValue);
                    scope.$apply();
                });
            },
        };
    }
    CorrelationDirective.$inject = ["$enApi", "$http", "$correlationService"];
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.datepicker')
        .directive('enDatePicker', DatePickerDirective);

    /**
     * @ngdoc directive
     * @name enDatePicker
     * @module enspire.ui.components.datepicker
     * @restrict A
     * @scope
     * @description
     * `en-date-picker` creates a styled datePicker element.
     *
     * @param {string}      ng-model                    Assignable angular expression to bind the date to.
     * @param {string=}     [date-display=MM/dd/yyyy]   Sets the displayed date format shown in a datePicker's input.
     * @param {string=}     [date-output=UTC]           Sets the date format to be output to a backend service or server.
     * @param {string=}     date-min                    If set, will disallow selecting a date earlier than the date set.
     * @param {string=}     date-max                    If set, will disallow selecting a date later than the date set.
     *
     * @usage
     * <hljs lang="html">
     *   <input
     *          type="text"
     *          name="mainDate"
     *          ng-model="demo.mainDate"
     *          en-date-picker
     *          date-min="{{demo.startDate}}"
     *          date-max="{{demo.endDate}}"
     *          date-display="{{demo.displayFormat}}"
     *          date-output="{{demo.outputFormat}}">
     *   </input>
     * </hljs>
     *
     *
     *
     */




    function DatePickerDirective($window, $document, $compile, $locale, $filter, $timeout, $enPosition, $enDimensions, $enTouch, $enDatePicker, $enPopover){

        var $dp = $enDatePicker;
        var $defaults = $dp.defaults;

        return {
            restrict    : 'A',
            require     : ['ngModel'],
            scope       : {
                model:'=ngModel'
            },
            link        : postLink
        };



        function postLink($scope, $element, $attrs, $ctrl){
            //angular.isDefined($attrs.href)
            var millisecondsInDay   = 86400000;

            //$scope.date           = $ngModel.$viewValue;

            var $calendar,
                $ngModel          = $ctrl[0],
                dateOutput        = $attrs.dateOutput  || $defaults.dateOutput,
                dateDisplay       = $attrs.dateDisplay || $defaults.dateDisplay,
                dateRangeType     = $attrs.dateRangeType || $defaults.dateRangeType,

                dateFormat          = $defaults.dateDisplay,//angular.isDefined($attrs.dateFormat) ? $attrs.dateFormat : 'MM/dd/yyyy',
                dateMin             = $attrs.dateMin,
                dateMax             = $attrs.dateMax,
                date                = $scope.model || new Date(),
                _mouseOver          = false,
                _mouseOverInput     = false,
                datetime            = $locale.DATETIME_FORMATS,
                $template           = $defaults.template();

            $scope.$watch('model',function(nv,ov){
                if(nv && nv!==ov){
                    date = nv;
                    $scope.month = $filter('date')(date, 'MMMM');        //ex: December-November
                    $scope.monthNumber = Number($filter('date')(date, 'MM'));  //ex: 01-12
                    $scope.day = Number($filter('date')(date, 'dd'));  //ex: 01-31
                    $scope.year = Number($filter('date')(date, 'yyyy'));//ex: 2014
                    //$scope.time = $filter('date')(date, 'HH:mm:ss:sss');
                }
            });

            $scope.month        = $filter('date')(date, 'MMMM');        //ex: December-November
            $scope.monthNumber  = Number($filter('date')(date, 'MM'));  //ex: 01-12
            $scope.day          = Number($filter('date')(date, 'dd'));  //ex: 01-31
            $scope.year         = Number($filter('date')(date, 'yyyy'));//ex: 2014
            //$scope.time         = $filter('date')(date, 'HH:mm:ss:sss');
            $scope.months       = datetime.MONTH;


            $scope.daysInString = ['0', '1', '2', '3', '4', '5', '6'].map(function(el){
                return $filter('date')(new Date(new Date('06/08/2014').valueOf() + millisecondsInDay * el), 'EEE');
            });

            $scope.showYearsPagination = false;

            $timeout(function(){
            $calendar = $compile(angular.element($template))($scope);
               $element
                .bind('focus click', function() {
                    _mouseOverInput = true;
                    $scope.showCalendar();
                }).bind('blur focusout', function() {
                    _mouseOverInput = false;
                       if(!_mouseOver){
                           $scope.hideCalendar();
                       }
                });

                $calendar.bind('mouseenter', function() {
                    _mouseOver = true;
                }).bind('mouseleave', function() {
                    _mouseOver = false;
                });

                angular.element($window).bind('click', function() {
                    if (!_mouseOver && !_mouseOverInput) {
                        $scope.hideCalendar();
                    }
                });
            });

            //Format viewValue when changed and save to modelValue
            $ngModel.$parsers.push(function(val){
                return formatOutputValue(val);
            });

            //Format modelValue when changed and save to viewValue
            $ngModel.$formatters.push(function(val){
                return formatDisplayValue(val);
            });

            $scope.setInputValue = function() {
                var inputVal = $scope.year + '/' + $scope.monthNumber + '/' + $scope.day;
                // var inputDate = new Date(inputVal+' '+$scope.time);
                var inputDate = adjustDateRange(new Date(inputVal));

                if ($scope.withinRange(inputVal)) {
                    if(dateDisplay==='UTC' || dateDisplay==='UNIX'){
                        inputDate = $dp[dateDisplay==='UTC' ? 'toUTC' : 'toUNIX'](inputDate);
                    }else{
                        inputDate = $filter('date')(inputDate, dateDisplay);
                    }
                    $ngModel.$setViewValue(inputDate);
                    $ngModel.$render();
                } else {
                    return false;
                }
            };

            function convertTimestamp(date){
                var rtnDate = date;
                if(date && !isNaN(Number(date))){
                    if((date).toString().length < 13){
                        date *= 1000;
                    }
                    date = Number(date);
                    rtnDate = new Date(date);
                }
                return rtnDate;
            }

            function formatDisplayValue(date){
                if(!date) return;
                date = adjustDateRange((date instanceof Date) ? date : new Date(date));

                if(dateDisplay==='UTC' || dateDisplay==='UNIX'){
                    date = convertTimestamp(date);
                    return $dp[dateDisplay==='UTC' ? 'toUTC' : 'toUNIX'](date);
                }else{
                    return $filter('date')(date, dateDisplay);
                }
            }

            function formatOutputValue(date){
                if(!date) return '';
                date = adjustDateRange((date instanceof Date) ? date : new Date(date));
                if(dateOutput==='UTC' || dateOutput==='UNIX'){
                    date = convertTimestamp(date);
                    return $dp[dateOutput==='UTC' ? 'toUTC' : 'toUNIX'](date);
                }else{
                    return $filter('date')(date, dateOutput);
                }
            }

            function adjustDateRange(date){
                if(dateRangeType){
                    (dateRangeType.toLowerCase()==='start') ? date.setHours(0,0,0,0) :  date.setHours(23,59,59,999);
                }
                return date;
            }




            $scope.showCalendar = function() {
                $scope.showYearsPagination = false;
                var pos = $enPosition.rect($element);

                angular.element($document[0].body).find('en-win').append($calendar);

                $enDimensions.setOffset($calendar[0], {
                    top: pos.bottom,
                    left: pos.left
                });

                $calendar.addClass('datepicker-open');
            };

            $scope.hideCalendar = function() {
                $calendar.removeClass('datepicker-open').detach();
            };

            $scope.nextMonth = function() {
                if ($scope.monthNumber === 12) {
                    $scope.monthNumber = 1;
                    $scope.nextYear();
                } else {
                    $scope.monthNumber += 1;
                }
                $scope.month = $filter('date')(new Date($scope.year + '/' + $scope.monthNumber + '/' + $scope.day), 'MMMM');
                $scope.setDaysInMonth($scope.monthNumber, $scope.year);
                $scope.setInputValue();
            };

            $scope.prevMonth = function() {
                if ($scope.monthNumber === 1) {
                    $scope.monthNumber = 12;
                    $scope.prevYear();
                } else {
                    $scope.monthNumber -= 1;
                }
                $scope.month = $filter('date')(new Date($scope.year + '/' + $scope.monthNumber + '/' + $scope.day), 'MMMM');
                $scope.setDaysInMonth($scope.monthNumber, $scope.year);
                $scope.setInputValue();
            };

            $scope.setYear = function(year) {
                year = Number(year);
                if($scope.withinRange(year + '/' + $scope.monthNumber + '/' + $scope.day)){
                    $scope.year = year;
                    $scope.setDaysInMonth($scope.monthNumber, $scope.year);
                    $scope.showYearsPagination = false;
                    $scope.setInputValue();
                    $scope.paginateYears(year);
                }
            };

            $scope.nextYear = function() {
                $scope.year = Number($scope.year) + 1;
                $scope.setInputValue();
            };

            $scope.prevYear = function() {
                $scope.year = Number($scope.year) - 1;
                $scope.setInputValue();
            };



            $scope.setDaysInMonth = function(month, year) {
                var i,
                    limitDate = new Date(year, month, 0).getDate(),
                    firstDayMonthNumber = new Date(year + '/' + month + '/' + 1).getDay(),
                    lastDayMonthNumber = new Date(year + '/' + month + '/' + limitDate).getDay(),
                    prevMonthDays = [],
                    nextMonthDays = [],
                    howManyNextDays,
                    howManyPreviousDays,
                    monthAlias;

                $scope.days = [];

                for (i = 1; i <= limitDate; i += 1) {
                    $scope.days.push(i);
                }
                //get previous month days is first day in month is not Sunday
                if (firstDayMonthNumber !== 0) {

                    howManyPreviousDays = firstDayMonthNumber;

                    //get previous month
                    if (Number(month) === 1) {
                        monthAlias = 12;
                    } else {
                        monthAlias = month - 1;
                    }
                    //return previous month days
                    for (i = 1; i <= new Date(year, monthAlias, 0).getDate(); i += 1) {
                        prevMonthDays.push(i);
                    }
                    //attach previous month days
                    $scope.prevMonthDays = prevMonthDays.slice(-howManyPreviousDays);
                } else {
                    //no need for it
                    $scope.prevMonthDays = [];
                }

                //get next month days is first day in month is not Sunday
                if (lastDayMonthNumber < 6) {

                    howManyNextDays = 6 - lastDayMonthNumber;
                    //get previous month

                    //return next month days
                    for (i = 1; i <= howManyNextDays; i += 1) {
                        nextMonthDays.push(i);
                    }
                    //attach previous month days
                    $scope.nextMonthDays = nextMonthDays;
                } else {
                    //no need for it
                    $scope.nextMonthDays = [];
                }
            };

            $scope.setDatepickerDay = function(day) {
                day = Number(day);
                if($scope.withinRange($scope.year + '/' + $scope.monthNumber + '/' + day)){
                    $scope.day = Number(day);
                    $scope.setInputValue();
                    $scope.hideCalendar();
                }
            };

            $scope.paginateYears = function(startingYear) {
                $scope.paginationYears = [];
                var i;
                for (i = 12/* Years */; i > 0; i -= 1) {
                    $scope.paginationYears.push(startingYear - i);
                }
                for (i = 0; i < 13/* Years */; i += 1) {
                    $scope.paginationYears.push(startingYear + i);
                }
            };

            $scope.withinRange = function(date) {
                if(!date) date = $scope.year + '/' + $scope.monthNumber + '/' + $scope.day;
                var currentDateVal = date;
                return ($scope.isSelectableMinDate(currentDateVal) && $scope.isSelectableMaxDate(currentDateVal));
            };

            $scope.isSelectableMinDate = function(date) {
                if (!!dateMin && !!new Date(dateMin) && (new Date(date).getTime() < new Date(dateMin).getTime())) {
                    return false;
                }
                return true;
            };

            $scope.isSelectableMaxDate = function(date) {
                if (!!dateMax && !!new Date(dateMax) && (new Date(date).getTime() > new Date(dateMax).getTime())) {
                    return false;
                }
                return true;
            };

            $scope.isSelectableMaxYear = function(year) {
                if (!!dateMax && (year > new Date(dateMax).getFullYear())) {
                    return false;
                }
                return true;
            };

            $scope.isSelectableMinYear = function(year) {
                if (!!dateMin && (year < new Date(dateMin).getFullYear())) {
                    return false;
                }
                return true;
            };

            $scope.paginateYears($scope.year);
            $scope.setDaysInMonth($scope.monthNumber, $scope.year);


            $scope.$on('$destroy', function(){ $calendar.remove(); });

            $attrs.$observe('dateOutput', function(val){
                dateOutput = val.trim() || $defaults.dateOutput;
                $ngModel.$$parseAndValidate();
            });
            $attrs.$observe('dateDisplay', function(val){
                dateDisplay = val.trim() || $defaults.dateDisplay;
                if($scope.model){
                    $scope.setInputValue();
                }
            });

            $attrs.$observe('dateMin', function(val){
                dateMin = val.trim() || '';
                if(dateMin) dateMin = convertTimestamp(dateMin);
            });

            $attrs.$observe('dateMax', function(val){
                dateMax = val.trim() || '';
                if(dateMax) dateMax = convertTimestamp(dateMax);
            });

        }
    }
    DatePickerDirective.$inject = ["$window", "$document", "$compile", "$locale", "$filter", "$timeout", "$enPosition", "$enDimensions", "$enTouch", "$enDatePicker", "$enPopover"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.datepicker')
        .provider('$enDatePicker', DatePickerProvider);
    

/**
* @ngdoc service
* @name $enDatePicker
* @module enspire.ui.components.datepicker
*
* @description
* Manages tab containers and selected tabs.
* 
*/
    

    function DatePickerProvider() {
        var self = this;
    
        var defaults = this.defaults = {};
    
        DatePickerFactory.$inject = ["$window", "$document", "$compile", "$locale", "$filter", "$timeout", "$enPosition", "$enDimensions", "$enTouch"];
        return {
            defaults: defaults,
            $get    : DatePickerFactory
        };
    
        function DatePickerFactory($window, $document, $compile, $locale, $filter, $timeout, $enPosition, $enDimensions, $enTouch){
            
            return {
                defaults            : self.defaults,
                toUTC               : toUTC,
                toUNIX              : toUNIX
            };

            function toUTC(date){
                return new Date(date).getTime();
            }
            function toUNIX(date){
                return Math.round(new Date(date).getTime() / 1000);
            }
        }
    }
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.dnd')
        .directive('dndDraggable', ComponentDirective);

    /**
    * @ngdoc directive
    * @name dndDraggable
    * @module enspire.ui.components.dnd
    * @restrict A
    * @description
    * Use the `dnd-draggable` attribute to make an element draggable.
    *
    * @param {object}       dnd-draggable       Required attribute. The value has to be an object that represents the data
    *                                           of the $element. In case of a drag and drop operation the object will be
    *                                           serialized and unserialized on the receiving end.
    * @param {string=}      [dnd-effect-allowed=move]  Use this attribute to limit the operations that can be performed.
    * ### Options
    * | Name              | Description           |
    * | ----------------- | --------------------- |
    * | __move__          | The drag operation will move the $element. This is the default. |
    * | __copy__          | The drag operation will copy the $element. Shows a copy cursor. |
    * | __copyMove__      | The user can choose between copy and move by pressing the ctrl or shift key. *Not supported in IE:* In
    * Internet Explorer this option will be the same as "copy". _Not fully supported in Chrome on Windows:_ In the Windows version
    * of Chrome the cursor will always be the move cursor. However, when the user drops an $element and has the ctrl key
    * pressed, we will perform a copy anyways. |
    *
    * HTML5 also specifies the "link" option, but this library does not actively support it yet, so use it at your own risk.
    * @param {function=}    dnd-selected        Callback that is invoked when the $element was clicked but not dragged.
    *                                           The original click event will be provided in the local event variable.
    * @param {function=}    dnd-moved           Callback that is invoked when the $element was moved. Usually you will
    *                                           remove your $element from the original list in this callback, since the
    *                                           directive is not doing that for you automatically. The original dragend
    *                                           event will be provided in the local event variable.
    * @param {function=}    dnd-canceled        Callback that is invoked if the $element was dragged, but the operation was
    *                                           canceled and the $element was not dropped. The original dragend event will
    *                                           be provided in the local event variable.
    * @param {function=}    dnd-copied          Same as dnd-moved, just that it is called when the $element was copied
    *                                           instead of moved. The original dragend event will be provided in the local
    *                                           event variable.
    * @param {function=}    dnd-dragstart       Callback that is invoked when the $element was dragged. The original
    *                                           dragstart event will be provided in the local event variable.
    * @param {function=}    dnd-dragend         Callback that is invoked when the drag operation ended. Available local
    *                                           variables are `event` and `dropEffect`.
    * @param {string=}      dnd-type            Use this attribute if you have different kinds of items in your
    *                                           application and you want to limit which items can be dropped into which
    *                                           lists. Combine with dnd-allowed-types on the dnd-list(s). This attribute
    *                                           should evaluate to a string, although this restriction is not enforced.
    * @param {expression=}  dnd-disable-if     You can use this attribute to dynamically disable the draggability of the
    *                                           $element. This is useful if you have certain list items that you don't want
    *                                           to be draggable, or if you want to disable drag & drop completely without
    *                                           having two different code branches (e.g. only allow for admins).
    *
    * > __Note:__ If your $element is not draggable, the user is probably able to select text or images inside of it. Since a selection is always draggable, this breaks your UI. You most likely want to disable user selection via CSS (see user-select).
    */

    function ComponentDirective($parse, $timeout, dndDropEffectWorkaround, dndDragTypeWorkaround){

        return {
            restrict: 'A',
            link    : postLink
        };

        function postLink($scope, $element, $attrs){
            // Set the HTML5 draggable attribute on the $element
            $element.attr("draggable", "true");

            // If the dnd-disable-if attribute is set, we have to watch that
            if($attrs.dndDisableIf){
                $scope.$watch($attrs.dndDisableIf, function(disabled){
                    $element.attr("draggable", !disabled);
                });
            }

            /**
             * When the drag operation is started we have to prepare the dataTransfer object,
             * which is the primary way we communicate with the target $element
             */
            $element.on('dragstart', function(event){
                event = event.originalEvent || event;

                // Serialize the data associated with this $element. IE only supports the Text drag type
                event.dataTransfer.setData("Text", angular.toJson($scope.$eval($attrs.dndDraggable)));

                // Only allow actions specified in dnd-effect-allowed attribute
                event.dataTransfer.effectAllowed = $attrs.dndEffectAllowed || "move";

                // Add CSS classes. See documentation above
                $element.addClass("dndDragging");
                $timeout(function(){
                    $element.addClass("dndDraggingSource");
                }, 0);

                // Workarounds for stupid browsers, see description below
                dndDropEffectWorkaround.dropEffect = "none";
                dndDragTypeWorkaround.isDragging   = true;

                // Save type of item in global state. Usually, this would go into the dataTransfer
                // typename, but we have to use "Text" there to support IE
                dndDragTypeWorkaround.dragType = $attrs.dndType ? $scope.$eval($attrs.dndType) : undefined;

                // Invoke callback
                $parse($attrs.dndDragstart)($scope, {event: event});

                event.stopPropagation();
            });

            /**
             * The dragend event is triggered when the $element was dropped or when the drag
             * operation was aborted (e.g. hit escape button). Depending on the executed action
             * we will invoke the callbacks specified with the dnd-moved or dnd-copied attribute.
             */
            $element.on('dragend', function(event){
                event = event.originalEvent || event;

                // Invoke callbacks. Usually we would use event.dataTransfer.dropEffect to determine
                // the used effect, but Chrome has not implemented that field correctly. On Windows
                // it always sets it to 'none', while Chrome on Linux sometimes sets it to something
                // else when it's supposed to send 'none' (drag operation aborted).
                var dropEffect = dndDropEffectWorkaround.dropEffect;
                $scope.$apply(function(){
                    switch(dropEffect){
                        case "move":
                            $parse($attrs.dndMoved)($scope, {event: event});
                            break;
                        case "copy":
                            $parse($attrs.dndCopied)($scope, {event: event});
                            break;
                        case "none":
                            $parse($attrs.dndCanceled)($scope, {event: event});
                            break;
                    }
                    $parse($attrs.dndDragend)($scope, {event: event, dropEffect: dropEffect});
                });

                // Clean up
                $element.removeClass("dndDragging");
                $timeout(function(){
                    $element.removeClass("dndDraggingSource");
                }, 0);
                dndDragTypeWorkaround.isDragging = false;
                event.stopPropagation();
            });

            /**
             * When the $element is clicked we invoke the callback function
             * specified with the dnd-selected attribute.
             */
            $element.on('click', function(event){
                if(!$attrs.dndSelected){
                    return;
                }

                event = event.originalEvent || event;
                $scope.$apply(function(){
                    $parse($attrs.dndSelected)($scope, {event: event});
                });

                // Prevent triggering dndSelected in parant elements.
                event.stopPropagation();
            });

            /**
             * Workaround to make $element draggable in IE9
             */
            $element.on('selectstart', function(){
                if(this.dragDrop) this.dragDrop();
            });

        }

    }
    ComponentDirective.$inject = ["$parse", "$timeout", "dndDropEffectWorkaround", "dndDragTypeWorkaround"];


})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.dnd')
        .directive('dndDropzone', ComponentDirective);

    /**
    * @ngdoc directive
    * @name dndDraggable
    * @module enspire.ui.components.dnd
    * @restrict A
    * @description
    * Use the `dnd-draggable` attribute to make an element draggable.
    *
    * @param {object}       dnd-draggable       Required attribute. The value has to be an object that represents the data
    *                                           of the $element. In case of a drag and drop operation the object will be
    *                                           serialized and unserialized on the receiving end.
    * @param {string=}      [dnd-effect-allowed=move]  Use this attribute to limit the operations that can be performed.
    * ### Options
    * | Name              | Description           |
    * | ----------------- | --------------------- |
    * | __move__          | The drag operation will move the $element. This is the default. |
    * | __copy__          | The drag operation will copy the $element. Shows a copy cursor. |
    * | __copyMove__      | The user can choose between copy and move by pressing the ctrl or shift key. *Not supported in IE:* In
    * Internet Explorer this option will be the same as "copy". _Not fully supported in Chrome on Windows:_ In the Windows version
    * of Chrome the cursor will always be the move cursor. However, when the user drops an $element and has the ctrl key
    * pressed, we will perform a copy anyways. |
    *
    * HTML5 also specifies the "link" option, but this library does not actively support it yet, so use it at your own risk.
    * @param {function=}    dnd-selected        Callback that is invoked when the $element was clicked but not dragged.
    *                                           The original click event will be provided in the local event variable.
    * @param {function=}    dnd-moved           Callback that is invoked when the $element was moved. Usually you will
    *                                           remove your $element from the original list in this callback, since the
    *                                           directive is not doing that for you automatically. The original dragend
    *                                           event will be provided in the local event variable.
    * @param {function=}    dnd-canceled        Callback that is invoked if the $element was dragged, but the operation was
    *                                           canceled and the $element was not dropped. The original dragend event will
    *                                           be provided in the local event variable.
    * @param {function=}    dnd-copied          Same as dnd-moved, just that it is called when the $element was copied
    *                                           instead of moved. The original dragend event will be provided in the local
    *                                           event variable.
    * @param {function=}    dnd-dragstart       Callback that is invoked when the $element was dragged. The original
    *                                           dragstart event will be provided in the local event variable.
    * @param {function=}    dnd-dragend         Callback that is invoked when the drag operation ended. Available local
    *                                           variables are `event` and `dropEffect`.
    * @param {string=}      dnd-type            Use this attribute if you have different kinds of items in your
    *                                           application and you want to limit which items can be dropped into which
    *                                           lists. Combine with dnd-allowed-types on the dnd-list(s). This attribute
    *                                           should evaluate to a string, although this restriction is not enforced.
    * @param {expression=}  dnd-disable-if     You can use this attribute to dynamically disable the draggability of the
    *                                           $element. This is useful if you have certain list items that you don't want
    *                                           to be draggable, or if you want to disable drag & drop completely without
    *                                           having two different code branches (e.g. only allow for admins).
    *
    * > __Note:__ If your $element is not draggable, the user is probably able to select text or images inside of it. Since a selection is always draggable, this breaks your UI. You most likely want to disable user selection via CSS (see user-select).
    */

    function ComponentDirective($parse, $timeout, dndDropEffectWorkaround, dndDragTypeWorkaround){

        return {
            restrict: 'A',
            link    : postLink
        };

        function postLink($scope, $element, $attrs){
            // While an $element is dragged over the dropzone, this placeholder element is inserted
            // at the location where the element would be inserted after dropping
            var placeholder     = getPlaceholderElement();
            var placeholderNode = placeholder[0];
            var listNode        = $element[0];
            placeholder.remove();

            var horizontal      = $attrs.dndHorizontalList && $scope.$eval($attrs.dndHorizontalList);
            var externalSources = $attrs.dndExternalSources && $scope.$eval($attrs.dndExternalSources);

            /**
             * The dragover event is triggered "every few hundred milliseconds" while an $element
             * is being dragged over our list, or over a child $element.
             */
            $element.on('dragover', function(event){
                event = event.originalEvent || event;

                if(!isDropAllowed(event)){
                    return true;
                }

                // First of all, make sure that the placeholder is shown
                // This is especially important if the list is empty
                if(placeholderNode.parentNode != listNode){
                    $element.append(placeholder);
                }

                if(event.target !== listNode){
                    // Try to find the node direct directly below the list node.
                    var listItemNode = event.target;
                    while(listItemNode.parentNode !== listNode && listItemNode.parentNode){
                        listItemNode = listItemNode.parentNode;
                    }

                    if(listItemNode.parentNode === listNode && listItemNode !== placeholderNode){
                        // If the mouse pointer is in the upper half of the child $element,
                        // we place it before the child $element, otherwise below it.
                        if(isMouseInFirstHalf(event, listItemNode)){
                            listNode.insertBefore(placeholderNode, listItemNode);
                        }else{
                            listNode.insertBefore(placeholderNode, listItemNode.nextSibling);
                        }
                    }
                }else{
                    // This branch is reached when we are dragging directly over the list $element.
                    // Usually we wouldn't need to do anything here, but the IE does not fire it's
                    // events for the child $element, only for the list directly. Therefore we repeat
                    // the positioning algorithm for IE here.
                    if(isMouseInFirstHalf(event, placeholderNode, true)){
                        // Check if we should move the placeholder $element one spot towards the top.
                        // Note that display none elements will have offsetTop and offsetHeight set to
                        // zero, therefore we need a special check for them.
                        while(placeholderNode.previousElementSibling
                        && (isMouseInFirstHalf(event, placeholderNode.previousElementSibling, true)
                        || placeholderNode.previousElementSibling.offsetHeight === 0)){
                            listNode.insertBefore(placeholderNode, placeholderNode.previousElementSibling);
                        }
                    }else{
                        // Check if we should move the placeholder $element one spot towards the bottom
                        while(placeholderNode.nextElementSibling && !isMouseInFirstHalf(event, placeholderNode.nextElementSibling, true)){
                            listNode.insertBefore(placeholderNode,
                                placeholderNode.nextElementSibling.nextElementSibling);
                        }
                    }
                }

                // At this point we invoke the callback, which still can disallow the drop.
                // We can't do this earlier because we want to pass the index of the placeholder.
                if($attrs.dndDragover && !invokeCallback($attrs.dndDragover, event, getPlaceholderIndex())){
                    return stopDragover();
                }

                $element.addClass("dndDragover");
                event.preventDefault();
                event.stopPropagation();
                return false;
            });

            /**
             * When the $element is dropped, we use the position of the placeholder $element as the
             * position where we insert the transferred data. This assumes that the list has exactly
             * one child $element per array $element.
             */
            $element.on('drop', function(event){
                event = event.originalEvent || event;

                if(!isDropAllowed(event)){
                    return true;
                }

                // The default behavior in Firefox is to interpret the dropped $element as URL and
                // forward to it. We want to prevent that even if our drop is aborted.
                event.preventDefault();

                // Unserialize the data that was serialized in dragstart. According to the HTML5 specs,
                // the "Text" drag type will be converted to text/plain, but IE does not do that.
                var data = event.dataTransfer.getData("Text") || event.dataTransfer.getData("text/plain");
                var transferredObject;
                try{
                    transferredObject = JSON.parse(data);
                }catch(e){
                    return stopDragover();
                }

                // Invoke the callback, which can transform the transferredObject and even abort the drop.
                var index = getPlaceholderIndex();
                if($attrs.dndDrop){
                    transferredObject = invokeCallback($attrs.dndDrop, event, index, transferredObject);
                    if(!transferredObject){
                        return stopDragover();
                    }
                }

                // Retrieve the JSON array and insert the transferred object into it.
                var targetArray = $scope.$eval($attrs.dndList);
                $scope.$apply(function(){
                    targetArray.splice(index, 0, transferredObject);
                });
                invokeCallback($attrs.dndInserted, event, index, transferredObject);

                // In Chrome on Windows the dropEffect will always be none...
                // We have to determine the actual effect manually from the allowed effects
                if(event.dataTransfer.dropEffect === "none"){
                    if(event.dataTransfer.effectAllowed === "copy" ||
                        event.dataTransfer.effectAllowed === "move"){
                        dndDropEffectWorkaround.dropEffect = event.dataTransfer.effectAllowed;
                    }else{
                        dndDropEffectWorkaround.dropEffect = event.ctrlKey ? "copy" : "move";
                    }
                }else{
                    dndDropEffectWorkaround.dropEffect = event.dataTransfer.dropEffect;
                }

                // Clean up
                stopDragover();
                event.stopPropagation();
                return false;
            });

            /**
             * We have to remove the placeholder when the $element is no longer dragged over our list. The
             * problem is that the dragleave event is not only fired when the $element leaves our list,
             * but also when it leaves a child $element -- so practically it's fired all the time. As a
             * workaround we wait a few milliseconds and then check if the dndDragover class was added
             * again. If it is there, dragover must have been called in the meantime, i.e. the $element
             * is still dragging over the list. If you know a better way of doing this, please tell me!
             */
            $element.on('dragleave', function(event){
                event = event.originalEvent || event;

                $element.removeClass("dndDragover");
                $timeout(function(){
                    if(!$element.hasClass("dndDragover")){
                        placeholder.remove();
                    }
                }, 100);
            });

            /**
             * Checks whether the mouse pointer is in the first half of the given target $element.
             *
             * In Chrome we can just use offsetY, but in Firefox we have to use layerY, which only
             * works if the child $element has position relative. In IE the events are only triggered
             * on the listNode instead of the listNodeItem, therefore the mouse positions are
             * relative to the parent $element of targetNode.
             */
            function isMouseInFirstHalf(event, targetNode, relativeToParent){
                var mousePointer   = horizontal ? (event.offsetX || event.layerX)
                    : (event.offsetY || event.layerY);
                var targetSize     = horizontal ? targetNode.offsetWidth : targetNode.offsetHeight;
                var targetPosition = horizontal ? targetNode.offsetLeft : targetNode.offsetTop;
                targetPosition     = relativeToParent ? targetPosition : 0;
                return mousePointer < targetPosition + targetSize / 2;
            }

            /**
             * Tries to find a child $element that has the dndPlaceholder class set. If none was found, a
             * new li $element is created.
             */
            function getPlaceholderElement(){
                var placeholder;
                angular.forEach($element.children(), function(childNode){
                    var child = angular.element(childNode);
                    if(child.hasClass('dndPlaceholder')){
                        placeholder = child;
                    }
                });
                return placeholder || angular.element("<li class='dndPlaceholder'></li>");
            }

            /**
             * We use the position of the placeholder node to determine at which position of the array the
             * object needs to be inserted
             */
            function getPlaceholderIndex(){
                return Array.prototype.indexOf.call(listNode.children, placeholderNode);
            }

            /**
             * Checks various conditions that must be fulfilled for a drop to be allowed
             */
            function isDropAllowed(event){
                // Disallow drop from external source unless it's allowed explicitly.
                if(!dndDragTypeWorkaround.isDragging && !externalSources){
                    return false;
                }

                // Check mimetype. Usually we would use a custom drag type instead of Text, but IE doesn't
                // support that.
                if(!hasTextMimetype(event.dataTransfer.types)){
                    return false;
                }

                // Now check the dnd-allowed-types against the type of the incoming $element. For drops from
                // external sources we don't know the type, so it will need to be checked via dnd-drop.
                if($attrs.dndAllowedTypes && dndDragTypeWorkaround.isDragging){
                    var allowed = $scope.$eval($attrs.dndAllowedTypes);
                    if(angular.isArray(allowed) && allowed.indexOf(dndDragTypeWorkaround.dragType) === -1){
                        return false;
                    }
                }

                // Check whether droping is disabled completely
                if($attrs.dndDisableIf && $scope.$eval($attrs.dndDisableIf)){
                    return false;
                }

                return true;
            }

            /**
             * Small helper function that cleans up if we aborted a drop.
             */
            function stopDragover(){
                placeholder.remove();
                $element.removeClass("dndDragover");
                return true;
            }

            /**
             * Invokes a callback with some interesting parameters and returns the callbacks return value.
             */
            function invokeCallback(expression, event, index, item){
                return $parse(expression)($scope, {
                    event   : event,
                    index   : index,
                    item    : item || undefined,
                    external: !dndDragTypeWorkaround.isDragging,
                    type    : dndDragTypeWorkaround.isDragging ? dndDragTypeWorkaround.dragType : undefined
                });
            }

            /**
             * Check if the dataTransfer object contains a drag type that we can handle. In old versions
             * of IE the types collection will not even be there, so we just assume a drop is possible.
             */
            function hasTextMimetype(types){
                if(!types){
                    return true;
                }
                for(var i = 0; i < types.length; i++){
                    if(types[i] === "Text" || types[i] === "text/plain"){
                        return true;
                    }
                }

                return false;
            }
        }

    }
    ComponentDirective.$inject = ["$parse", "$timeout", "dndDropEffectWorkaround", "dndDragTypeWorkaround"];


})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.dnd')
        .directive('dndList', ComponentDirective);

        /**
        * @ngdoc directive
        * @name dndList
        * @module enspire.ui.components.dnd
        * @restrict A
         *
        * @description
        * Use the dnd-list attribute to make your list element a dropzone. Usually you will add a single
        * li element as child with the ng-repeat directive. If you don't do that, we will not be able to
        * position the dropped element correctly. If you want your list to be sortable, also add the
        * dnd-draggable directive to your li element(s). Both the dnd-list and it's direct children must
        * have position: relative CSS style, otherwise the positioning algorithm will not be able to
        * determine the correct placeholder position in all browsers.
        *
        * ## CSS Classes
        *
        * - **dndPlaceholder**: When an element is dragged over the list, a new placeholder child element will be added. This element is of type li and has the class
        * dndPlaceholder set. Alternatively, you can define your own placeholder by creating a child element with dndPlaceholder class.
        * - **dndDragover**: Will be added to the list while an element is dragged over the list.
        *
        * @param {array}    dnd-list    Required attribute. The value has to be the array in which the data of
        * the dropped element should be inserted.
        * @param {array=}    dnd-allowed-types  Optional array of allowed item types. When used, only items that had a
        * matching dnd-type attribute will be dropable.
        * @param {boolean=}    dnd-disable-if   Optional boolean expresssion. When it evaluates to true, no dropping
        * into the list is possible. Note that this also disables rearranging items inside the list.
        * @param {boolean=}    dnd-horizontal-list  Optional boolean expresssion. When it evaluates to true, the positioning
        * algorithm will use the left and right halfs of the list items instead of the upper and lower halfs.
        * @param {expression=}    dnd-dragover  Optional expression that is invoked when an element is dragged over the
        * list. If the expression is set, but does not return true, the element is not allowed to be dropped. The following variables will be available:
         *
        * - **event**: The original dragover event sent by the browser.
        * - **index**: The position in the list at which the element would be dropped.
        * - **type**: The dnd-type set on the dnd-draggable, or undefined if unset.
        * @param {expression=}    dnd-drop Optional expression that is invoked when an element is dropped over the
        * list. If the expression is set, it must return the object that will be inserted into the list. If it returns false, the drop will be aborted
        * and the event is propagated. The following variables will be available:
         *
        * - **event**: The original drop event sent by the browser.
        * - **index**: The position in the list at which the element would be dropped.
        * - **item**: The transferred object.
        * - **type**: The dnd-type set on the dnd-draggable, or undefined if unset.
        * @param {expression=}    dnd-inserted  Optional expression that is invoked after a drop if the element was
        * actually inserted into the list. The same local variables as for dnd-drop will be available. Note that for reorderings inside the same
        * list the old element will still be in the list due to the fact that dnd-moved was not called yet.
        * @param {boolean=}    dnd-external-sources Optional boolean expression. When it evaluates to true, the list accepts
        * drops from sources outside of the current browser tab. This allows to drag and drop accross different browser tabs. Note that this will allow
        * to drop arbitrary text into the list, thus it is highly recommended to implement the dnd-drop callback to check the incoming element for
        * sanity. Furthermore, the dnd-type of external sources can not be determined, therefore do not rely on restrictions of dnd-allowed-type.
        *
        *
        */

    function ComponentDirective($parse, $timeout, dndDropEffectWorkaround, dndDragTypeWorkaround){

        return {
            restrict: 'A',
            link    : postLink
        };

        function postLink($scope, $element, $attrs){
            // While an $element is dragged over the list, this placeholder $element is inserted
            // at the location where the $element would be inserted after dropping
            var placeholder     = getPlaceholderElement();
            var placeholderNode = placeholder[0];
            var listNode        = $element[0];
            placeholder.remove();

            var horizontal      = $attrs.dndHorizontalList && $scope.$eval($attrs.dndHorizontalList);
            var externalSources = $attrs.dndExternalSources && $scope.$eval($attrs.dndExternalSources);

            /**
             * The dragover event is triggered "every few hundred milliseconds" while an $element
             * is being dragged over our list, or over a child $element.
             */
            $element.on('dragover', function(event){
                event = event.originalEvent || event;

                if(!isDropAllowed(event)){
                    return true;
                }

                // First of all, make sure that the placeholder is shown
                // This is especially important if the list is empty
                if(placeholderNode.parentNode != listNode){
                    $element.append(placeholder);
                }

                if(event.target !== listNode){
                    // Try to find the node direct directly below the list node.
                    var listItemNode = event.target;
                    while(listItemNode.parentNode !== listNode && listItemNode.parentNode){
                        listItemNode = listItemNode.parentNode;
                    }

                    if(listItemNode.parentNode === listNode && listItemNode !== placeholderNode){
                        // If the mouse pointer is in the upper half of the child $element,
                        // we place it before the child $element, otherwise below it.
                        if(isMouseInFirstHalf(event, listItemNode)){
                            listNode.insertBefore(placeholderNode, listItemNode);
                        }else{
                            listNode.insertBefore(placeholderNode, listItemNode.nextSibling);
                        }
                    }
                }else{
                    // This branch is reached when we are dragging directly over the list $element.
                    // Usually we wouldn't need to do anything here, but the IE does not fire it's
                    // events for the child $element, only for the list directly. Therefore we repeat
                    // the positioning algorithm for IE here.
                    if(isMouseInFirstHalf(event, placeholderNode, true)){
                        // Check if we should move the placeholder $element one spot towards the top.
                        // Note that display none elements will have offsetTop and offsetHeight set to
                        // zero, therefore we need a special check for them.
                        while(placeholderNode.previousElementSibling
                        && (isMouseInFirstHalf(event, placeholderNode.previousElementSibling, true)
                        || placeholderNode.previousElementSibling.offsetHeight === 0)){
                            listNode.insertBefore(placeholderNode, placeholderNode.previousElementSibling);
                        }
                    }else{
                        // Check if we should move the placeholder $element one spot towards the bottom
                        while(placeholderNode.nextElementSibling && !isMouseInFirstHalf(event, placeholderNode.nextElementSibling, true)){
                            listNode.insertBefore(placeholderNode,
                                placeholderNode.nextElementSibling.nextElementSibling);
                        }
                    }
                }

                // At this point we invoke the callback, which still can disallow the drop.
                // We can't do this earlier because we want to pass the index of the placeholder.
                if($attrs.dndDragover && !invokeCallback($attrs.dndDragover, event, getPlaceholderIndex())){
                    return stopDragover();
                }

                $element.addClass("dndDragover");
                event.preventDefault();
                event.stopPropagation();
                return false;
            });

            /**
             * When the $element is dropped, we use the position of the placeholder $element as the
             * position where we insert the transferred data. This assumes that the list has exactly
             * one child $element per array $element.
             */
            $element.on('drop', function(event){
                event = event.originalEvent || event;

                if(!isDropAllowed(event)){
                    return true;
                }

                // The default behavior in Firefox is to interpret the dropped $element as URL and
                // forward to it. We want to prevent that even if our drop is aborted.
                event.preventDefault();

                // Unserialize the data that was serialized in dragstart. According to the HTML5 specs,
                // the "Text" drag type will be converted to text/plain, but IE does not do that.
                var data = event.dataTransfer.getData("Text") || event.dataTransfer.getData("text/plain");
                var transferredObject;
                try{
                    transferredObject = JSON.parse(data);
                }catch(e){
                    return stopDragover();
                }

                // Invoke the callback, which can transform the transferredObject and even abort the drop.
                var index = getPlaceholderIndex();
                if($attrs.dndDrop){
                    transferredObject = invokeCallback($attrs.dndDrop, event, index, transferredObject);
                    if(!transferredObject){
                        return stopDragover();
                    }
                }

                // Retrieve the JSON array and insert the transferred object into it.
                var targetArray = $scope.$eval($attrs.dndList);
                $scope.$apply(function(){
                    targetArray.splice(index, 0, transferredObject);
                });
                invokeCallback($attrs.dndInserted, event, index, transferredObject);

                // In Chrome on Windows the dropEffect will always be none...
                // We have to determine the actual effect manually from the allowed effects
                if(event.dataTransfer.dropEffect === "none"){
                    if(event.dataTransfer.effectAllowed === "copy" ||
                        event.dataTransfer.effectAllowed === "move"){
                        dndDropEffectWorkaround.dropEffect = event.dataTransfer.effectAllowed;
                    }else{
                        dndDropEffectWorkaround.dropEffect = event.ctrlKey ? "copy" : "move";
                    }
                }else{
                    dndDropEffectWorkaround.dropEffect = event.dataTransfer.dropEffect;
                }

                // Clean up
                stopDragover();
                event.stopPropagation();
                return false;
            });

            /**
             * We have to remove the placeholder when the $element is no longer dragged over our list. The
             * problem is that the dragleave event is not only fired when the $element leaves our list,
             * but also when it leaves a child $element -- so practically it's fired all the time. As a
             * workaround we wait a few milliseconds and then check if the dndDragover class was added
             * again. If it is there, dragover must have been called in the meantime, i.e. the $element
             * is still dragging over the list. If you know a better way of doing this, please tell me!
             */
            $element.on('dragleave', function(event){
                event = event.originalEvent || event;

                $element.removeClass("dndDragover");
                $timeout(function(){
                    if(!$element.hasClass("dndDragover")){
                        placeholder.remove();
                    }
                }, 100);
            });

            /**
             * Checks whether the mouse pointer is in the first half of the given target $element.
             *
             * In Chrome we can just use offsetY, but in Firefox we have to use layerY, which only
             * works if the child $element has position relative. In IE the events are only triggered
             * on the listNode instead of the listNodeItem, therefore the mouse positions are
             * relative to the parent $element of targetNode.
             */
            function isMouseInFirstHalf(event, targetNode, relativeToParent){
                var mousePointer   = horizontal ? (event.offsetX || event.layerX)
                    : (event.offsetY || event.layerY);
                var targetSize     = horizontal ? targetNode.offsetWidth : targetNode.offsetHeight;
                var targetPosition = horizontal ? targetNode.offsetLeft : targetNode.offsetTop;
                targetPosition     = relativeToParent ? targetPosition : 0;
                return mousePointer < targetPosition + targetSize / 2;
            }

            /**
             * Tries to find a child $element that has the dndPlaceholder class set. If none was found, a
             * new li $element is created.
             */
            function getPlaceholderElement(){
                var placeholder;
                angular.forEach($element.children(), function(childNode){
                    var child = angular.element(childNode);
                    if(child.hasClass('dndPlaceholder')){
                        placeholder = child;
                    }
                });
                return placeholder || angular.element("<li class='dndPlaceholder'></li>");
            }

            /**
             * We use the position of the placeholder node to determine at which position of the array the
             * object needs to be inserted
             */
            function getPlaceholderIndex(){
                if($attrs.dndIndex){
                    return $scope.$eval($attrs.dndIndex);
                }else{
                    return Array.prototype.indexOf.call(listNode.children, placeholderNode);
                }
            }

            /**
             * Checks various conditions that must be fulfilled for a drop to be allowed
             */
            function isDropAllowed(event){
                // Disallow drop from external source unless it's allowed explicitly.
                if(!dndDragTypeWorkaround.isDragging && !externalSources){
                    return false;
                }

                // Check mimetype. Usually we would use a custom drag type instead of Text, but IE doesn't
                // support that.
                if(!hasTextMimetype(event.dataTransfer.types)){
                    return false;
                }

                // Now check the dnd-allowed-types against the type of the incoming $element. For drops from
                // external sources we don't know the type, so it will need to be checked via dnd-drop.
                if($attrs.dndAllowedTypes && dndDragTypeWorkaround.isDragging){
                    var allowed = $scope.$eval($attrs.dndAllowedTypes);
                    if(angular.isArray(allowed) && allowed.indexOf(dndDragTypeWorkaround.dragType) === -1){
                        return false;
                    }
                }

                // Check whether droping is disabled completely
                if($attrs.dndDisableIf && $scope.$eval($attrs.dndDisableIf)){
                    return false;
                }

                return true;
            }

            /**
             * Small helper function that cleans up if we aborted a drop.
             */
            function stopDragover(){
                placeholder.remove();
                $element.removeClass("dndDragover");
                return true;
            }

            /**
             * Invokes a callback with some interesting parameters and returns the callbacks return value.
             */
            function invokeCallback(expression, event, index, item){
                return $parse(expression)($scope, {
                    event   : event,
                    index   : index,
                    item    : item || undefined,
                    external: !dndDragTypeWorkaround.isDragging,
                    type    : dndDragTypeWorkaround.isDragging ? dndDragTypeWorkaround.dragType : undefined
                });
            }

            /**
             * Check if the dataTransfer object contains a drag type that we can handle. In old versions
             * of IE the types collection will not even be there, so we just assume a drop is possible.
             */
            function hasTextMimetype(types){
                if(!types){
                    return true;
                }
                for(var i = 0; i < types.length; i++){
                    if(types[i] === "Text" || types[i] === "text/plain"){
                        return true;
                    }
                }

                return false;
            }
        }

    }
    ComponentDirective.$inject = ["$parse", "$timeout", "dndDropEffectWorkaround", "dndDragTypeWorkaround"];


})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.dnd')
        .directive('dndNodrag', ComponentDirective);

    /**
    * @ngdoc directive
    * @name dndNodrag
    * @module enspire.ui.components.dnd
    * @restrict A
    * @description
    * Use the dnd-nodrag attribute inside of dnd-draggable elements to prevent them from starting
    * drag operations. This is especially useful if you want to use input elements inside of
    * dnd-draggable elements or create specific handle elements.
    */

    function ComponentDirective($parse, $timeout, dndDropEffectWorkaround, dndDragTypeWorkaround){

        return {
            restrict: 'A',
            link    : postLink
        };

        function postLink($scope, $element, $attrs){
            // Set as draggable so that we can cancel the events explicitly
            $element.attr("draggable", "true");

            /**
             * Since the element is draggable, the browser's default operation is to drag it on dragstart.
             * We will prevent that and also stop the event from bubbling up.
             */
            $element.on('dragstart', function(event){
                event = event.originalEvent || event;
            /**
            * If a child element already reacted to dragstart and set a dataTransfer object, we will
            * allow that. For example, this is the case for user selections inside of input elements.
            */
                if(!(event.dataTransfer.types && event.dataTransfer.types.length)){
                    event.preventDefault();
                }
                event.stopPropagation();
            });

            /**
             * Stop propagation of dragend events, otherwise dnd-moved might be triggered and the element
             * would be removed.
             */
            $element.on('dragend', function(event){
                event = event.originalEvent || event;
                event.stopPropagation();
            });
        }

    }
    ComponentDirective.$inject = ["$parse", "$timeout", "dndDropEffectWorkaround", "dndDragTypeWorkaround"];


})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.draggable')
    .controller('enDraggableController', DraggableController);
    
    /**
     * @private
     * @ngdoc function
     * @name DraggableController
     * @module enspire.ui.components.draggable
     *
     */
    function DraggableController($scope, $element, $attrs) {
        var self = this;
    }
    DraggableController.$inject = ["$scope", "$element", "$attrs"];
    
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.draggable')
        .directive('enDraggable', DraggableDirective);


    /**
     * @ngdoc directive
     * @name enDraggable
     * @module enspire.ui.components.draggable
     * @restrict A
     * @description
     * Makes a DOM element draggable.
     *
     * @usage
     * <hljs lang="html">
     *     <en-button en-draggable class="primary">
     *       Drag me!
     *     </en-button>
     * </hljs>
     *
     * ## CSS classes for theming
     * - `.is-pointer-down` added when the user's pointer (mouse, touch, pointer) first presses down.
     * - `.is-dragging` added when elements starts to drag.
     *
     * ## Options
     * Options are data attributes placed on the DOM element. Options being with `drag-` prefix.
     * Example: `drag-axis="x"`
     *
     * Name        | Type     | Example         | Description
     * :-----------| :--------|:----------------|:---------------------------------------------------
     * axis        | *String* | `drag-axis="x"` | Constrains movement to horizontal or vertical axis.
     * containment | *Element*, Selector *String*, or *Boolean* | `drag-containment="true"` | Contains movement to the bounds of the element. If `true`, the container will be the parent element.
     * grid        | *Array*  | `drag-grid="[20, 20]"` | Snaps the element to a grid, every x and y pixels.
     * handle      | Selector *String*  | `drag-handle='.modal-header'` | Specifies on what element the drag interaction starts. Useful for when you do not want all inner elements to be used for dragging, like inputs and forms.
     * complete    | *String* name of function callback | `drag-complete="myCallback(dragEl)"`| Will fire the callback after initialization and pass the draggable object as first parameter. Useful for getting handle of draggable object.
     *
     *
     * ##Events
     *
     * ### **dragStart**
     * Triggered when dragging starts and the element starts moving. Dragging starts after the user's pointer has moved a couple pixels to allow for clicks.
     * - `event` - **Type:** Event - the original `mousedown` or `touchstart` event
     * - `pointer` - **Type:** *MouseEvent* or *Touch* - the event object that has `.pageX` and `.pageY`
     *
     *
     * ### **dragMove**
     * Triggered when dragging moves.
     * - `event` - **Type:** Event - the original `mousemove` or `touchmove` event
     * - `pointer` - **Type:** *MouseEvent* or *Touch* - the event object that has `.pageX` and `.pageY`
     * - `moveVector` - **Type:** *Object* - How far the pointer has moved from its start position `{ x: 20, y: -30 }`
     *
     *
     * ### **dragEnd**
     * Triggered when dragging ends.
     * - `event` - **Type:** Event - the original `mouseup` or `touchend` event
     * - `pointer` - **Type:** *MouseEvent* or *Touch* - the event object that has `.pageX` and `.pageY`
     *
     *
     * ### **pointerDown**
     * Triggered when the user's pointer (mouse, touch, pointer) presses down.
     * - `event` - **Type:** Event - the original `mousedown` or `touchstart` event
     * - `pointer` - **Type:** *MouseEvent* or *Touch* - the event object that has `.pageX` and `.pageY`
     *
     *
     * ### **pointerMove**
     * Triggered when the user's pointer moves.
     * - `event` - **Type:** Event - the original `mousemove` or `touchmove` event
     * - `pointer` - **Type:** *MouseEvent* or *Touch* - the event object that has `.pageX` and `.pageY`
     * - `moveVector` - **Type:** *Object* - How far the pointer has moved from its start position `{ x: 20, y: -30 }`
     *
     *
     * ### **pointerUp**
     * Triggered when the user's pointer unpresses.
     * - `event` - **Type:** Event - the original `mouseup` or `touchend` event
     * - `pointer` - **Type:** *MouseEvent* or *Touch* - the event object that has `.pageX` and `.pageY`
     *
     *
     * ### **staticClick**
     * Triggered when the user's pointer is pressed and unpressed and has not moved enough to start dragging.
     * `click` events are hard to detect with draggable UI, as they are triggered whenever a user drags. *StaticClick* event resolves this, as it is triggered when the user has not dragged.
     * - `event` - **Type:** Event - the original `mouseup` or `touchend` event
     * - `pointer` - **Type:** *MouseEvent* or *Touch* - the event object that has `.pageX` and `.pageY`
     *
     *
     * ## Methods
     * - disable - `dragEl.disable()`
     * - enable - `dragEl.enable()`
     * - destroy - `dragEl.destroy()` **Note:** This is called automatically from the directive when the scope is destroyed.
     *
     * ## Properties
     * - position - `dragEl.position` - Returns offset position as an object `{x: 20, y: -30}`
     *
     */
    function DraggableDirective($enDraggable, $parse) {
        return {
            restrict: 'A',
            controller: 'enDraggableController',
            link: postLink
        };

        function postLink($scope, $element, $attrs) {
            var options = { 'scope': $scope },
                dragEl;

            // Drag handle
            if ($attrs.dragHandle) {
                options.handle = $attrs.dragHandle;
            }

            // Containment container
            if ($attrs.dragContainment) {
                options.containment = $attrs.dragContainment;
                options.containment = (options.containment.toLowerCase() === 'true') ? true: options.containment;
            }

            // restrict to axis
            if ($attrs.dragAxis && $attrs.dragAxis.match(/^x|y$/)) {
                options.axis = $attrs.dragAxis;
            }

            // Callback function defined
            if ($attrs.dragComplete && $attrs.dragComplete.length) {
                options.callback = $parse($attrs.dragComplete);
            }

            // create new draggable element
            dragEl = $enDraggable.init($element[0], options);

            // Remove bindings
            $scope.$on('$destroy', function() {
                $enDraggable.destroy(dragEl);
            });
        }
    }
    DraggableDirective.$inject = ["$enDraggable", "$parse"];
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.draggable')
        .provider('$enDraggable', DraggableService);
    

/**
* @ngdoc service
* @name $enDraggable
* @module enspire.ui.components.draggable
*
* @description
* Adds drag and drop functionality to an element.
* 
*/
    

    function DraggableService() {
        var self = this;

        self.$get = [function $enDraggableFactory() {

            /**
             * @ngdoc method
             * @name $enDraggable#init
             *
             * @description
             * Makes a DOM element draggable.
             *
             * @param {object} domEl (DOM Element) The DOM element you want to make draggable.
             * @param {object} options The configuration options to apply.
             *
             * @returns {object} (Draggabilly Object) Returns handle to draggable object.
             */
            function init(domEl, options) {
                var dragEl = new Draggabilly(domEl, options),
                    callback = options.callback || angular.noop;

                callback(options.scope, {'dragEl': dragEl});

                options = null;

                return dragEl;
            }

            /**
             * @ngdoc method
             * @name $enDraggable#destroy
             *
             * @description
             * Remove any bindings for garbage collection.
             *
             * @param {object} (Draggabilly Object) The handle to draggable object.
             */
            function destroy(dragEl) {
                dragEl.destroy();
            }

            // TODO: Investigate pros and cons of storing handle to draggable object(s)
            // Should the responsibility of developer really.
            function enableDraggable(dragEl){
                dragEl.enable();
            }

            function disableDraggable(dragEl) {
                dragEl.disable();
            }

            return {
                'init': init,
                'destroy': destroy,
                'enable': enableDraggable,
                'disable': disableDraggable
            };

        }];
    }
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';
    angular.module('enspire.ui.components.enter').directive('enEnter', enterDirective);

    function enterDirective($timeout) {

        return {
            restrict : 'A',
            link     : postLink
        };

        function postLink($scope, $element, $attrs) {

            $element.bind('keydown keypress', function (event) {
                if(event.which === 13) {
                    // $timeout(function (){
                        $scope.$eval($attrs.enEnter, {$event:event});
                    // });
                    // event.preventDefault();
                }
            });
        }
    }
    enterDirective.$inject = ["$timeout"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';
    angular.module('enspire.ui.components.error').directive('enError', ErrorDirective);

    /**
     * @ngdoc directive
     * @name enError
     * @module enspire.ui.components.error
     * @restrict E
     * @description
     * `en-error` creates a style error block.
     *
     * @element en-error
     *
     * @param {object=}    object             Causes `en-error` to display an error returned by apiObject. 
     *
     * @usage
     * ### As Link error
     * <hljs lang="html">
     *   <en-error object="apiObject">
     *   </en-error>
     * </hljs>
     * 
     * 
     * 
     */
    
    function ErrorDirective(){
        var randomName = function () {
            var length = 32;
            var chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
            var result = '';
            for (var i = length; i > 0; --i){
                result += chars[Math.round(Math.random() * (chars.length - 1))];
            }
            return result;
        };
        return {
            restrict    : 'E',
            // transclude  : true,
            replace     : true,
            template    : resolveTemplate,
            link        : postLink
        };
        
        function postLink($scope, $element, $attrs){
            $scope[$attrs.objectName] = $scope.$eval($attrs.object);
        }
        
        function resolveTemplate($element, $attrs){
            var objectName = randomName();
            $attrs.objectName = objectName;

            var strTemplate = '<en-content class="margin-bottom-collapse" style="margin-bottom:8px;"';
             if(angular.isDefined($attrs.id)){
                strTemplate+='id="'+$attrs.id+'" ';
             }
             strTemplate+='ng-show="'+objectName+'.errors.length>0 && !'+objectName+'.putting && !'+objectName+'.posting">'+
                    '<en-alert class="alert-error" style="padding:1rem">'+
                    '<en-icon icon="alert-circle"></en-icon>'+
                    '<span ng-if="'+objectName+'.errors[0].fieldErrors === undefined">'+
                    '{{'+objectName+'.errors[0].message}}'+
                    '</span>'+
                    '<span ng-if="'+objectName+'.errors[0].fieldErrors.length >= 1">'+
                    '{{'+objectName+'.errors[0].message}}'+
                    '<p ng-repeat=" error in '+objectName+'.errors[0].fieldErrors">{{error.path}} {{error.message}}</p>'+
                    '</span>'+
                    '</en-alert>'+
                    '</en-content>';
            return strTemplate;
        }
    }
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013 danialfarid
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**!
 * AngularJS file upload/drop directive and service with progress and abort
 * @author  Danial  <danial.farid@gmail.com>
 * @version 4.0.2
 */

/**
 * @ngdoc directive
 * @name ngFileUpload
 * @module enspire.ui.components.fileUpload
 * @restrict AE
 * @description
 * Lightweight Angular JS directive to upload files. Uses `ngf-select` and `ngf-drop`, see documentation below. Documentation taken from https://github.com/danialfarid/ng-file-upload.
 *
 * @usage
 * ### Basic Example
 * <hljs lang="html" escape="false">
 *   <form name="myForm">
 *      <label>Profile Picture:</label>
 *
 *       <input type="file"
 *           ngf-select
 *           ng-model="picFile"
 *           name="file"
 *           accept="image/*"
 *           required />
 *
 *       <button ng-disabled="!myForm.$valid" ng-click="uploadPic(picFile)">
 *           Submit
 *       </button>
 *
 *       <span class="progress" ng-show="picFile[0].progress >= 0">
 *           <div style="width:{{picFile[0].progress}}%" ng-bind="picFile[0].progress + '%'"></div>
 *       </span>
 *   </form>
 * </hljs>
 *
 *  <br />
 *  <br />
 *  **Here is the <a href="https://angular-file-upload.appspot.com/" target="_blank">DEMO</a> page**.
 *
 *  Another example <a href="http://jsfiddle.net/3t50b3fw/" target="_blank"><strong>DEMO 2</strong></a>
 *
 *
 *  ###Features
 *  - Supports upload progress, cancel/abort upload while in progress, file drag and drop (html5), directory drag and drop (webkit), CORS, `PUT(html5)`/`POST` methods, validation of file type and size.
 *  - Cross browser file upload (`HTML5` and `non-HTML5`) with Flash polyfill if needed.
 *  - Allows client side validation/modification before uploading the file.
 *  - Direct upload to db services CouchDB, imgur, etc... with file's content type using `$upload.http()`. This enables progress event for angular http `POST`/`PUT` requests.
 *  - Seperate shim file, FileAPI files are loaded on demand for `non-HTML5` code meaning no extra load/code if you just need HTML5 support.
 *  - Lightweight using regular `$http` to upload (with shim for non-HTML5 browsers) so all angular `$http` features are available
 *
 *
 *  <br />
 *  ###Sample Usage:
 *
 * ### HTML:
 *  <hljs lang="html" no-escape>
 *      <div>
 *          <div class="button" ngf-select ng-model="files">Upload using model $watch</div>
 *          <div class="button" ngf-select ngf-change="upload($files)">Upload on file change</div>
 *          Drop File:
 *          <div ngf-drop ng-model="files" class="drop-box" ngf-drag-over-class="dragover" ngf-multiple="true" ngf-allow-dir="true" ngf-accept="'.jpg,.png,.pdf'">Drop Images or PDFs files here</div>
 *          <div ngf-no-file-drop>File Drag-n-Drop is not supported for this browser</div>
 *      </div>
 *  </hljs>
 *
 *
 * ### JS:
 *  <hljs lang="js">
 *  app.controller('MyCtrl', ['$scope', 'Upload', function ($scope, Upload) {
 *      $scope.$watch('files', function () {
 *          $scope.upload($scope.files);
 *      });
 *
 *      $scope.upload = function (files) {
 *          if (files && files.length) {
 *              for (var i = 0; i < files.length; i++) {
 *                  var file = files[i];
 *                  Upload.upload({
 *                      url: 'upload/url',
 *                      fields: {'username': $scope.username},
 *                      file: file
 *                  }).progress(function (evt) {
 *                      var progressPercentage = parseInt(100.0 * evt.loaded / evt.total);
 *                      console.log('progress: ' + progressPercentage + '% ' + evt.config.file.name);
 *                  }).success(function (data, status, headers, config) {
 *                      console.log('file ' + config.file.name + 'uploaded. Response: ' + data);
 *                  });
 *              }
 *          }
 *      };
 *  }]);
 *  </hljs>
 *
 *  <br />
 *  <br />
 *
 *  ## File select (ngf-select)
 *  Attribute         | Example                       | Description
 *  ------------------|-------------------------------|------------
 *  ng-model          | ng-model="myFiles"            | Binds the selected files to the scope model.
 *  ng-model-rejected | ng-model-rejected="rejFiles"  | Bind to dropped files that do not match the accept wildcard.
 *  ngf-change        | ngf-change="fileSelected($files, $event)" | Is called when files are selected. Can use $scope.$watch('myFiles') instead.
 *  ngf-multiple      | ngf-multiple="true&#124;false"| Defaults to false, allows selecting multiple files.
 *  ngf-capture       | ngf-capture="'camera'&#124;'other'"| Allows mobile devices to capture images using camera.
 *  accept            | accept="'image/&#42;'"            | If the value of the type attribute is file, this attribute indicates the types of files that the server accepts; otherwise it is ignored. The value must be a comma-separated list of unique content type specifiers: <br/>- File extensions (E.g.: ".jpg,.png,.doc")<br>- Valid MIME type with no extensions<br>- audio/&#42; representing sound files <br>- video/&#42; representing video files<br>- image/&#42; representing image files
 *  ngf-min-size      | ngf-min-size='10' |  Minimum acceptable file size in bytes
 *  ngf-max-size      | ngf-max-size='10' |  Maximum acceptable file size in bytes
 *
 *
 *  <pre><code class="highlight">
 *  &lt;button|div|input type="file"|ngf-select|...
 *      // binds the selected files to the scope model
 *      <strong>ngf-select</strong> <strong>ng-model</strong>=<em>"myFiles"</em>
 *
 *      // bind to dropped files that do not match the accept wildcard
 *      <strong>ng-model-rejected</strong>=<em>"rejFiles"</em>
 *
 *      // will be called upon files being selected
 *      // you can use $scope.$watch('myFiles') instead
 *      <strong>ngf-change</strong>=<em>"fileSelected($files, $event)"</em>
 *
 *      // default false, allows selecting multiple files
 *      <strong>ngf-multiple</strong>=<em>"true|false"</em>
 *
 *      // allows mobile devices to capture using camera
 *      <strong>ngf-capture</strong>=<em>"'camera'|'other'"</em>
 *
 *      // see standard HTML file input accept attribute
 *      <strong>accept</strong>=<em>"'image/*'"</em>
 *
 *      // function or comma separated wildcard to filter files allowed
 *      <strong>ngf-accept</strong>=<em>"'image/*'|validate($file)"</em>
 *
 *      // minimum acceptable file size in bytes
 *      <strong>ngf-min-size</strong>=<em>'10'</em>
 *
 *      // maximum acceptable file size in bytes
 *      <strong>ngf-max-size</strong>=<em>'10'</em>
 *  &gt;Upload&lt;/button&gt;
 *  </code></pre>
 *
 *  <br />
 *  <br />
 *  <br />
 *
 *  ## File drop (ngf-drop)
 *  Attribute         | Example                       | Description
 *  ------------------|-------------------------------|------------
 *  ng-model          | ng-model="myFiles"            | Binds the dropped files to the scope model.
 *  ng-model-rejected | ng-model-rejected="rejFiles"  | Bind to dropped files that do not match the accept wildcard.
 *  ngf-change        | ngf-change="fileDropped($files, $event, $rejectedFiles)" | Called upon files being dropped.
 *  ngf-multiple      | ngf-multiple="true&#124;false"| Defaults to false, allows selecting multiple files.
 *  ngf-accept        | ngf-accept="'.pdf,.jpg'&#124;validate($file)" | Function or comma separated wildcard to filter allowed files.
 *  ngf-allow-dir     | ngf-allow-dir="true&#124;false" | Defaults to true, allows dropping files only for Chrome webkit browser.
 *  ngf-drag-over-class | ngf-drag-over-class="{accept:'acceptClass', reject:'rejectClass', delay:100}&#124;myDragOverClass&#124; calcDragOverClass($event)" | Drag over css class behaviour. could be a string, a function returning class name or a json object {accept: 'c1', reject: 'c2', delay:10}. <br />Default "dragover" reject class only works in Chrome. <br />Validation only on file type.
 *  ngf-drop-available | ngf-drop-available="dropSupported" | Set the value of scope model to true or false based on file drag&drop support for this browser
 *  ngf-stop-propagation | ngf-stop-propagation="true&#124;false" | Default to false, whether to propagate drag/drop events.
 *  ngf-hide-on-drop-not-available | ngf-hide-on-drop-not-available="true&#124;false" | Defaults to false, hides element if file drag&drop is not supported
 *  ngf-min-size      | ngf-min-size='10' |  Minimum acceptable file size in bytes
 *  ngf-max-size      | ngf-max-size='10' |  Maximum acceptable file size in bytes
 *
 *
 *  <pre><code class="highlight">
 *  &lt;div|button|ngf-drop|...
 *
 *      // binds the dropped files to the scope model
 *      <strong>ngf-drop</strong> <strong>ng-model</strong>=<em>"myFiles"</em>
 *
 *      // bind to dropped files that do not match the accept wildcard
 *      <strong>ng-model-rejected</strong>=<em>"rejFiles"</em>
 *
 *      //called upon files being dropped
 *      <strong>ngf-change</strong>=<em>"fileDropped($files, $event, $rejectedFiles)"</em>
 *
 *      // default false, allows selecting multiple files.
 *      <strong>ngf-multiple</strong>=<em>"true|false"</em>
 *
 *       // function or comma separated wildcard to filter files allowed
 *      <strong>ngf-accept</strong>=<em>"'.pdf,.jpg'|validate($file)"</em>
 *
 *       // default true, allow dropping files only for Chrome webkit browser
 *      <strong>ngf-allow-dir</strong>=<em>"true|false"</em>
 *
 *
 *       // drag over css class behaviour. could be a string, a function returning class name
 *       // or a json object {accept: 'c1', reject: 'c2', delay:10}. default "dragover"
 *       // reject class only works in Chrome. Validation only on file type.
 *      <strong>ngf-drag-over-class</strong>=<em>"{accept:'acceptClass', reject:'rejectClass', delay:100}|myDragOverClass|
 *                      calcDragOverClass($event)"</em>
 *
 *
 *      // set the value of scope model to true or false based on file
 *      // drag&drop support for this browser
 *      <strong>ngf-drop-available</strong>=<em>"dropSupported"</em>
 *
 *      // default false, whether to propagate drag/drop events.
 *      <strong>ngf-stop-propagation</strong>=<em>"true|false"</em>
 *
 *      // default false, hides element if file drag&drop is not supported
 *      <strong>ngf-hide-on-drop-not-available</strong>=<em>"true|false"</em>
 *
 *      // minimum acceptable file size in bytes
 *      <strong>ngf-min-size</strong>=<em>'10'</em>
 *
 *      // maximum acceptable file size in bytes
 *      <strong>ngf-max-size</strong>=<em>'10'</em>
 *  &gt;
 *  Drop files here
 *  &lt;/div&gt;
 *  &lt;div|... ng-no-file-drop&gt;File Drag/drop is not supported&lt;/div&gt;
 *  </code></pre>
 *
 *  <br />
 *  <br />
 *  ### Upload multiple files:
 *  Only for HTML5 FormData browsers (not IE8-9) if you pass an array of files to `file` option it will upload all of them together in one request. In this case the `fileFormDataName` could be an array of names or a single string. For Rails or depending on your server append square brackets to the end (i.e. `file[]`).
 *  Non-html5 browsers due to flash limitation will still upload array of files one by one in a separate request. You should iterate over files and send them one by one if you want cross browser solution.
 *
 *  ### Drag and drop styling:
 *  For file drag and drop, `ngf-drag-over-class` could be used to style the drop zone. It can be a function that returns a class name based on the $event. Default is "dragover" string.
 *  Only in chrome It could be a json object `{accept: 'a', 'reject': 'r', delay: 10}` that specify the class name for the accepted or rejected drag overs. The validation `ng-accept` could only check the file type since that is the only property of the file that is reported by the browser on drag. So you cannot validate the file size or name on drag. There is also some limitation on some file types which are not reported by Chrome.
 *  `delay` param is there to fix css3 transition issues from dragging over/out/over [#277](https://github.com/danialfarid/angular-file-upload/issues/277).
 *
 *
 *  ### Cancel/Abort the upload in progress:
 *  ```js
 *  var upload = Upload.upload({ ... });
 *  upload.abort();
 *  ```
 *
 *
 *  ### Using as a promise. (Note that returned promise doesn't have progress, xhr and cancel functions):
 * ```js
 *  var upload  = Upload.upload({ ... }),
 *      promise = upload.then(success, error, progress);
 * ```
 */

/**
 * @ngdoc service
 * @name ngFileUpload
 * @module enspire.ui.components.fileUpload
 *
 * @description
 * Uploads file(s) to server. The service is called `Upload`.
 *
 * @usage
 * <hljs lang="js">
 *     Upload.upload({
 *         'url': 'some url',
 *         'fields': {'foo': 'bar'},
 *         'file': file
 *      })
 *      .progress(function (evt) {
 *         var progressPercentage = parseInt(100.0 * evt.loaded / evt.total);
 *         console.log('progress: ' + progressPercentage + '% ' + evt.config.file.name);
 *      })
 *      .success(function (data, status, headers, config) {
 *         console.log('file ' + config.file.name + 'uploaded. Response: ' + data);
 *         alert('Upload Complete!');
 *      });
 * </hljs>
 *
 *  ## Upload service:
 *  Property              | Example                           | Description
 *  ----------------------|-----------------------------------|-----------------------
 *  url                   |                                   | **Required.** Url to upload to.
 *  file                  |                                   | **Required.** Single file or an array of files to upload (array is for html5 only)
 *  method                |                                   | 'POST' or 'PUT', default POST.
 *  headers               | headers: {'Authorization': 'xxx'} | XHR headers to send. Applies to HTML5 only.
 *  fileName              | fileName: 'doc.jpg' or ['1.jpg', '2.jpg', ...] | Modifies the name of the file(s).
 *  fileFormDataName      | fileFormDataName: 'myFile' or ['file[0]', 'file[1]', ...] | File formData name ('Content-Disposition'), server side request form name could be an array  of names for multiple files (html5). Default is 'file'
 *  fields                | fields: {key: $scope.myValue, ...} | Map of extra form data fields to send along with file. Each field will be sent as a form field. The values are converted to json string or jsob blob depending on 'sendObjectsAsJsonBlob' option.
 *  sendObjectsAsJsonBlob | sendObjectsAsJsonBlob: true&#124;false | If the value of a form field is an object it will be sent as 'application/json' blob rather than json string, default false.
 *  formDataAppender      | formDataAppender: function(formData, key, val){} | Customize how data is added to the formData. See #40#issuecomment-28612000 for sample code.
 *  data                  | data: {}                           | Data will be sent as a separate form data field called "data". It will be converted to json string or jsob blob depending on 'sendObjectsAsJsonBlob' option.
 *  withCredentials       | withCredentials: true&#42;false    | Boolean indicating whether or not to send with credentials.
 *
 *
 * Methods                | Example                            | Description
 * -----------------------|------------------------------------|----------------------------
 * upload                 | .upload({options})                 | Uploads file(s).
 * progress               | .progress(function(evt){ ... })    | Use to show file upload progress by passing in callback function. First parameter of the function is an event object with .loaded, .total and .config properties. Example usage: `console.log('progress: ' + parseInt(100.0 * evt.loaded / evt.total) + '% file :'+ evt.config.file.name);`
 * success                | .success(function(data, status, headers, config) { ... }) | Called when the file upload is complete.
 * error                  | .error(function(error) { ... })    | Called on error.
 * xhr                    | .xhr(function(xhr){xhr.upload.addEventListener(...)}) | Access or attach event listeners to the underlying XMLHttpRequest
 *
 *
 *  <pre><code class="highlight">
 *  var upload = Upload<em>.upload</em>({
 *
 *    // upload.php script, node.js route, or servlet url
 *    <strong>*url:</strong> 'server/upload/url',
 *
 *    // single file or an array of files (array is for html5 only)
 *    <strong>*file:</strong> file,
 *
 *    <strong>method:</strong> 'POST' or 'PUT', default POST,
 *
 *    // only for html5
 *    <strong>headers:</strong> {'Authorization': 'xxx'},
 *
 *    // to modify the name of the file(s)
 *    <strong>fileName:</strong> 'doc.jpg' or ['1.jpg', '2.jpg', ...],
 *
 *
 *    // file formData name ('Content-Disposition'), server side request form name could be
 *    // an array  of names for multiple files (html5). Default is 'file'
 *    <strong>fileFormDataName:</strong> 'myFile' or ['file[0]', 'file[1]', ...],
 *
 *
 *    // map of extra form data fields to send along with file. each field will be sent as a form field.
 *    // The values are converted to json string or jsob blob depending on 'sendObjectsAsJsonBlob' option.
 *    <strong>fields:</strong> {key: $scope.myValue, ...},
 *
 *
 *    // if the value of a form field is an object it will be sent as 'application/json' blob
 *    // rather than json string, default false.
 *    <strong>sendObjectsAsJsonBlob:</strong> true|false,
 *
 *
 *    // customize how data is added to the formData. See #40#issuecomment-28612000 for sample code.
 *    <strong>formDataAppender:</strong> function(formData, key, val){},
 *
 *
 *    // data will be sent as a separate form data field called "data". It will be converted to json string
 *    // or jsob blob depending on 'sendObjectsAsJsonBlob' option
 *    <strong>data:</strong> {}.
 *
 *    <strong>withCredentials:</strong> true|false,
 *    ... and all other angular $http() options could be used here.
 *
 *  })<em>.progress</em>(function(evt) {
 *    console.log('progress: ' + parseInt(100.0 * evt.loaded / evt.total) + '% file :'+ evt.config.file.name);
 *
 *  })<em>.success</em>(function(data, status, headers, config) {
 *    // file is uploaded successfully
 *    console.log('file ' + config.file.name + 'is uploaded successfully. Response: ' + data);
 *
 *  })<em>.error</em>(...
 *
 *
 *  // access or attach event listeners to the underlying XMLHttpRequest
 *  })<em>.xhr</em>(function(xhr){xhr.upload.addEventListener(...)
 *
 *
 *  // return $http promise then(). Note that this promise does NOT have progress/abort/xhr functions
 *  });
 *
 *  // then promise (note that returned promise doesn't have progress, xhr and cancel functions.
 *  var promise = upload.then(success, error, progress);
 *
 *  // cancel/abort the upload in progress.
 *  upload.abort();
 *
 *
 *  // alternative way of uploading, send the file binary with the file's content-type.
 *  // Could be used to upload files to CouchDB, imgur, etc... html5 FileReader is needed.
 *  // It could also be used to monitor the progress of a normal http post/put request.
 *
 *  Upload.http({
 *              url: '/server/upload/url',
 *              headers : {
 *                  'Content-Type': file.type
 *              },
 *              data: file
 *  })
 *  </code></pre>
 *
 *  <br />
 *  <br />
 *
 *  ### Upload multiple files:
 *  Only for HTML5 FormData browsers (not IE8-9) if you pass an array of files to `file` option it will upload all of them together in one request. In this case the `fileFormDataName` could be an array of names or a single string. For Rails or depending on your server append square brackets to the end (i.e. `file[]`).
 *  Non-html5 browsers due to flash limitation will still upload array of files one by one in a separate request. You should iterate over files and send them one by one if you want cross browser solution.
 *
 *
 *  ###Upload.http():
 *  This is equivalent to angular $http() but allow you to listen to the progress event for HTML5 browsers.
 *
 *
 *  ### Drag and drop styling:
 *  For file drag and drop, `ngf-drag-over-class` could be used to style the drop zone. It can be a function that returns a class name based on the $event. Default is "dragover" string.
 *  Only in chrome It could be a json object `{accept: 'a', 'reject': 'r', delay: 10}` that specify the class name for the accepted or rejected drag overs. The validation `ng-accept` could only check the file type since that is the only property of the file that is reported by the browser on drag. So you cannot validate the file size or name on drag. There is also some limitation on some file types which are not reported by Chrome.
 *  `delay` param is there to fix css3 transition issues from dragging over/out/over [#277](https://github.com/danialfarid/angular-file-upload/issues/277).
 *
 *
 *  ### Cancel/Abort the upload in progress:
 *  ```js
 *  var upload = Upload.upload({ ... });
 *  upload.abort();
 *  ```
 *
 *
 *  ### Using as a promise. (Note that returned promise doesn't have progress, xhr and cancel functions):
 * ```js
 *  var upload  = Upload.upload({ ... }),
 *      promise = upload.then(success, error, progress);
 * ```
 */

(function () {


        var ngFileUpload = angular.module('ngFileUpload', []);

        ngFileUpload.version = '5.0.1';
        ngFileUpload.service('Upload', ['$http', '$q', '$timeout', function ($http, $q, $timeout) {

            /**
             * Added ChunckUploader for chunk support
             * Start of modifications
             */
            function ChunkedUploader(options) {
                if (!this instanceof ChunkedUploader) {
                    return new ChunkedUploader(options);
                }

                var self = this;

                this.file = options.file;
                this.fileSize = Number(this.file.size);
                this.chunkSize = (options.chunkSize || 5) * 1024; // Default 100KB
                this.options = options;
                this.rangeStart = 0;
                this.rangeEnd = this.chunkSize;

                if ('mozSlice' in this.file) {
                    this.sliceMethod = 'mozSlice';
                }
                else if ('webkitSlice' in this.file) {
                    this.sliceMethod = 'webkitSlice';
                }
                else {
                    this.sliceMethod = 'slice';
                }

                //this.uploadRequest = new XMLHttpRequest();
                this.uploadRequest = options.xhr;
                this.uploadRequest.onload = function(e) {
                    self._onChunkComplete.call(self, e);
                }
            }

            ChunkedUploader.prototype = {
                _upload: function() {
                    var self = this,
                        chunk;

                    // Slight timeout needed here (File read / AJAX readystate conflict?)
                    setTimeout(function() {
                        // Prevent range overflow
                        if (self.rangeEnd > self.fileSize) {
                            self.rangeEnd = self.fileSize;
                        }

                        chunk = self.file[self.sliceMethod](self.rangeStart, self.rangeEnd);

                        self.uploadRequest.open('PUT', self.options.url, true);
                        self.uploadRequest.overrideMimeType('application/octet-stream');

                        if (self.rangeStart !== 0) {
                            self.uploadRequest.setRequestHeader('Content-Range', 'bytes ' + self.rangeStart + '-' + self.rangeEnd + '/' + self.fileSize);
                        }

                        self.uploadRequest.send(chunk);

                    }, 20);
                },

                _onChunkComplete: function(evt) {
                    //Normalize event
                    var loaded = Number(this.rangeEnd),
                        totalSize = Number(this.file.size)
                        chunkLoaded = Number(evt.loaded),

                        e = {
                                'chunkLoaded': chunkLoaded,
                                'loaded': loaded,
                                'total': totalSize,
                                'totalSize': totalSize,
                                'config': this.options,
                                'event': evt
                            };

                    // If the end range is already the same size as our file, we
                    // can assume that our last chunk has been processed and exit
                    // out of the function.
                    if (this.rangeEnd === this.fileSize) {
                        this._onUploadComplete &&
                        this._onUploadComplete(
                            // data
                            e,
                            // status
                            evt.target.status,
                            // headers
                            JSON.parse(evt.target.response),
                            // config
                            evt.config
                        );
                        console.log('Transfer Complete!');
                        return;
                    }

                    // Update our ranges
                    this.rangeStart = this.rangeEnd;
                    this.rangeEnd = this.rangeStart + this.chunkSize;

                    // Continue as long as we aren't paused
                    if (!this.isPaused) {
                        this._upload();
                    }

                    this._onUpdate.call(this, e);
                },

               /**
                * Public Methods
                * ---------------
                */
                abort: function() {

                },
                start: function() {
                    this._upload();
                },

                pause: function() {
                    this.isPaused = true;
                },

                resume: function() {
                    this.isPaused = false;
                    this._upload();
                }
            };
          /* End of modifications */


          function patchXHR(fnName, newFn) {
            window.XMLHttpRequest.prototype[fnName] = newFn(window.XMLHttpRequest.prototype[fnName]);
          }

          if (window.XMLHttpRequest && !window.XMLHttpRequest.__isFileAPIShim) {
            patchXHR('setRequestHeader', function (orig) {
              return function (header, value) {
                if (header === '__setXHR_') {
                  var val = value(this);
                  // fix for angular < 1.2.0
                  if (val instanceof Function) {
                    val(this);
                  }
                } else {
                  orig.apply(this, arguments);
                }
              };
            });
          }

          function sendHttp(config) {
            config.method = config.method || 'POST';
            config.headers = config.headers || {};

            var deferred =
                $q.defer();
            var promise = deferred.promise;

            config.headers.__setXHR_ = function () {
              return function (xhr) {
                if (!xhr) return;
                config.__XHR = xhr;
                if (config.xhrFn) config.xhrFn(xhr);
                xhr.upload.addEventListener('progress', function (e) {
                  e.config = config;
                  if (deferred.notify) {
                    deferred.notify(e);
                  } else if (promise.progressFunc) {
                    $timeout(function () {
                      promise.progressFunc(e);
                    });
                  }
                }, false);
                //fix for firefox not firing upload progress end, also IE8-9
                xhr.upload.addEventListener('load', function (e) {
                  if (e.lengthComputable) {
                    e.config = config;
                    if (deferred.notify) {
                      deferred.notify(e);
                    } else if (promise.progressFunc) {
                      $timeout(function () {
                        promise.progressFunc(e);
                      });
                    }
                  }
                }, false);
              };
            };


            /*  Start of modifications to library */

            // Enable sending by chunks?
            if (config.enableChunks) {
                var chunkXHR = new XMLHttpRequest(),
                    chunkUpload = new ChunkedUploader({
                        'url': config.url,
                        'file': config.file,
                        'xhr': chunkXHR,
                        'chunkSize': config.chunkSize,
                    });
                chunkUpload._onUploadComplete = function(e){
                    deferred.resolve(e);
                }
                chunkUpload._onUpdate = function(e) {
                    deferred.notify(e);
                }
                chunkXHR.onerror = function(e) {
                    deferred.reject(e);
                }
                chunkUpload.start();

            }
            // Otherwise continue with using $http
            else {
                $http(config).then(function (r) {
                  deferred.resolve(r);
                }, function (e) {
                  deferred.reject(e);
                }, function (n) {
                  deferred.notify(n);
                });
            }
            /* End of modifications */


            promise.success = function (fn) {
              promise.then(function (response) {
                fn(response.data, response.status, response.headers, config);
              });
              return promise;
            };

            promise.error = function (fn) {
              promise.then(null, function (response) {
                fn(response.data, response.status, response.headers, config);
              });
              return promise;
            };

            promise.progress = function (fn) {
              promise.progressFunc = fn;
              promise.then(null, null, function (update) {
                fn(update);
              });
              return promise;
            };
            promise.abort = function () {
              if (config.__XHR) {
                $timeout(function () {
                  config.__XHR.abort();
                });
              }
              return promise;
            };
            promise.xhr = function (fn) {
              config.xhrFn = (function (origXhrFn) {
                return function () {
                  if (origXhrFn) origXhrFn.apply(promise, arguments);
                  fn.apply(promise, arguments);
                };
              })(config.xhrFn);
              return promise;
            };

            return promise;
          }

          this.upload = function (config) {
            function addFieldToFormData(formData, val, key) {
              if (val !== undefined) {
                if (angular.isDate(val)) {
                  val = val.toISOString();
                }
                if (angular.isString(val)) {
                  formData.append(key, val);
                } else if (config.sendFieldsAs === 'form') {
                  if (angular.isObject(val)) {
                    for (var k in val) {
                      if (val.hasOwnProperty(k)) {
                        addFieldToFormData(formData, val[k], key + '[' + k + ']');
                      }
                    }
                  } else {
                    formData.append(key, val);
                  }
                } else {
                  val = angular.isString(val) ? val : JSON.stringify(val);
                  if (config.sendFieldsAs === 'json-blob') {
                    formData.append(key, new Blob([val], {type: 'application/json'}));
                  } else {
                    formData.append(key, val);
                  }
                }
              }
            }

            config.headers = config.headers || {};
            config.headers['Content-Type'] = undefined;
            config.transformRequest = config.transformRequest ?
              (angular.isArray(config.transformRequest) ?
                config.transformRequest : [config.transformRequest]) : [];
            config.transformRequest.push(function (data) {
              var formData = new FormData();
              var allFields = {};
              var key;
              for (key in config.fields) {
                if (config.fields.hasOwnProperty(key)) {
                  allFields[key] = config.fields[key];
                }
              }
              if (data) allFields.data = data;
              for (key in allFields) {
                if (allFields.hasOwnProperty(key)) {
                  var val = allFields[key];
                  if (config.formDataAppender) {
                    config.formDataAppender(formData, key, val);
                  } else {
                    addFieldToFormData(formData, val, key);
                  }
                }
              }

              if (config.file != null) {
                var fileFormName = config.fileFormDataName || 'file';

                if (angular.isArray(config.file)) {
                  var isFileFormNameString = angular.isString(fileFormName);
                  for (var i = 0; i < config.file.length; i++) {
                    formData.append(isFileFormNameString ? fileFormName : fileFormName[i], config.file[i],
                      (config.fileName && config.fileName[i]) || config.file[i].name);
                  }
                } else {
                  formData.append(fileFormName, config.file, config.fileName || config.file.name);
                }
              }
              return formData;
            });

            return sendHttp(config);
          };

          this.http = function (config) {
            config.transformRequest = config.transformRequest || function (data) {
                if (window.ArrayBuffer && data instanceof window.ArrayBuffer) {
                  return data;
                }
                return $http.defaults.transformRequest[0](arguments);
              };
            return sendHttp(config);
          };
        }

        ])
        ;

        (function () {
            ngFileUpload.directive('ngfSelect', ['$parse', '$timeout', '$compile',
                function ($parse, $timeout, $compile) {
                    return {
                        restrict: 'AEC',
                        require: '?ngModel',
                        link: function (scope, elem, attr, ngModel) {
                            linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile);
                        }
                    };
                }]);

            function linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile) {
                /** @namespace attr.ngfSelect */
                /** @namespace attr.ngfChange */
                /** @namespace attr.ngModel */
                /** @namespace attr.ngModelRejected */
                /** @namespace attr.ngfMultiple */
                /** @namespace attr.ngfCapture */
                /** @namespace attr.ngfAccept */
                /** @namespace attr.ngfMaxSize */
                /** @namespace attr.ngfMinSize */
                /** @namespace attr.ngfResetOnClick */
                /** @namespace attr.ngfResetModelOnClick */
                /** @namespace attr.ngfKeep */
                /** @namespace attr.ngfKeepDistinct */

                if (elem.attr('__ngf_gen__')) {
                    return;
                }

                scope.$on('$destroy', function () {
                    if (elem.$$ngfRefElem) elem.$$ngfRefElem.remove();
                });

                var disabled = false;
                if (attr.ngfSelect.search(/\W+$files\W+/) === -1) {
                    scope.$watch(attr.ngfSelect, function (val) {
                        disabled = val === false;
                    });
                }
                function isInputTypeFile() {
                    return elem[0].tagName.toLowerCase() === 'input' && attr.type && attr.type.toLowerCase() === 'file';
                }

                var isUpdating = false;

                function changeFn(evt) {
                    if (!isUpdating) {
                        isUpdating = true;
                        try {
                            var fileList = evt.__files_ || (evt.target && evt.target.files);
                            var files = [], rejFiles = [];

                            for (var i = 0; i < fileList.length; i++) {
                                var file = fileList.item(i);
                                if (validate(scope, $parse, attr, file, evt)) {
                                    files.push(file);
                                } else {
                                    rejFiles.push(file);
                                }
                            }
                            updateModel($parse, $timeout, scope, ngModel, attr, attr.ngfChange || attr.ngfSelect, files, rejFiles, evt);
                            if (files.length === 0) evt.target.value = files;
        //                if (evt.target && evt.target.getAttribute('__ngf_gen__')) {
        //                    angular.element(evt.target).remove();
        //                }
                        } finally {
                            isUpdating = false;
                        }
                    }
                }

                function bindAttrToFileInput(fileElem) {
                    if (attr.ngfMultiple) fileElem.attr('multiple', $parse(attr.ngfMultiple)(scope));
                    if (attr.ngfCapture) fileElem.attr('capture', $parse(attr.ngfCapture)(scope));
                    if (attr.accept) fileElem.attr('accept', attr.accept);
                    for (var i = 0; i < elem[0].attributes.length; i++) {
                        var attribute = elem[0].attributes[i];
                        if ((isInputTypeFile() && attribute.name !== 'type') ||
                            (attribute.name !== 'type' && attribute.name !== 'class' &&
                            attribute.name !== 'id' && attribute.name !== 'style')) {
                            fileElem.attr(attribute.name, attribute.value);
                        }
                    }
                }

                function createFileInput(evt, resetOnClick) {
                    if (elem.attr('disabled') || disabled) return;

                    if (!resetOnClick && (evt || isInputTypeFile())) return elem.$$ngfRefElem || elem;

                    var fileElem = angular.element('<input type="file">');
                    bindAttrToFileInput(fileElem);

                    if (isInputTypeFile()) {
                        elem.replaceWith(fileElem);
                        elem = fileElem;
                        fileElem.attr('__ngf_gen__', true);
                        $compile(elem)(scope);
                    } else {
                        fileElem.css('visibility', 'hidden').css('position', 'absolute')
                            .css('width', '9').css('height', '1').css('z-index', '-100000')
                            .attr('tabindex', '-1');
                        if (elem.$$ngfRefElem) {
                            elem.$$ngfRefElem.remove();
                        }
                        elem.$$ngfRefElem = fileElem;
                        document.body.appendChild(fileElem[0]);
                    }

                    return fileElem;
                }

                function resetModel(evt) {
                    updateModel($parse, $timeout, scope, ngModel, attr, attr.ngfChange || attr.ngfSelect, [], [], evt, true);
                }

                function clickHandler(evt) {
                    if (evt != null) {
                        evt.preventDefault();
                        evt.stopPropagation();
                    }
                    var resetOnClick = $parse(attr.ngfResetOnClick)(scope) !== false;
                    var fileElem = createFileInput(evt, resetOnClick);

                    function clickAndAssign(evt) {
                        if (evt) {
                            fileElem[0].click();
                        }
                        if (isInputTypeFile() || !evt) {
                            elem.bind('click touchend', clickHandler);
                        }
                    }

                    if (fileElem) {
                        if (!evt || resetOnClick) fileElem.bind('change', changeFn);
                        if (evt && resetOnClick && $parse(attr.ngfResetModelOnClick)(scope) !== false) resetModel(evt);

                        // fix for android native browser < 4.4
                        if (isAndroidBelow44(navigator.userAgent)) {
                            setTimeout(function () {
                                clickAndAssign(evt);
                            }, 0);
                        } else {
                            clickAndAssign(evt);
                        }
                    }
                    return false;
                }

                if (window.FileAPI && window.FileAPI.ngfFixIE) {
                    window.FileAPI.ngfFixIE(elem, createFileInput, bindAttrToFileInput, changeFn);
                } else {
                    clickHandler();
                    //if (!isInputTypeFile()) {
                    //  elem.bind('click touchend', clickHandler);
                    //}
                }
            }

            function isAndroidBelow44(ua) {
                var m = ua.match(/Android[^\d]*(\d+)\.(\d+)/);
                if (m && m.length > 2) {
                    return parseInt(m[1]) < 4 || (parseInt(m[1]) === 4 && parseInt(m[2]) < 4);
                }

                return false;
            }

            ngFileUpload.validate = function (scope, $parse, attr, file, evt) {
                function globStringToRegex(str) {
                    if (str.length > 2 && str[0] === '/' && str[str.length - 1] === '/') {
                        return str.substring(1, str.length - 1);
                    }
                    var split = str.split(','), result = '';
                    if (split.length > 1) {
                        for (var i = 0; i < split.length; i++) {
                            result += '(' + globStringToRegex(split[i]) + ')';
                            if (i < split.length - 1) {
                                result += '|';
                            }
                        }
                    } else {
                        if (str.indexOf('.') === 0) {
                            str = '*' + str;
                        }
                        result = '^' + str.replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\' + '-]', 'g'), '\\$&') + '$';
                        result = result.replace(/\\\*/g, '.*').replace(/\\\?/g, '.');
                    }
                    return result;
                }

                var accept = $parse(attr.ngfAccept)(scope, {$file: file, $event: evt});
                var fileSizeMax = $parse(attr.ngfMaxSize)(scope, {$file: file, $event: evt}) || 9007199254740991;
                var fileSizeMin = $parse(attr.ngfMinSize)(scope, {$file: file, $event: evt}) || -1;
                if (accept != null && angular.isString(accept)) {
                    var regexp = new RegExp(globStringToRegex(accept), 'gi');
                    accept = (file.type != null && regexp.test(file.type.toLowerCase())) ||
                        (file.name != null && regexp.test(file.name.toLowerCase()));
                }
                return (accept == null || accept) && (file.size == null || (file.size < fileSizeMax && file.size > fileSizeMin));
            };

            ngFileUpload.updateModel = function ($parse, $timeout, scope, ngModel, attr, fileChange,
                                                 files, rejFiles, evt, noDelay) {
                function update() {
                    if ($parse(attr.ngfKeep)(scope) === true) {
                        if (!files || !files.length) {
                            return;
                        }
                        if ($parse(attr.ngfKeepDistinct)(scope) === true) {
                            var prevFiles = (ngModel.$modelValue || []).slice(0), len = prevFiles.length;
                            for (var i = 0; i < files.length; i++) {
                                for (var j = 0; j < len; j++) {
                                    if (files[i].name === prevFiles[j].name) break;
                                }
                                if (j === len) {
                                    prevFiles.push(files[i]);
                                }
                            }
                            if (len === prevFiles.length) {
                                return;
                            }
                            files = [].concat(prevFiles);
                        } else {
                            files = (ngModel.$modelValue || []).concat(files);
                        }
                    }
                    if (ngModel) {
                        $parse(attr.ngModel).assign(scope, files);
                        $timeout(function () {
                            if (ngModel) {
                                ngModel.$setViewValue(files != null && files.length === 0 ? null : files);
                            }
                        });
                    }
                    if (attr.ngModelRejected) {
                        $parse(attr.ngModelRejected).assign(scope, rejFiles);
                    }
                    if (fileChange) {
                        $parse(fileChange)(scope, {
                            $files: files,
                            $rejectedFiles: rejFiles,
                            $event: evt
                        });
                    }
                }

                if (noDelay) {
                    update();
                } else {
                    $timeout(function () {
                        update();
                    });
                }
            };

            var validate = ngFileUpload.validate;
            var updateModel = ngFileUpload.updateModel;

        })();

        (function () {
          var validate = ngFileUpload.validate;
          var updateModel = ngFileUpload.updateModel;

          ngFileUpload.directive('ngfDrop', ['$parse', '$timeout', '$location', function ($parse, $timeout, $location) {
            return {
              restrict: 'AEC',
              require: '?ngModel',
              link: function (scope, elem, attr, ngModel) {
                linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $location);
              }
            };
          }]);

          ngFileUpload.directive('ngfNoFileDrop', function () {
            return function (scope, elem) {
              if (dropAvailable()) elem.css('display', 'none');
            };
          });

          ngFileUpload.directive('ngfDropAvailable', ['$parse', '$timeout', function ($parse, $timeout) {
            return function (scope, elem, attr) {
              if (dropAvailable()) {
                var fn = $parse(attr.ngfDropAvailable);
                $timeout(function () {
                  fn(scope);
                  if (fn.assign) {
                    fn.assign(scope, true);
                  }
                });
              }
            };
          }]);

          function linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $location) {
            var available = dropAvailable();
            if (attr.dropAvailable) {
              $timeout(function () {
                if (scope[attr.dropAvailable]) {
                  scope[attr.dropAvailable].value = available;
                } else {
                  scope[attr.dropAvailable] = available;
                }
              });
            }
            if (!available) {
              if ($parse(attr.ngfHideOnDropNotAvailable)(scope) === true) {
                elem.css('display', 'none');
              }
              return;
            }

            var disabled = false;
            if (attr.ngfDrop.search(/\W+$files\W+/) === -1) {
              scope.$watch(attr.ngfDrop, function(val) {
                disabled = val === false;
              });
            }

            var leaveTimeout = null;
            var stopPropagation = $parse(attr.ngfStopPropagation);
            var dragOverDelay = 1;
            var actualDragOverClass;

            elem[0].addEventListener('dragover', function (evt) {
              if (elem.attr('disabled') || disabled) return;
              evt.preventDefault();
              if (stopPropagation(scope)) evt.stopPropagation();
              // handling dragover events from the Chrome download bar
              if (navigator.userAgent.indexOf('Chrome') > -1) {
                var b = evt.dataTransfer.effectAllowed;
                evt.dataTransfer.dropEffect = ('move' === b || 'linkMove' === b) ? 'move' : 'copy';
              }
              $timeout.cancel(leaveTimeout);
              if (!scope.actualDragOverClass) {
                actualDragOverClass = calculateDragOverClass(scope, attr, evt);
              }
              elem.addClass(actualDragOverClass);
            }, false);
            elem[0].addEventListener('dragenter', function (evt) {
              if (elem.attr('disabled') || disabled) return;
              evt.preventDefault();
              if (stopPropagation(scope)) evt.stopPropagation();
            }, false);
            elem[0].addEventListener('dragleave', function () {
              if (elem.attr('disabled') || disabled) return;
              leaveTimeout = $timeout(function () {
                elem.removeClass(actualDragOverClass);
                actualDragOverClass = null;
              }, dragOverDelay || 1);
            }, false);
            elem[0].addEventListener('drop', function (evt) {
              if (elem.attr('disabled') || disabled) return;
              evt.preventDefault();
              if (stopPropagation(scope)) evt.stopPropagation();
              elem.removeClass(actualDragOverClass);
              actualDragOverClass = null;
              extractFiles(evt, function (files, rejFiles) {
                updateModel($parse, $timeout, scope, ngModel, attr,
                  attr.ngfChange || attr.ngfDrop, files, rejFiles, evt);
              }, $parse(attr.ngfAllowDir)(scope) !== false, attr.multiple || $parse(attr.ngfMultiple)(scope));
            }, false);

            function calculateDragOverClass(scope, attr, evt) {
              var accepted = true;
              var items = evt.dataTransfer.items;
              if (items != null) {
                for (var i = 0; i < items.length && accepted; i++) {
                  accepted = accepted &&
                    (items[i].kind === 'file' || items[i].kind === '') &&
                    validate(scope, $parse, attr, items[i], evt);
                }
              }
              var clazz = $parse(attr.ngfDragOverClass)(scope, {$event: evt});
              if (clazz) {
                if (clazz.delay) dragOverDelay = clazz.delay;
                if (clazz.accept) clazz = accepted ? clazz.accept : clazz.reject;
              }
              return clazz || attr.ngfDragOverClass || 'dragover';
            }

            function extractFiles(evt, callback, allowDir, multiple) {
              var files = [], rejFiles = [], items = evt.dataTransfer.items, processing = 0;

              function addFile(file) {
                if (validate(scope, $parse, attr, file, evt)) {
                  files.push(file);
                } else {
                  rejFiles.push(file);
                }
              }

              function traverseFileTree(files, entry, path) {
                if (entry != null) {
                  if (entry.isDirectory) {
                    var filePath = (path || '') + entry.name;
                    addFile({name: entry.name, type: 'directory', path: filePath});
                    var dirReader = entry.createReader();
                    var entries = [];
                    processing++;
                    var readEntries = function () {
                      dirReader.readEntries(function (results) {
                        try {
                          if (!results.length) {
                            for (var i = 0; i < entries.length; i++) {
                              traverseFileTree(files, entries[i], (path ? path : '') + entry.name + '/');
                            }
                            processing--;
                          } else {
                            entries = entries.concat(Array.prototype.slice.call(results || [], 0));
                            readEntries();
                          }
                        } catch (e) {
                          processing--;
                          console.error(e);
                        }
                      }, function () {
                        processing--;
                      });
                    };
                    readEntries();
                  } else {
                    processing++;
                    entry.file(function (file) {
                      try {
                        processing--;
                        file.path = (path ? path : '') + file.name;
                        addFile(file);
                      } catch (e) {
                        processing--;
                        console.error(e);
                      }
                    }, function () {
                      processing--;
                    });
                  }
                }
              }

              if (items && items.length > 0 && $location.protocol() !== 'file') {
                for (var i = 0; i < items.length; i++) {
                  if (items[i].webkitGetAsEntry && items[i].webkitGetAsEntry() && items[i].webkitGetAsEntry().isDirectory) {
                    var entry = items[i].webkitGetAsEntry();
                    if (entry.isDirectory && !allowDir) {
                      continue;
                    }
                    if (entry != null) {
                      traverseFileTree(files, entry);
                    }
                  } else {
                    var f = items[i].getAsFile();
                    if (f != null) addFile(f);
                  }
                  if (!multiple && files.length > 0) break;
                }
              } else {
                var fileList = evt.dataTransfer.files;
                if (fileList != null) {
                  for (var j = 0; j < fileList.length; j++) {
                    addFile(fileList.item(j));
                    if (!multiple && files.length > 0) {
                      break;
                    }
                  }
                }
              }
              var delays = 0;
              (function waitForProcess(delay) {
                $timeout(function () {
                  if (!processing) {
                    if (!multiple && files.length > 1) {
                      i = 0;
                      while (files[i].type === 'directory') i++;
                      files = [files[i]];
                    }
                    callback(files, rejFiles);
                  } else {
                    if (delays++ * 10 < 20 * 1000) {
                      waitForProcess(10);
                    }
                  }
                }, delay || 0);
              })();
            }
          }

          ngFileUpload.directive('ngfSrc', ['$parse', '$timeout', function ($parse, $timeout) {
            return {
              restrict: 'AE',
              link: function (scope, elem, attr) {
                if (window.FileReader) {
                  scope.$watch(attr.ngfSrc, function (file) {
                    if (file &&
                      validate(scope, $parse, attr, file, null) &&
                      (!window.FileAPI || navigator.userAgent.indexOf('MSIE 8') === -1 || file.size < 20000) &&
                      (!window.FileAPI || navigator.userAgent.indexOf('MSIE 9') === -1 || file.size < 4000000)) {
                      $timeout(function () {
                        //prefer URL.createObjectURL for handling refrences to files of all sizes
                        //since it doesn´t build a large string in memory
                        var URL = window.URL || window.webkitURL;
                        if (URL && URL.createObjectURL) {
                          elem.attr('src', URL.createObjectURL(file));
                        } else {
                          var fileReader = new FileReader();
                          fileReader.readAsDataURL(file);
                          fileReader.onload = function (e) {
                            $timeout(function () {
                              elem.attr('src', e.target.result);
                            });
                          };
                        }
                      });
                    } else {
                      elem.attr('src', attr.ngfDefaultSrc || '');
                    }
                  });
                }
              }
            };
          }]);

          function dropAvailable() {
            var div = document.createElement('div');
            return ('draggable' in div) && ('ondrop' in div);
          }

        })();

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
'use strict';

    angular.module('enspire.ui.components.form').directive('alwaysShowErrors', AlwaysShowErrorsDirective);

    /**
     * @ngdoc directive
     * @name showErrors
     * @module enspire.ui.components.form
     * @restrict A
     * @element always-show-errors
     *
     * @description
     * Extends the form to store the $alwaysShowErrors flag.
     *
     *
     * @usage
     * <hljs lang="html">

     * </hljs>
     *
     *
     *
     */

    //console.log('hello');

    function AlwaysShowErrorsDirective() {
        return {
            restrict    : 'A',
            require     : 'form',
            link        : postLink
        };

        function postLink($scope, $element, $attrs, form){
            form.$showErrors = true;
            $element.addClass('always-show-errors');

            if(angular.isDefined($attrs.alwaysShowErrors) && $attrs.alwaysShowErrors!==''){
                $scope.$watch(function(){ return $scope.$eval($attrs.alwaysShowErrors); },function(val){
                    if(val){
                        form.$alwaysShowErrors = true;
                        $element.addClass('always-show-errors');
                    }else{
                        form.$alwaysShowErrors = false;
                        $element.removeClass('always-show-errors');
                    }
                });
            }


        }

    }

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){

  'use strict'

    /**
     * angular-growl-v2 - v0.7.3 - 2015-02-22
     * http://janstevens.github.io/angular-growl-2
     * Copyright (c) 2015 Marco Rinck,Jan Stevens; Licensed MIT
     */
    angular.module('angular-growl', []);
    angular.module('angular-growl').directive('growl', [function () {
        'use strict';
        return {
          restrict: 'A',
          templateUrl: 'templates/growl/growl.html',
          replace: false,
          scope: {
            reference: '@',
            inline: '=',
            limitMessages: '='
          },
          controller: [
            '$scope',
            '$timeout',
            'growl',
            'growlMessages',
            function ($scope, $timeout, growl, growlMessages) {
              $scope.referenceId = $scope.reference || 0;
              growlMessages.initDirective($scope.referenceId, $scope.limitMessages);
              $scope.growlMessages = growlMessages;
              $scope.inlineMessage = angular.isDefined($scope.inline) ? $scope.inline : growl.inlineMessages();
              $scope.$watch('limitMessages', function (limitMessages) {
                var directive = growlMessages.directives[$scope.referenceId];
                if (!angular.isUndefined(limitMessages) && !angular.isUndefined(directive)) {
                  directive.limitMessages = limitMessages;
                }
              });
              $scope.stopTimeoutClose = function (message) {
                if (!message.clickToClose) {
                  angular.forEach(message.promises, function (promise) {
                    $timeout.cancel(promise);
                  });
                  if (message.close) {
                    growlMessages.deleteMessage(message);
                  } else {
                    message.close = true;
                  }
                }
              };
              $scope.alertClasses = function (message) {
                return {
                  'alert-success': message.severity === 'success',
                  'alert-error': message.severity === 'error',
                  'alert-danger': message.severity === 'error',
                  'alert-info': message.severity === 'info',
                  'alert-warning': message.severity === 'warning',
                  'icon': message.disableIcons === false,
                  'alert-dismissable': !message.disableCloseButton
                };
              };
              $scope.showCountDown = function (message) {
                return !message.disableCountDown && message.ttl > 0;
              };
              $scope.wrapperClasses = function () {
                var classes = {};
                classes['growl-fixed'] = !$scope.inlineMessage;
                classes[growl.position()] = true;
                return classes;
              };
              $scope.computeTitle = function (message) {
                var ret = {
                    'success': 'Success',
                    'error': 'Error',
                    'info': 'Information',
                    'warn': 'Warning'
                  };
                return ret[message.severity];
              };
            }
          ]
        };
      }]);
    angular.module('angular-growl').run([
      '$templateCache',
      function ($templateCache) {
        'use strict';
        if ($templateCache.get('templates/growl/growl.html') === undefined) {
          $templateCache.put('templates/growl/growl.html', '<div class="growl-container" ng-class="wrapperClasses()">' + '<div class="growl-item alert" ng-repeat="message in growlMessages.directives[referenceId].messages" ng-class="alertClasses(message)" ng-click="stopTimeoutClose(message)">' + '<button type="button" class="close" data-dismiss="alert" aria-hidden="true" ng-click="growlMessages.deleteMessage(message)" ng-show="!message.disableCloseButton">&times;</button>' + '<button type="button" class="close" aria-hidden="true" ng-show="showCountDown(message)">{{message.countdown}}</button>' + '<h4 class="growl-title" ng-show="message.title" ng-bind="message.title"></h4>' + '<div class="growl-message" ng-bind-html="message.text"></div>' + '</div>' + '</div>');
        }
      }
    ]);
    angular.module('angular-growl').provider('growl', function () {
      'use strict';
      var _ttl = {
          success: null,
          error: null,
          warning: null,
          info: null
        }, _messagesKey = 'messages', _messageTextKey = 'text', _messageTitleKey = 'title', _messageSeverityKey = 'severity', _onlyUniqueMessages = true, _messageVariableKey = 'variables', _referenceId = 0, _inline = false, _position = 'top-right', _disableCloseButton = false, _disableIcons = false, _reverseOrder = false, _disableCountDown = false, _translateMessages = true;
      this.globalTimeToLive = function (ttl) {
        if (typeof ttl === 'object') {
          for (var k in ttl) {
            if (ttl.hasOwnProperty(k)) {
              _ttl[k] = ttl[k];
            }
          }
        } else {
          for (var severity in _ttl) {
            if (_ttl.hasOwnProperty(severity)) {
              _ttl[severity] = ttl;
            }
          }
        }
      };
      this.globalTranslateMessages = function (translateMessages) {
        _translateMessages = translateMessages;
      };
      this.globalDisableCloseButton = function (disableCloseButton) {
        _disableCloseButton = disableCloseButton;
      };
      this.globalDisableIcons = function (disableIcons) {
        _disableIcons = disableIcons;
      };
      this.globalReversedOrder = function (reverseOrder) {
        _reverseOrder = reverseOrder;
      };
      this.globalDisableCountDown = function (countDown) {
        _disableCountDown = countDown;
      };
      this.messageVariableKey = function (messageVariableKey) {
        _messageVariableKey = messageVariableKey;
      };
      this.globalInlineMessages = function (inline) {
        _inline = inline;
      };
      this.globalPosition = function (position) {
        _position = position;
      };
      this.messagesKey = function (messagesKey) {
        _messagesKey = messagesKey;
      };
      this.messageTextKey = function (messageTextKey) {
        _messageTextKey = messageTextKey;
      };
      this.messageTitleKey = function (messageTitleKey) {
        _messageTitleKey = messageTitleKey;
      };
      this.messageSeverityKey = function (messageSeverityKey) {
        _messageSeverityKey = messageSeverityKey;
      };
      this.onlyUniqueMessages = function (onlyUniqueMessages) {
        _onlyUniqueMessages = onlyUniqueMessages;
      };
      this.serverMessagesInterceptor = [
        '$q',
        'growl',
        function ($q, growl) {
          function checkResponse(response) {
            if (response !== undefined && response.data[_messagesKey] && response.data[_messagesKey].length > 0) {
              growl.addServerMessages(response.data[_messagesKey]);
            }
          }
          return {
            'response': function (response) {
              checkResponse(response);
              return response;
            },
            'responseError': function (rejection) {
              checkResponse(rejection);
              return $q.reject(rejection);
            }
          };
        }
      ];
      this.$get = [
        '$rootScope',
        '$interpolate',
        '$sce',
        '$filter',
        '$timeout',
        'growlMessages',
        '$compile',
        function ($rootScope, $interpolate, $sce, $filter, $timeout, growlMessages, $compile) {
          var translate;

          if (document.querySelector('[growl]') === null) {
            var growlDirective = $compile('<div growl></div>')($rootScope.$new());
            $timeout(function(){
              angular.element(document.body).append( growlDirective );
            });
          }


          growlMessages.onlyUnique = _onlyUniqueMessages;
          growlMessages.reverseOrder = _reverseOrder;
          try {
            translate = $filter('translate');
          } catch (e) {
          }
          function broadcastMessage(message) {
            if (translate && message.translateMessage) {
              message.text = translate(message.text, message.variables);
              message.title = translate(message.title);
            } else {
              var polation = $interpolate(message.text);
              message.text = polation(message.variables);
            }
            var addedMessage = growlMessages.addMessage(message);
            $rootScope.$broadcast('growlMessage', message);
            $timeout(function () {
            }, 0);
            return addedMessage;
          }
          function sendMessage(text, config, severity) {
            var _config = config || {}, message;
            message = {
              text: text,
              title: _config.title,
              severity: severity,
              ttl: _config.ttl || _ttl[severity],
              variables: _config.variables || {},
              disableCloseButton: _config.disableCloseButton === undefined ? _disableCloseButton : _config.disableCloseButton,
              disableIcons: _config.disableIcons === undefined ? _disableIcons : _config.disableIcons,
              disableCountDown: _config.disableCountDown === undefined ? _disableCountDown : _config.disableCountDown,
              position: _config.position || _position,
              referenceId: _config.referenceId || _referenceId,
              translateMessage: _config.translateMessage === undefined ? _translateMessages : _config.translateMessage,
              destroy: function () {
                growlMessages.deleteMessage(message);
              },
              setText: function (newText) {
                message.text = $sce.trustAsHtml(String(newText));
              },
              onclose: _config.onclose,
              onopen: _config.onopen
            };
            return broadcastMessage(message);
          }
          function warning(text, config) {
            return sendMessage(text, config, 'warning');
          }
          function error(text, config) {
            return sendMessage(text, config, 'error');
          }
          function info(text, config) {
            return sendMessage(text, config, 'info');
          }
          function success(text, config) {
            return sendMessage(text, config, 'success');
          }
          function general(text, config, severity) {
            severity = (severity || 'error').toLowerCase();
            sendMessage(text, config, severity);
          }
          function addServerMessages(messages) {
            if (!messages || !messages.length) {
              return;
            }
            var i, message, severity, length;
            length = messages.length;
            for (i = 0; i < length; i++) {
              message = messages[i];
              if (message[_messageTextKey]) {
                severity = (message[_messageSeverityKey] || 'error').toLowerCase();
                var config = {};
                config.variables = message[_messageVariableKey] || {};
                config.title = message[_messageTitleKey];
                sendMessage(message[_messageTextKey], config, severity);
              }
            }
          }
          function onlyUnique() {
            return _onlyUniqueMessages;
          }
          function reverseOrder() {
            return _reverseOrder;
          }
          function inlineMessages() {
            return _inline;
          }
          function position() {
            return _position;
          }
          return {
            warning: warning,
            error: error,
            info: info,
            success: success,
            general: general,
            addServerMessages: addServerMessages,
            onlyUnique: onlyUnique,
            reverseOrder: reverseOrder,
            inlineMessages: inlineMessages,
            position: position
          };
        }
      ];
    });
    angular.module('angular-growl').service('growlMessages', [
      '$sce',
      '$timeout',
      function ($sce, $timeout) {
        'use strict';
        this.directives = {};
        var preloadDirectives = {};
        function preLoad(referenceId) {
          var directive;
          if (preloadDirectives[referenceId]) {
            directive = preloadDirectives[referenceId];
          } else {
            directive = preloadDirectives[referenceId] = { messages: [] };
          }
          return directive;
        }
        this.initDirective = function (referenceId, limitMessages) {
          if (preloadDirectives[referenceId]) {
            this.directives[referenceId] = preloadDirectives[referenceId];
            this.directives[referenceId].limitMessages = limitMessages;
          } else {
            this.directives[referenceId] = {
              messages: [],
              limitMessages: limitMessages
            };
          }
          return this.directives[referenceId];
        };
        this.getAllMessages = function (referenceId) {
          referenceId = referenceId || 0;
          var messages;
          if (this.directives[referenceId]) {
            messages = this.directives[referenceId].messages;
          } else {
            messages = [];
          }
          return messages;
        };
        this.destroyAllMessages = function (referenceId) {
          var messages = this.getAllMessages(referenceId);
          for (var i = messages.length - 1; i >= 0; i--) {
            messages[i].destroy();
          }
          if (this.directives[referenceId]) {
            this.directives[referenceId].messages = [];
          }
        };
        this.addMessage = function (message) {
          var directive, messages, found, msgText;
          if (this.directives[message.referenceId]) {
            directive = this.directives[message.referenceId];
          } else {
            directive = preLoad(message.referenceId);
          }
          messages = directive.messages;
          if (this.onlyUnique) {
            angular.forEach(messages, function (msg) {
              msgText = $sce.getTrustedHtml(msg.text);
              if (message.text === msgText && message.severity === msg.severity && message.title === msg.title) {
                found = true;
              }
            });
            if (found) {
              return;
            }
          }
          message.text = $sce.trustAsHtml(String(message.text));
          if (message.ttl && message.ttl !== -1) {
            message.countdown = message.ttl / 1000;
            message.promises = [];
            message.close = false;
            message.countdownFunction = function () {
              if (message.countdown > 1) {
                message.countdown--;
                message.promises.push($timeout(message.countdownFunction, 1000));
              } else {
                message.countdown--;
              }
            };
          }
          if (angular.isDefined(directive.limitMessages)) {
            var diff = messages.length - (directive.limitMessages - 1);
            if (diff > 0) {
              messages.splice(directive.limitMessages - 1, diff);
            }
          }
          if (this.reverseOrder) {
            messages.unshift(message);
          } else {
            messages.push(message);
          }
          if (typeof message.onopen === 'function') {
            message.onopen();
          }
          if (message.ttl && message.ttl !== -1) {
            message.promises.push($timeout(angular.bind(this, function () {
              this.deleteMessage(message);
            }), message.ttl));
            message.promises.push($timeout(message.countdownFunction, 1000));
          }
          return message;
        };
        this.deleteMessage = function (message) {
          var messages = this.directives[message.referenceId].messages, index = messages.indexOf(message);
          if (index > -1) {
            messages[index].close = true;
            messages.splice(index, 1);
          }
          if (typeof message.onclose === 'function') {
            message.onclose();
          }
        };
      }
    ]);

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    //angular.module('enspire.ui.components.icon').directive('enIcon', IconDirective);

    /**
     * @ngdoc directive
     * @name enIcon
     * @module enspire.ui.components.icon
     * @restrict E
     * @description
     * `en-icon` creates a styled icon element.
     *
     * @element en-icon
     *
     * @param {string}    icon      Name of the icon to be shown. View demo for a list of <a href="#/demo/enspire.ui.components.icon">available icons</a>.
     *
     * @usage
     * <hljs lang="html">
     *   <en-icon icon="{iconName}"></en-icon>
     * </hljs>
     *
     */

    //function IconDirective(){
    //    return {
    //        restrict    : 'E',
    //        link        : postLink
    //    };
    //
    //    function postLink($scope, $element, $attrs){
    //
    //    }
    //}
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';


    angular.module('enspire.ui.components.include')
        .directive('enInclude', IncludeDirective);


    /**
     * @ngdoc directive
     * @name enInclude
     * @module enspire.ui.components.include
     * @restrict E
     * @description
     * `en-include`... Includes a file.
     *
     * @element en-include
     *
     * @param {string} src Assignable url.
     *
     */

    function IncludeDirective($http, $compile, $templateCache) {
        return {
            restrict: 'E',
            link: postLink
        };

        function postLink($scope, $element, $attrs) {
            if(angular.isDefined($attrs.ngIf)){
                console.error('en-include SHOULD NOT use the "ng-if" attribute, instead put the "ng-if" on the parent element. <en-include src="'+$attrs.src+'">');
            }

            var currentTemplate = '';
            var parseTemplate = function (template) {
                if (template !== '' && template!==currentTemplate) {
                    currentTemplate = template;
                    var url = ('views/includes/' + template + '.html').replace(/\/\//g, '/');
                    if (template.length > 5) {
                        if (template.substring(template.length - 5) === '.html') url = template;
                    }

                    $http.get(url, {cache: $templateCache}).then(function (result) {
                        if(result.data.replace(/^\s+|\s+$/g,'').substring(1,0)!=='<'){
                            console.error('en-include file "'+url+'" contents must be wrapped in an element');
                            return false;
                        }
                        $compile(result.data)($scope, function (clonedElement, scope) {
                            $element.replaceWith(clonedElement);
                        });
                    });
                }
            };

            $attrs.$observe('src', parseTemplate);

            if(angular.isDefined($attrs.src)){
                parseTemplate($attrs.src);
            }
        }
    }
    IncludeDirective.$inject = ["$http", "$compile", "$templateCache"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.input').directive('enInput', InputDirective);

    /**
     * @ngdoc directive
     * @name enInput
     * @module enspire.ui.components.input
     * @restrict E
     * @element en-input
     * @description
     * `en-input` is used as a wrapper for standard text `<input>` elements when you want to visually place icons inside of 
     * the input itself. It is not required to wrap every input with `<en-input>`.
     *
     * @usage
     * 
     * ### As Standard Input
     * <hljs lang="html">
     *  <label>Input Label</label>
        <input type="text" name="demoInput" ng-model="demoInputValue" />
     * </hljs>
     * 
     * #### Output
     * <en-content>
     *  <label>Input Label</label>
     *  <input type="text" name="demoInput" ng-model="demoInputValue" />
     * </en-content>
     *
     * 
     * ### As Standard Input
     * <hljs lang="html">
     *  <label>Input Label</label>
        <input type="text" name="demoInput" ng-model="demoInputValue" />
     * </hljs>
     * 
     * #### Output
     * <en-content>
     *  <label>Input Label</label>
     *  <input type="text" name="demoInput" ng-model="demoInputValue" />
     * </en-content>
     * 
     * 
     * 
     * 
     * 
     * 
     * 
     * 
     */
    
    function InputDirective(){
        return {
            restrict    : 'E',
            link        : postLink
        };
        
        function postLink($scope, $element, $attrs){
            
        }
    }
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * Represents an autocomplete match. Used internally by the autoComplete directive.
     */
    angular.module('enspire.ui.components.inputTags').directive('enInputTagsAutoMatch', ComponentDirective);

    function ComponentDirective($sce, enInputTagsUtil) {
        return {
            restrict: 'E',
            require: '^enInputTagsAutoComplete',
            template: '<ng-include src="$$template"></ng-include>',
            scope: { data: '=' },
            link: function(scope, element, attrs, autoCompleteCtrl) {
                var autoComplete = autoCompleteCtrl.registerAutocompleteMatch(),
                    options = autoComplete.getOptions();

                scope.$$template = options.template;
                scope.$index = scope.$parent.$index;

                scope.$highlight = function(text) {
                    if (options.highlightMatchedText) {
                        text = enInputTagsUtil.safeHighlight(text, autoComplete.getQuery());
                    }
                    return $sce.trustAsHtml(text);
                };
                scope.$getDisplayText =  function() {
                    return enInputTagsUtil.safeToString(scope.data[options.displayProperty || options.enInputTags.displayProperty]);
                };
            }
        };
    }
    ComponentDirective.$inject = ["$sce", "enInputTagsUtil"];

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc directive
     * @name enInputTagsAutoComplete
     * @restrict E
     * @module enspire.ui.components.inputTags
     *
     * @description
     * Provides autocomplete support for the enInputTags directive.
     *
     * @param {expression} source Expression to evaluate upon changing the input content. The input value is available as
     *    $query. The result of the expression must be a promise that eventually resolves to an array of strings.
     * @param {string=} [template=NA] URL or id of a custom template for rendering each element of the autocomplete list.
     * @param {string=} [displayProperty=enInputTags.displayText] Property to be rendered as the autocomplete label.
     * @param {number=} [debounceDelay=100] Amount of time, in milliseconds, to wait before evaluating the expression in
     *    the source option after the last keystroke.
     * @param {number=} [minLength=3] Minimum number of characters that must be entered before evaluating the expression
     *    in the source option.
     * @param {boolean=} [highlightMatchedText=true] Flag indicating that the matched text will be highlighted in the
     *    suggestions list.
     * @param {number=} [maxResultsToShow=10] Maximum number of results to be displayed at a time.
     * @param {boolean=} [loadOnDownArrow=false] Flag indicating that the source option will be evaluated when the down arrow
     *    key is pressed and the suggestion list is closed. The current input value is available as $query.
     * @param {boolean=} [loadOnEmpty=false] Flag indicating that the source option will be evaluated when the input content
     *    becomes empty. The $query variable will be passed to the expression as an empty string.
     * @param {boolean=} [loadOnFocus=false] Flag indicating that the source option will be evaluated when the input element
     *    gains focus. The current input value is available as $query.
     * @param {boolean=} [selectFirstMatch=true] Flag indicating that the first match will be automatically selected once
     *    the suggestion list is shown.
     */
    angular.module('enspire.ui.components.inputTags').directive('enInputTagsAutoComplete', ComponentDirective);

    function ComponentDirective($document, $timeout, $sce, $q, enInputTagsConfig, enInputTagsUtil) {
        var KEYS = enInputTagsConfig.KEYS;

        function SuggestionList(loadFn, options, events) {
            var self = {}, getDifference, lastPromise, getTagId;

            getTagId = function() {
                return options.enInputTags.keyProperty || options.enInputTags.displayProperty;
            };

            getDifference = function(array1, array2) {
                return array1.filter(function(item) {
                    return !enInputTagsUtil.findInObjectArray(array2, item, getTagId(), function(a, b) {
                        if (options.enInputTags.replaceSpacesWithDashes) {
                            a = enInputTagsUtil.replaceSpacesWithDashes(a);
                            b = enInputTagsUtil.replaceSpacesWithDashes(b);
                        }
                        return enInputTagsUtil.defaultComparer(a, b);
                    });
                });
            };

            self.reset = function() {
                lastPromise = null;

                self.items = [];
                self.visible = false;
                self.index = -1;
                self.selected = null;
                self.query = null;
            };
            self.show = function() {
                if (options.selectFirstMatch) {
                    self.select(0);
                }
                else {
                    self.selected = null;
                }
                self.visible = true;
            };
            self.load = enInputTagsUtil.debounce(function(query, tags) {
                self.query = query;

                var promise = $q.when(loadFn({ $query: query }));
                lastPromise = promise;

                promise.then(function(items) {
                    if (promise !== lastPromise) {
                        return;
                    }

                    items = enInputTagsUtil.makeObjectArray(items.data || items, getTagId());
                    items = getDifference(items, tags);
                    self.items = items.slice(0, options.maxResultsToShow);

                    if (self.items.length > 0) {
                        self.show();
                    }
                    else {
                        self.reset();
                    }
                });
            }, options.debounceDelay);

            self.selectNext = function() {
                self.select(++self.index);
            };
            self.selectPrior = function() {
                self.select(--self.index);
            };
            self.select = function(index) {
                if (index < 0) {
                    index = self.items.length - 1;
                }
                else if (index >= self.items.length) {
                    index = 0;
                }
                self.index = index;
                self.selected = self.items[index];
                events.trigger('suggestion-selected', index);
            };

            self.reset();

            return self;
        }

        function scrollToElement(root, index) {
            var element = root.find('li').eq(index),
                parent = element.parent(),
                elementTop = element.prop('offsetTop'),
                elementHeight = element.prop('offsetHeight'),
                parentHeight = parent.prop('clientHeight'),
                parentScrollTop = parent.prop('scrollTop');

            if (elementTop < parentScrollTop) {
                parent.prop('scrollTop', elementTop);
            }
            else if (elementTop + elementHeight > parentHeight + parentScrollTop) {
                parent.prop('scrollTop', elementTop + elementHeight - parentHeight);
            }
        }

        return {
            restrict: 'E',
            require: '^enInputTags',
            scope: { source: '&' },
            templateUrl: 'input-tags/auto-complete.html',
            controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
                $scope.events = enInputTagsUtil.simplePubSub();

                enInputTagsConfig.load('autoComplete', $scope, $attrs, {
                    template: [String, 'input-tags/auto-complete-match.html'],
                    debounceDelay: [Number, 100],
                    minLength: [Number, 3],
                    highlightMatchedText: [Boolean, true],
                    maxResultsToShow: [Number, 10],
                    loadOnDownArrow: [Boolean, false],
                    loadOnEmpty: [Boolean, false],
                    loadOnFocus: [Boolean, false],
                    selectFirstMatch: [Boolean, true],
                    displayProperty: [String, '']
                });

                $scope.suggestionList = new SuggestionList($scope.source, $scope.options, $scope.events);

                this.registerAutocompleteMatch = function() {
                    return {
                        getOptions: function() {
                            return $scope.options;
                        },
                        getQuery: function() {
                            return $scope.suggestionList.query;
                        }
                    };
                };
            }],
            link: function(scope, element, attrs, enInputTagsCtrl) {
                var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down],
                    suggestionList = scope.suggestionList,
                    enInputTags = enInputTagsCtrl.registerAutocomplete(),
                    options = scope.options,
                    events = scope.events,
                    shouldLoadSuggestions;

                options.enInputTags = enInputTags.getOptions();

                shouldLoadSuggestions = function(value) {
                    return value && value.length >= options.minLength || !value && options.loadOnEmpty;
                };

                scope.addSuggestionByIndex = function(index) {
                    suggestionList.select(index);
                    scope.addSuggestion();
                };

                scope.addSuggestion = function() {
                    var added = false;

                    if (suggestionList.selected) {
                        enInputTags.addTag(angular.copy(suggestionList.selected));
                        suggestionList.reset();
                        enInputTags.focusInput();

                        added = true;
                    }
                    return added;
                };

                scope.track = function(item) {
                    return item[options.enInputTags.keyProperty || options.enInputTags.displayProperty];
                };

                enInputTags
                    .on('tag-added invalid-tag input-blur', function() {
                        suggestionList.reset();
                    })
                    .on('input-change', function(value) {
                        if (shouldLoadSuggestions(value)) {
                            suggestionList.load(value, enInputTags.getTags());
                        }
                        else {
                            suggestionList.reset();
                        }
                    })
                    .on('input-focus', function() {
                        var value = enInputTags.getCurrentTagText();
                        if (options.loadOnFocus && shouldLoadSuggestions(value)) {
                            suggestionList.load(value, enInputTags.getTags());
                        }
                    })
                    .on('input-keydown', function(event) {
                        var key = event.keyCode,
                            handled = false;

                        if (hotkeys.indexOf(key) === -1) {
                            return;
                        }

                        if (suggestionList.visible) {

                            if (key === KEYS.down) {
                                suggestionList.selectNext();
                                handled = true;
                            }
                            else if (key === KEYS.up) {
                                suggestionList.selectPrior();
                                handled = true;
                            }
                            else if (key === KEYS.escape) {
                                suggestionList.reset();
                                handled = true;
                            }
                            else if (key === KEYS.enter || key === KEYS.tab) {
                                handled = scope.addSuggestion();
                            }
                        }
                        else {
                            if (key === KEYS.down && scope.options.loadOnDownArrow) {
                                suggestionList.load(enInputTags.getCurrentTagText(), enInputTags.getTags());
                                handled = true;
                            }
                        }

                        if (handled) {
                            event.preventDefault();
                            event.stopImmediatePropagation();
                            return false;
                        }
                    });

                events.on('suggestion-selected', function(index) {
                    scrollToElement(element, index);
                });
            }
        };
    }
    ComponentDirective.$inject = ["$document", "$timeout", "$sce", "$q", "enInputTagsConfig", "enInputTagsUtil"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.inputTags').directive('enInputTagsAutosize', ComponentDirective);

    function ComponentDirective(enInputTagsConfig) {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function(scope, element, attrs, ctrl) {
                var threshold = enInputTagsConfig.getTextAutosizeThreshold(),
                    span, resize;

                span = angular.element('<span class="input"></span>');
                span.css('display', 'none')
                    .css('visibility', 'hidden')
                    .css('width', 'auto')
                    .css('white-space', 'pre');

                element.parent().append(span);

                resize = function(originalValue) {
                    var value = originalValue, width;

                    if (angular.isString(value) && value.length === 0) {
                        value = attrs.placeholder;
                    }

                    if (value) {
                        span.text(value);
                        span.css('display', '');
                        width = span.prop('offsetWidth');
                        span.css('display', 'none');
                    }

                    element.css('width', width ? width + threshold + 'px' : '');

                    return originalValue;
                };

                ctrl.$parsers.unshift(resize);
                ctrl.$formatters.unshift(resize);

                attrs.$observe('placeholder', function(value) {
                    if (!ctrl.$modelValue) {
                        resize(value);
                    }
                });
            }
        };
    }
    ComponentDirective.$inject = ["enInputTagsConfig"];
    
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.inputTags').provider('enInputTagsConfig', ComponentService);

    /**
     * Sets global configuration settings for both enInputTags and autoComplete directives. It's also used internally to parse and
     * initialize options from HTML attributes.
     */

    function ComponentService() {
        var self = this,
            globalDefaults = {},
            interpolationStatus = {},
            autosizeThreshold = 16;

        /**
         * enInputTagsConfig#setDefaults
         * Sets the default configuration option for a directive.
         *
         * @param {string} directive Name of the directive to be configured. Must be either 'enInputTags' or 'autoComplete'.
         * @param {object} defaults Object containing options and their values.
         *
         * @returns {object} The service itself for chaining purposes.
         */
        self.setDefaults = function(directive, defaults) {
            globalDefaults[directive] = defaults;
            return this;
        };

        /**
         * enInputTagsConfig#setActiveInterpolation
         * Sets active interpolation for a set of options.
         *
         * @param {string} directive Name of the directive to be configured. Must be either 'enInputTags' or 'autoComplete'.
         * @param {object} options Object containing which options should have interpolation turned on at all times.
         *
         * @returns {object} The service itself for chaining purposes.
         */
        self.setActiveInterpolation = function(directive, options) {
            interpolationStatus[directive] = options;
            return this;
        };

        /**
         * enInputTagsConfig#setTextAutosizeThreshold
         * Sets the threshold used by the enInputTags directive to re-size the inner input field element based on its contents.
         *
         * @param {number} threshold Threshold value, in pixels.
         *
         * @returns {object} The service itself for chaining purposes.
         */
        self.setTextAutosizeThreshold = function(threshold) {
            autosizeThreshold = threshold;
            return this;
        };

        self.$get = ["$interpolate", function($interpolate) {
            var converters = {};
            converters[String] = function(value) { return value; };
            converters[Number] = function(value) { return parseInt(value, 10); };
            converters[Boolean] = function(value) { return value.toLowerCase() === 'true'; };
            converters[RegExp] = function(value) { return new RegExp(value); };

            return {
                load: function(directive, scope, attrs, options) {
                    var defaultValidator = function() { return true; };

                    scope.options = {};

                    angular.forEach(options, function(value, key) {
                        var type, localDefault, validator, converter, getDefault, updateValue;

                        type = value[0];
                        localDefault = value[1];
                        validator = value[2] || defaultValidator;
                        converter = converters[type];

                        getDefault = function() {
                            var globalValue = globalDefaults[directive] && globalDefaults[directive][key];
                            return angular.isDefined(globalValue) ? globalValue : localDefault;
                        };

                        updateValue = function(value) {
                            scope.options[key] = value && validator(value) ? converter(value) : getDefault();
                        };

                        if (interpolationStatus[directive] && interpolationStatus[directive][key]) {
                            attrs.$observe(key, function(value) {
                                updateValue(value);
                                scope.events.trigger('option-change', { name: key, newValue: value });
                            });
                        }
                        else {
                            updateValue(attrs[key] && $interpolate(attrs[key])(scope.$parent));
                        }
                    });
                },
                getTextAutosizeThreshold: function() {
                    return autosizeThreshold;
                },

                KEYS: {
                    backspace: 8,
                    tab: 9,
                    enter: 13,
                    escape: 27,
                    space: 32,
                    up: 38,
                    down: 40,
                    left: 37,
                    right: 39,
                    delete: 46,
                    comma: 188
                },

                MAX_SAFE_INTEGER: 9007199254740991,

                SUPPORTED_INPUT_TYPES: ['text', 'email', 'url']
            };
        }];

    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.inputTags').controller('enInputTagsController', InputTagsController);

    function InputTagsController($scope, $attrs, $element, enInputTagsConfig, enInputTagsUtil) {
        $scope.events = enInputTagsUtil.simplePubSub();

        var MAX_SAFE_INTEGER = enInputTagsConfig.MAX_SAFE_INTEGER,
            SUPPORTED_INPUT_TYPES = enInputTagsConfig.SUPPORTED_INPUT_TYPES;

        function validateType(type) {
            return SUPPORTED_INPUT_TYPES.indexOf(type) !== -1;
        }

        function TagList(options, events, onTagAdding, onTagRemoving) {
            var self = {}, getTagText, setTagText, tagIsValid;

            getTagText = function(tag) {
                return enInputTagsUtil.safeToString(tag[options.displayProperty]);
            };

            setTagText = function(tag, text) {
                tag[options.displayProperty] = text;
            };

            tagIsValid = function(tag) {
                var tagText = getTagText(tag);

                return tagText &&
                       tagText.length >= options.minLength &&
                       tagText.length <= options.maxLength &&
                       options.allowedTagsPattern.test(tagText) &&
                       !enInputTagsUtil.findInObjectArray(self.items, tag, options.keyProperty || options.displayProperty) &&
                       onTagAdding({ $tag: tag });
            };

            self.items = [];

            self.addText = function(text) {
                var tag = {};
                setTagText(tag, text);
                return self.add(tag);
            };

            self.add = function(tag) {
                var tagText = getTagText(tag);

                if (options.replaceSpacesWithDashes) {
                    tagText = enInputTagsUtil.replaceSpacesWithDashes(tagText);
                }

                setTagText(tag, tagText);

                if (tagIsValid(tag)) {
                    self.items.push(tag);
                    events.trigger('tag-added', { $tag: tag });
                }
                else if (tagText) {
                    events.trigger('invalid-tag', { $tag: tag });
                }

                return tag;
            };

            self.remove = function(index) {
                var tag = self.items[index];

                if (onTagRemoving({ $tag: tag }))  {
                    self.items.splice(index, 1);
                    self.clearSelection();
                    events.trigger('tag-removed', { $tag: tag });
                    return tag;
                }
            };

            self.select = function(index) {
                if (index < 0) {
                    index = self.items.length - 1;
                }
                else if (index >= self.items.length) {
                    index = 0;
                }

                self.index = index;
                self.selected = self.items[index];
            };

            self.selectPrior = function() {
                self.select(--self.index);
            };

            self.selectNext = function() {
                self.select(++self.index);
            };

            self.removeSelected = function() {
                return self.remove(self.index);
            };

            self.clearSelection = function() {
                self.selected = null;
                self.index = -1;
            };

            self.clearSelection();

            return self;
        }


        enInputTagsConfig.load('enInputTags', $scope, $attrs, {
            template: [String, 'input-tags/tag-item.html'],
            type: [String, 'text', validateType],
            placeholder: [String, 'Add a tag'],
            tabindex: [Number, null],
            removeTagSymbol: [String, String.fromCharCode(215)],
            replaceSpacesWithDashes: [Boolean, true],
            minLength: [Number, 3],
            maxLength: [Number, MAX_SAFE_INTEGER],
            addOnEnter: [Boolean, true],
            addOnSpace: [Boolean, false],
            addOnComma: [Boolean, true],
            addOnBlur: [Boolean, true],
            addOnPaste: [Boolean, false],
            pasteSplitPattern: [RegExp, /,/],
            allowedTagsPattern: [RegExp, /.+/],
            enableEditingLastTag: [Boolean, false],
            minTags: [Number, 0],
            maxTags: [Number, MAX_SAFE_INTEGER],
            displayProperty: [String, 'text'],
            keyProperty: [String, ''],
            allowLeftoverText: [Boolean, false],
            addFromAutocompleteOnly: [Boolean, false],
            spellcheck: [Boolean, true]
        });

        $scope.tagList = new TagList($scope.options, $scope.events,
            enInputTagsUtil.handleUndefinedResult($scope.onTagAdding, true),
            enInputTagsUtil.handleUndefinedResult($scope.onTagRemoving, true));

        this.registerAutocomplete = function() {
            var input = $element.find('input');

            return {
                addTag: function(tag) {
                    return $scope.tagList.add(tag);
                },
                focusInput: function() {
                    input[0].focus();
                },
                getTags: function() {
                    return $scope.tagList.items;
                },
                getCurrentTagText: function() {
                    return $scope.newTag.text;
                },
                getOptions: function() {
                    return $scope.options;
                },
                on: function(name, handler) {
                    $scope.events.on(name, handler);
                    return this;
                }
            };
        };

        this.registerTagItem = function() {
            return {
                getOptions: function() {
                    return $scope.options;
                },
                removeTag: function(index) {
                    if ($scope.disabled) {
                        return;
                    }
                    $scope.tagList.remove(index);
                }
            };
        };
    }
    InputTagsController.$inject = ["$scope", "$attrs", "$element", "enInputTagsConfig", "enInputTagsUtil"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */

/*
TODOS:
    - Clear watches
*/
(function(){
    'use strict';


    angular.module('enspire.ui.components.inputTags').directive('enInputTags', InputTags);

    /**
     * @ngdoc directive
     * @name enInputTags
     * @module enspire.ui.components.inputTags
     * @restrict E
     * @description
     * Input box that supports typeahead and turns typed words into tags.
     *
     * @param {string} ngModel Assignable angular expression to data-bind to.
     * @param {string=} [template=NA] URL or id of a custom template for rendering each tag.
     * @param {string=} [keyProperty=text] Property to be used as a unique identifier for the tag.
     * @param {string=} [displayProperty=text] Property to be rendered as the tag label.
     * @param {string=} [type=text] Type of the input element. Only 'text', 'email' and 'url' are supported values.
     * @param {number=} tabindex Tab order of the control.
     * @param {string=} [placeholder=Add a tag] Placeholder text for the control.
     * @param {number=} [minLength=3] Minimum length for a new tag.
     * @param {number=} [maxLength=
     * @param {number=} [minTags=0] Sets minTags validation error key if the number of tags added is less than minTags.
     * @param {number=} [maxTags=
     *    than maxTags.
     * @param {boolean=} [allowLeftoverText=false] Sets leftoverText validation error key if there is any leftover text in
     *    the input element when the directive loses focus.
     * @param {string=} [removeTagSymbol=×] Symbol character for the remove tag button.
     * @param {boolean=} [addOnEnter=true] Flag indicating that a new tag will be added on pressing the ENTER key.
     * @param {boolean=} [addOnSpace=false] Flag indicating that a new tag will be added on pressing the SPACE key.
     * @param {boolean=} [addOnComma=true] Flag indicating that a new tag will be added on pressing the COMMA key.
     * @param {boolean=} [addOnBlur=true] Flag indicating that a new tag will be added when the input field loses focus.
     * @param {boolean=} [addOnPaste=false] Flag indicating that the text pasted into the input field will be split into tags.
     * @param {string=} [pasteSplitPattern=,] Regular expression used to split the pasted text into tags.
     * @param {boolean=} [replaceSpacesWithDashes=true] Flag indicating that spaces will be replaced with dashes.
     * @param {string=} [allowedTagsPattern=.+] Regular expression that determines whether a new tag is valid.
     * @param {boolean=} [enableEditingLastTag=false] Flag indicating that the last tag will be moved back into the new tag
     *    input box instead of being removed when the backspace key is pressed and the input box is empty.
     * @param {boolean=} [addFromAutocompleteOnly=false] Flag indicating that only tags coming from the autocomplete list
     *    will be allowed. When this flag is true, addOnEnter, addOnComma, addOnSpace and addOnBlur values are ignored.
     * @param {boolean=} [spellcheck=true] Flag indicating whether the browser's spellcheck is enabled for the input field or not.
     * @param {expression=} [onTagAdding=NA] Expression to evaluate that will be invoked before adding a new tag. The new
     *    tag is available as $tag. This method must return either true or false. If false, the tag will not be added.
     * @param {expression=} [onTagAdded=NA] Expression to evaluate upon adding a new tag. The new tag is available as $tag.
     * @param {expression=} [onInvalidTag=NA] Expression to evaluate when a tag is invalid. The invalid tag is available as $tag.
     * @param {expression=} [onTagRemoving=NA] Expression to evaluate that will be invoked before removing a tag. The tag
     *    is available as $tag. This method must return either true or false. If false, the tag will not be removed.
     * @param {expression=} [onTagRemoved=NA] Expression to evaluate upon removing an existing tag. The removed tag is
     *    available as $tag.
     *
     * @usage
     * ### As attribute
     * <hljs lang="html">
     *   <input type="text" en-input-tags />
     * </hljs>
     *
     *
     * ### As element
     * <hljs lang="html">
     *   <en-input-tags data-typeahead="true" />
     * </hljs>
     */

    function InputTags($timeout, $document, $window, enInputTagsConfig, enInputTagsUtil, $parse) {

        var KEYS = enInputTagsConfig.KEYS,
            linkFunction;

        return {
            restrict: 'E',
            require: 'ngModel',
            scope: {
                tags: '=ngModel',
                onTagAdding: '&',
                onTagAdded: '&',
                onInvalidTag: '&',
                onTagRemoving: '&',
                onTagRemoved: '&',
                showTags: '='
            },
            replace: false,
            transclude: true,
            controller: 'enInputTagsController',
            templateUrl: 'input-tags/input-tags.html',
            link: linkFunction
        }



        function linkFunction (scope, element, attrs, ngModelCtrl) {
            var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace, KEYS.delete, KEYS.left, KEYS.right],
                tagList = scope.tagList,
                events = scope.events,
                options = scope.options,
                input = element.find('input'),
                validationOptions = ['minTags', 'maxTags', 'allowLeftoverText'],
                setElementValidity;

            tagList.showTags = attrs.showTags ? $parse(attrs.showTags)(): true;

            setElementValidity = function() {
                ngModelCtrl.$setValidity('maxTags', tagList.items.length <= options.maxTags);
                ngModelCtrl.$setValidity('minTags', tagList.items.length >= options.minTags);
                ngModelCtrl.$setValidity('leftoverText', scope.hasFocus || options.allowLeftoverText ? true : !scope.newTag.text);
            };

            ngModelCtrl.$isEmpty = function(value) {
                return !value || !value.length;
            };

            scope.newTag = {
                text: '',
                invalid: null,
                setText: function(value) {
                    this.text = value;
                    events.trigger('input-change', value);
                }
            };

            scope.track = function(tag) {
                return tag[options.keyProperty || options.displayProperty];
            };

            scope.$watch('tags', function(value) {
                if (value) {
                    tagList.items = enInputTagsUtil.makeObjectArray(value, options.displayProperty);
                    scope.tags = tagList.items;
                }
                else {
                    tagList.items = [];
                }
            });

            var unWatchTagsLen = scope.$watch('tags.length', function() {
                setElementValidity();

                // ngModelController won't trigger validators when the model changes (because it's an array),
                // so we need to do it ourselves. Unfortunately this won't trigger any registered formatter.
                ngModelCtrl.$validate();
            });

            attrs.$observe('disabled', function(value) {
                scope.disabled = value;
            });

            scope.eventHandlers = {
                input: {
                    change: function(text) {
                        events.trigger('input-change', text);
                    },
                    keydown: function($event) {
                        events.trigger('input-keydown', $event);
                    },
                    focus: function() {
                        if (scope.hasFocus) {
                            return;
                        }

                        scope.hasFocus = true;
                        events.trigger('input-focus');
                    },
                    blur: function() {
                        $timeout(function() {
                            var activeElement = $document.prop('activeElement'),
                                lostFocusToBrowserWindow = activeElement === input[0],
                                lostFocusToChildElement = element[0].contains(activeElement);

                            if (lostFocusToBrowserWindow || !lostFocusToChildElement) {
                                scope.hasFocus = false;
                                events.trigger('input-blur');
                            }
                        });
                    },
                    paste: function($event) {
                        $event.getTextData = function() {
                            var clipboardData = $event.clipboardData || ($event.originalEvent && $event.originalEvent.clipboardData);
                            return clipboardData ? clipboardData.getData('text/plain') : $window.clipboardData.getData('Text');
                        };
                        events.trigger('input-paste', $event);
                    }
                },
                host: {
                    click: function() {
                        if (scope.disabled) {
                            return;
                        }
                        input[0].focus();
                    }
                }
            };

            events
                .on('tag-added', scope.onTagAdded)
                .on('invalid-tag', scope.onInvalidTag)
                .on('tag-removed', scope.onTagRemoved)
                .on('tag-added', onTagAdded )
                .on('tag-added tag-removed', onTagAddedRemoved)
                .on('invalid-tag', onInvalidTag)
                .on('option-change', onOptionChange)
                .on('input-change', onInputChange)
                .on('input-focus', onInputFocus)
                .on('input-blur', onInputBlur)
                .on('input-keydown', onInputKeydown)
                .on('input-paste', onInputPaste);

           /**
            * ---------------
            * Event functions
            * ---------------
            */
            function onTagAdded () {
                scope.newTag.setText('');
            }

            function onTagAddedRemoved() {
                scope.tags = tagList.items;
                // Ideally we should be able call $setViewValue here and let it in turn call $setDirty and $validate
                // automatically, but since the model is an array, $setViewValue does nothing and it's up to us to do it.
                // Unfortunately this won't trigger any registered $parser and there's no safe way to do it.
                ngModelCtrl.$setDirty();
            }

            function onInvalidTag() {
                scope.newTag.invalid = true;
            }

            function onOptionChange(e) {
                if (validationOptions.indexOf(e.name) !== -1) {
                    setElementValidity();
                }
            }

            function onInputChange() {
                tagList.clearSelection();
                scope.newTag.invalid = null;
            }

            function onInputFocus() {
                element.triggerHandler('focus');
                ngModelCtrl.$setValidity('leftoverText', true);
            }

            function onInputBlur() {
                if (options.addOnBlur && !options.addFromAutocompleteOnly) {
                    tagList.addText(scope.newTag.text);
                }
                element.triggerHandler('blur');
                setElementValidity();
            }

            function onInputKeydown (event) {
                var key = event.keyCode,
                    isModifier = event.shiftKey || event.altKey || event.ctrlKey || event.metaKey,
                    addKeys = {},
                    shouldAdd, shouldRemove, shouldSelect, shouldEditLastTag;

                if (isModifier || hotkeys.indexOf(key) === -1) {
                    return;
                }

                addKeys[KEYS.enter] = options.addOnEnter;
                addKeys[KEYS.comma] = options.addOnComma;
                addKeys[KEYS.space] = options.addOnSpace;

                shouldAdd = !options.addFromAutocompleteOnly && addKeys[key];
                shouldRemove = (key === KEYS.backspace || key === KEYS.delete) && tagList.selected;
                shouldEditLastTag = key === KEYS.backspace && scope.newTag.text.length === 0 && options.enableEditingLastTag;
                shouldSelect = (key === KEYS.backspace || key === KEYS.left || key === KEYS.right) && scope.newTag.text.length === 0 && !options.enableEditingLastTag;

                if (shouldAdd) {
                    tagList.addText(scope.newTag.text);
                }
                else if (shouldEditLastTag) {
                    var tag;

                    tagList.selectPrior();
                    tag = tagList.removeSelected();

                    if (tag) {
                        scope.newTag.setText(tag[options.displayProperty]);
                    }
                }
                else if (shouldRemove) {
                    tagList.removeSelected();
                }
                else if (shouldSelect) {
                    if (key === KEYS.left || key === KEYS.backspace) {
                        tagList.selectPrior();
                    }
                    else if (key === KEYS.right) {
                        tagList.selectNext();
                    }
                }

                if (shouldAdd || shouldSelect || shouldRemove || shouldEditLastTag) {
                    event.preventDefault();
                }
            }

            function onInputPaste(event) {
                if (options.addOnPaste) {
                    var data = event.getTextData();
                    var tags = data.split(options.pasteSplitPattern);

                    if (tags.length > 1) {
                        tags.forEach(function(tag) {
                            tagList.addText(tag);
                        });
                        event.preventDefault();
                    }
                }
            }

            scope.$on('$destroy', function(){
                unWatchTagsLen();
            })

        } //linkFunction
    }
    InputTags.$inject = ["$timeout", "$document", "$window", "enInputTagsConfig", "enInputTagsUtil", "$parse"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.inputTags').directive('enInputTagItem', ComponentDirective);

    /**
     * Represents a tag item. Used internally by the enInputTags directive.
     */

    function ComponentDirective(enInputTagsUtil) {

        return {
            restrict: 'E',
            require: '^enInputTags',
            template: '<ng-include src="$$template"></ng-include>',
            scope: { data: '=' },
            link: function(scope, element, attrs, enInputTagsCtrl) {
                var enInputTags = enInputTagsCtrl.registerTagItem(),
                    options = enInputTags.getOptions();

                scope.$$template = options.template;
                scope.$$removeTagSymbol = options.removeTagSymbol;

                scope.$getDisplayText = function() {
                    return enInputTagsUtil.safeToString(scope.data[options.displayProperty]);
                };
                scope.$removeTag = function() {
                    enInputTags.removeTag(scope.$index);
                };

                scope.$watch('$parent.$index', function(value) {
                    scope.$index = value;
                });
            }
        };
    }
    ComponentDirective.$inject = ["enInputTagsUtil"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * Re-creates the old behavior of ng-transclude. Used internally by the enInputTags directive.
     */
    angular.module('enspire.ui.components.inputTags').directive('enInputTagsTranscludeAppend', ComponentDirective);

    function ComponentDirective() {
        return function(scope, element, attrs, ctrl, transcludeFn) {
            transcludeFn(function(clone) {
                element.append(clone);
            });
        };
    }

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.inputTags').factory('enInputTagsUtil', ComponentService);

    /**
     * Helper methods used internally by the directive. Should not be called directly from user code.
     */

    function ComponentService($timeout) {
        var self = {};

        self.debounce = function(fn, delay) {
            var timeoutId;
            return function() {
                var args = arguments;
                $timeout.cancel(timeoutId);
                timeoutId = $timeout(function() { fn.apply(null, args); }, delay);
            };
        };

        self.makeObjectArray = function(array, key) {
            if (!angular.isArray(array) || array.length === 0 || angular.isObject(array[0])) {
                return array;
            }

            var newArray = [];
            array.forEach(function(item) {
                var obj = {};
                obj[key] = item;
                newArray.push(obj);
            });
            return newArray;
        };

        self.findInObjectArray = function(array, obj, key, comparer) {
            var item = null;
            comparer = comparer || self.defaultComparer;

            array.some(function(element) {
                if (comparer(element[key], obj[key])) {
                    item = element;
                    return true;
                }
            });

            return item;
        };

        self.defaultComparer = function(a, b) {
            // I'm aware of the internationalization issues regarding toLowerCase()
            // but I couldn't come up with a better solution right now
            return self.safeToString(a).toLowerCase() === self.safeToString(b).toLowerCase();
        };

        self.safeHighlight = function(str, value) {
            if (!value) {
                return str;
            }

            function escapeRegexChars(str) {
                return str.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
            }

            str = self.encodeHTML(str);
            value = self.encodeHTML(value);

            var expression = new RegExp('&[^;]+;|' + escapeRegexChars(value), 'gi');
            return str.replace(expression, function(match) {
                return match.toLowerCase() === value.toLowerCase() ? '<em>' + match + '</em>' : match;
            });
        };

        self.safeToString = function(value) {
            return angular.isUndefined(value) || value == null ? '' : value.toString().trim();
        };

        self.encodeHTML = function(value) {
            return self.safeToString(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        };

        self.handleUndefinedResult = function(fn, valueIfUndefined) {
            return function() {
                var result = fn.apply(null, arguments);
                return angular.isUndefined(result) ? valueIfUndefined : result;
            };
        };

        self.replaceSpacesWithDashes = function(str) {
            return self.safeToString(str).replace(/\s/g, '-');
        };

        self.simplePubSub = function() {
            var events = {};
            return {
                on: function(names, handler) {
                    names.split(' ').forEach(function(name) {
                        if (!events[name]) {
                            events[name] = [];
                        }
                        events[name].push(handler);
                    });
                    return this;
                },
                trigger: function(name, args) {
                    var handlers = events[name] || [];
                    handlers.every(function(handler) {
                        return self.handleUndefinedResult(handler, true)(args);
                    });
                    return this;
                }
            };
        };

        return self;
    }
    ComponentService.$inject = ["$timeout"];
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
angular
    .module('enspire.ui.components.keyEvent')
    .directive('enKeyEvent', ComponentDirective);

/**
 * @ngdoc directive
 * @name enKeyEvent
 * @module enspire.ui.components.keyEvent
 *
 * @description
 * UNFINISHED DOCUMENTATION
 *
 * @param {expression} name               An expression in the format of `item in items` to iterate over matches for your search.
 * @param {expression} type
 * @param {expression} callback
 *
 *
 */

function ComponentDirective($keyEvent, $uuid, $document){
    return {
        restrict    : 'EA',
        link        : postLink
    };

    function postLink($scope, $element, $attrs){
        var self        = $scope;

        var name        = $attrs.keyEventName       || $attrs.name          || $uuid('');
        var type        = $attrs.keyEventType       || $attrs.type          || 'keydown';
        var handler     = $attrs.keyEventHandler    || $attrs.handler       || 'generic';
        var element     = $element;
        var callback    = $scope.$eval($attrs.keyEventCallback)   || $scope.$eval($attrs.callback) || function(){};
        var disabled    = $scope.$eval($attrs.keyEventDisabled)   || $scope.$eval($attrs.disabled) || false;
        var disabledAttrStr  = 'key-event-disabled';

        if(element[0].tagName.toLowerCase() === 'en-key-event'){
            disabledAttrStr = 'disabled';
            element = $document.find('body');
        }

        var instance = $keyEvent.addInstance({
            name        : name,
            type        : type,
            handler     : handler,
            element     : element,
            disabled    : disabled,
            callback    : callback
        });

        if(instance){
            $attrs.$observe(disabledAttrStr, function(val){
                instance.disabled = $scope.$eval(val);
            });

            $element.on('$destroy', instance.destroy);
            $scope.$on('$destroy', instance.destroy);
        }

    }
}
ComponentDirective.$inject = ["$keyEvent", "$uuid", "$document"];

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
/**
* @ngdoc service
* @name $keyEvent
* @module enspire.ui.components.keyEvent
*
* @description
* The `$keyEvent` service manages event listeners and handlers for scanned and swiped events that are passed to the DOM as keyed events (ie. keypress, keydown, keyup).
 *
 * #### $keyEvent is not meant to be the go-to component for setting key events.
 *
 *
*
*/
    'use strict';

    angular.module('enspire.ui.components.keyEvent')
        .provider('$keyEvent', ComponentProvider)
        .config(ComponentProviderConfig);

    function ComponentProvider(){

        var config = {

        };

        var defaults = {

        };

        var handlers = {
            generic: function($event, objInstance){
                objInstance.private.chars.push(String.fromCharCode($event.which));
                if(objInstance.private.pressed == false){
                    setTimeout(function(){
                        if(objInstance.private.chars.length >= 70){
                            objInstance.callback(objInstance.private.chars.join(""));
                        }
                        objInstance.private.chars   = [];
                        objInstance.private.pressed = false;
                    }, 300);
                }
                objInstance.private.pressed = true;
            }
        };

        var instances = {};

        function ComponentService($uuid, $filter, $timeout, $q, $rootScope, $document){
            var self     = this;
            var config   = self.config   = getConfig();
            var defaults = self.defaults = getDefaults();

            /**
             * @ngdoc method
             * @name $keyEvent#addInstance
             *
             * @description
             * Adds a new keyEvent instance.
             *
             * @param {string} name The unique name of the instance to be added.
             * @param {string} [type=|keydown, keyup,keypress] The type of instance being added.
             * @param {string|object} handler The unique name of handler function. Can also be an object containing the properties `name` and `handler`.  If an object is passed, the addInstance method will pass it to the `registerHandler` method and create a new handler before completing.
             * @param {function} callback The function that is called by the handler function. It will receive 2 arguments `$event` and `objInstance`.
             */

            self.addInstance = function(objInstance){

                var name     = objInstance.name;
                var type     = objInstance.type;
                var handler  = objInstance.handler;
                var element  = objInstance.element;
                var callback = objInstance.callback;
                var disabled = objInstance.disabled;
                var objPriv  = {
                        chars     : [],
                        initiated : true,
                        pressed   : false
                    };

                //
                if(!(/(keyup|keydown|keypress)/i).test(type)){
                    console.error('['+type+'] is not a valid event type.');
                    return;
                }

                // if handler is an object, assume the user is wanting to register a new handler at the same time
                // as adding the new instance.
                if(angular.isObject(handler)){
                    if(self.registerHandler(handler.name, handler.handler)){
                        handler = handler.name;
                    }else{
                        console.error('Handler was unable to be set while adding the ['+name+'] key event instance.');
                        return;
                    }
                }

                // if handler name is passed, check and make sure it is a registered handler.
                if(!handlers.hasOwnProperty(handler)){
                    console.error('['+handler+'] is not a registered handler.');
                    return;
                }

                if(!isUnique(name)){
                    console.warn('['+name+'] is already a registered keyEvent instance.');
                    return false;
                }


                // create the key event instance and store it to the service.
                instances[name] = {
                    type        : type,
                    handler     : handler,
                    element     : element,
                    callback    : callback,
                    disabled    : disabled,
                    private     : objPriv,
                    destroy     : function(){ self.removeInstance(name); },
                    eventRef    : function($event){
                        var inst = instances[name];
                        //console.log('EVENT ['+name+'] FIRED');
                        if(!inst.disabled){
                            handlers[handler]($event, inst);
                        }
                    }
                };

                // sets the key event on the element provided.
                element.on(type, instances[name].eventRef);

                // console.log('CREATED '+name+' keyEvent instance');

                return instances[name];
            };


            /**
             * @ngdoc method
             * @name $keyEvent#removeInstance
             *
             * @description
             * Permanently removes a keyEvent instance.
             *
             * @param {string} name The unique name of the instance to be removed.
             */
            self.removeInstance = function (name) {
                if(!angular.isDefined(instances[name])){
                    return;
                }
                instances[name].element.off(instances[name].type, instances[name].eventRef);
                delete instances[name];
                // console.log('DESTROYED '+name+' keyEvent instance');
            };


            /**
             * @ngdoc method
             * @name $keyEvent#getInstance
             *
             * @description
             * Fetches and returns a custom listener object that has been set using the $keyEvent service.
             *
             * @param {string} name    The name of the keyEvent instance to retrieve.
             *
             * @returns {object} If found, returns the instance object. Otherwise returns `undefined`.
             */
            self.getInstance = function(name) {
                return instances[name];
            };

            /**
             * @ngdoc method
             * @name $keyEvent#getInstance
             *
             * @description
             * Fetches and returns a custom listener object that has been set using the $keyEvent service.
             *
             * @param {string} name    The name of the keyEvent instance to retrieve.
             *
             * @returns {object} If found, returns the instance object. Otherwise returns `undefined`.
             */
            self.toggleInstance = toggleInstance;


            /**
             * @ngdoc method
             * @name $keyEvent#registerHandler
             *
             * @description
             * Registers a new handler function to the $keyEvent service.  Handlers are independent of $scopes and $elements and will persist across a project once added.
             *
             * @param {string}   name    The name in which to register the handler function as. This must be a unique name, otherwise and error will occur.
             * @param {function} handler    The function called when a matching key event is fired. There are 2 arguments that get supplied to the handler function, `$event` and `objInstance`.
             *
             * @returns {boolean} Returns `true` if the handler was added. `false` if not.
             */
            self.registerHandler = registerHandler;


            window.$keyEvent = $rootScope.$keyEvent = self;

            return self;
        }
        ComponentService.$inject = ["$uuid", "$filter", "$timeout", "$q", "$rootScope", "$document"];

        function getConfig()  { return config; }
        function getDefaults(){ return defaults; }

        function registerHandler(name, handler){
            if(!name || !handler || typeof handler !=='function'){
                console.error('['+name ? name : 'UnNamed'+'] handler could not be registered.');
                return false;
            }
            if(!isUniqueHandler(name)){
                console.error('['+name+'] is already a registered handler.');
                return false;
            }
            handlers[name] = handler;
            // console.log('Added '+name+' keyEvent HANDLER');
            return true;
        }


        function toggleInstance(name, disabled) {
            instances[name].disabled = (disabled ? disabled : !instances[name].disabled);
            return instances[name].disabled;
        }

        function isUnique(name){
            if(!name) return false;
            return !instances.hasOwnProperty(name);
        }

        function isUniqueHandler(name){
            if(!name) return false;
            return !handlers.hasOwnProperty(name);
        }

        return {
            setConfig       : function(configObj)   { config    = angular.extend({}, config, configObj); },
            setDefaults     : function(defaultsObj) { defaults  = angular.extend({}, defaults, defaultsObj); },
            registerHandler : registerHandler,
            $get            : ComponentService
        };


    }


    // EXAMPLE OF ADDING A HANDLER BY USING THE CONFIG METHOD
    function ComponentProviderConfig($keyEventProvider){

        //Registers the "barcode" keyEvent handler.
        $keyEventProvider.registerHandler('barcode', function($event, objInstance){
            //initiate private properties if first time running
            if(!angular.isDefined(objInstance.private.initiated)){
                objInstance.private = {
                    chars: [],
                    timeLastPressed: new Date().getTime(),
                    timeOut: undefined,
                    initiated: true
                };
            }

            var curTime = new Date().getTime();
            var difTime = curTime-objInstance.private.timeLastPressed;

            //set new time
            objInstance.private.timeLastPressed = curTime;

            //clear timeOut
            clearTimeout(objInstance.private.timeOut);

            var charCode = $event.which || $event.charCode || $event.keyCode;
            var character = mapKeyPressToActualCharacter($event.shiftKey,charCode);

            if((charCode >= 32 && charCode <= 126) || charCode === 190 || charCode === 13 || charCode === 16) {
                // console.log('charCode:',charCode, difTime);

                if (difTime <= 75) {
                    //add character to string

                    if(charCode !== 16 && charCode !== 13) objInstance.private.chars.push(character);

                    objInstance.private.timeOut = setTimeout(function () {
                        if (objInstance.private.chars.length >= 5) {
                            var barcode = objInstance.private.chars.join("");
                            objInstance.callback(barcode);
                            // console.log('BARCODE callback fired: ' + barcode);
                        } else {
                            objInstance.private.chars = [];
                        }
                    }, 75);
                } else {
                    objInstance.private.chars = [];
                    if(charCode !== 16 && charCode !== 13) objInstance.private.chars.push(character);
                }
            } else {
                objInstance.private.chars = [];
                if(charCode !== 16 && charCode !== 13) objInstance.private.chars.push(character);
            }
        });


        //Registers the "cardSwipe" keyEvent handler.
        $keyEventProvider.registerHandler('cardSwipe', function($event, objInstance){
            if(!angular.isDefined(objInstance.private.initiated)){
                objInstance.private = {
                    chars: [],
                    timeLastPressed: new Date().getTime(),
                    timeOut: undefined,
                    initiated: true
                };
            }

            var curTime = new Date().getTime();
            var difTime = curTime-objInstance.private.timeLastPressed;

            //set new time
            objInstance.private.timeLastPressed = curTime;

            //clear timeOut
            clearTimeout(objInstance.private.timeOut);

            var charCode = $event.which || $event.charCode || $event.keyCode;
            if(charCode===191) console.log($event);
            var character = mapKeyPressToActualCharacter($event.shiftKey,charCode);
            if((charCode >= 32 && charCode <= 126) || charCode === 190 || charCode === 191 || charCode === 13 || charCode === 16 || charCode === 186 || charCode === 187) {
                // console.log('charCode:',charCode, difTime);

                var timeDiffValue = 35;

                if(charCode === 186) timeDiffValue = 400;

                if (difTime <= timeDiffValue) {
                    //add character to string

                    if(charCode !== 16 && charCode !== 13) objInstance.private.chars.push(character);

                    objInstance.private.timeOut = setTimeout(function () {
                        if (objInstance.private.chars.length >= 10) {
                            var barcode = objInstance.private.chars.join("");
                            objInstance.callback(barcode);
                            // console.log('CARDSWIPE callback fired: ' + barcode);
                        } else {
                            objInstance.private.chars = [];
                        }
                    }, 400);
                } else {
                    objInstance.private.chars = [];
                    if(charCode !== 16 && charCode !== 13) objInstance.private.chars.push(character);
                }

            } else {
                // console.log('NO charCode:',charCode);

                objInstance.private.chars = [];
                if(charCode !== 16 && charCode !== 13) objInstance.private.chars.push(character);
            }
        });

        function mapKeyPressToActualCharacter(isShiftKey, characterCode) {
            if ( characterCode === 27 || characterCode === 8 || characterCode === 9 || characterCode === 20 || characterCode === 16 || characterCode === 17 || characterCode === 91 || characterCode === 13 || characterCode === 92 || characterCode === 18 ) {
                return false;
            }
            if (typeof isShiftKey != "boolean" || typeof characterCode != "number") {
                return false;
            }
            var characterMap = [];
            characterMap[192] = "~";
            characterMap[49] = "!";
            characterMap[50] = "@";
            characterMap[51] = "#";
            characterMap[52] = "$";
            characterMap[53] = "%";
            characterMap[54] = "^";
            characterMap[55] = "&";
            characterMap[56] = "*";
            characterMap[57] = "(";
            characterMap[58] = ";";
            characterMap[48] = ")";
            characterMap[109] = "_";
            characterMap[107] = "+";
            characterMap[219] = "{";
            characterMap[221] = "}";
            characterMap[220] = "|";
            characterMap[59] = ":";
            characterMap[222] = "\"";
            characterMap[188] = "<";
            characterMap[190] = ">";
            characterMap[191] = "?";
            characterMap[32] = " ";
            var character = "";
            if (isShiftKey) {
                if ( characterCode >= 65 && characterCode <= 90 ) {
                    character = String.fromCharCode(characterCode);
                } else {
                    character = characterMap[characterCode];
                }
            } else {
                if ( characterCode >= 65 && characterCode <= 90 ) {
                    character = String.fromCharCode(characterCode).toLowerCase();
                } else {
                    if(characterCode === 191){
                        character = "/";
                    }else if(characterCode === 187){
                        character = "=";
                    }else if(characterCode === 186){
                        character = ";";
                    }else{
                        character = String.fromCharCode(characterCode);
                    }
                }
            }
            // console.log(character)
            return character;
        }



    }
    ComponentProviderConfig.$inject = ["$keyEventProvider"];;














})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
'use strict';

    angular.module('enspire.ui.components.label').directive('enLabel', LabelDirective);

    /**
     * @ngdoc directive
     * @name enLabel
     * @module enspire.ui.components.label
     * @restrict E
     * @element en-label
     * 
     * @description
     * `en-label` is a custom html element that can be used to highlight small text items or create intricate tag styled groups.
     * 
     * @usage
     * <hljs lang="html">
     *     <en-label class="[type] [size] [color]">
     *       Label
     *       <en-detail>22</en-detail>
     *     </en-label>
     * </hljs>
     * 
     * ## Type <a name="labelType"></a>
     * By adding a "type" to the `<en-label>` class you will be able to alter the labels appearance.  There are 3 types to choose from.
     * 
     * Type     | Output                                            | Src
     * ---------| :-----------------------------------------------: | ---------------------------------------------------------------------
     * default  | <span class="en-label primary">(default)</span>   | <hljs lang="html"><en-label class="primary">Label</en-label></hljs>
     * tag      | <span class="en-label tag success">tag</span>     | <hljs lang="html"><en-label class="tag success">Tag</en-label></hljs>
     * circle   | <span class="en-label circle error">22</span>     | <hljs lang="html"><en-label class="circle error">22</en-label></hljs>
     * 
     * 
     * ## Color <a name="labelColor"></a>
     * A label can have many different colors.
     * 
     * <span class="en-label primary">primary</span>
     * <span class="en-label secondary">secondary</span>
     * <span class="en-label info">info</span>
     * <span class="en-label error">error</span>
     * <span class="en-label success">success</span>
     * <span class="en-label warn">warn</span>
     * <hljs lang="html"><en-label class="[primary|secondary|info|error|success|warn]">Label</en-label></hljs>
     * 
     * 
     * ## Size <a name="labelSize"></a>
     * Labels can have different sizes by applying one of the size classes (xs|sm|md|lg) to `<en-label>`.
     * 
     * <span class="en-label xs secondary">xs</span>
     * <span class="en-label sm secondary">sm</span>
     * <span class="en-label md secondary">md</span>
     * <span class="en-label lg secondary">lg</span>
     * <hljs lang="html"><en-label class="[xs|sm|md|lg]">Label</en-label></hljs>
     * 
     * 
     * ## Details <a name="labelDetails"></a>
     * Labels can contain a details element.  This element is used to add visual separation between the text content of a label and any other text that you would
     * like highlighted within the label itself. 
     * 
     * The `<en-detail>` element can be placed before or after the label text. It will accept the same color classes as `en-label`. It can also use the label type class of `circle`
     * to give itself a circular appearance.
     * 
     * <span class="en-label secondary">
     *     Email
     *     <span class="detail circle primary">12</span>
     * </span>
     * 
     * <hljs lang="html">
     *     <en-label class="secondary">
     *       Email
     *       <en-detail class="circle primary">12</en-detail>
     *     </en-label>
     * </hljs>
     *
     */
    
    function LabelDirective() {
        return {
            restrict    : 'E',
            link        : postLink
        };
        
        function postLink($scope, $element, $attrs){
            
        }
    }

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
'use strict';

    angular.module('enspire.ui.components.listObject').directive('enListObject', ListObjectDirective);

    /**
    * @ngdoc directive
    * @name enListObject
    * @module enspire.ui.components.listObject
    * @restrict E
    * @element en-list-object
    *
    * @description
    * List results of an array
    *
    * @param {string=}     name         Reference name of the list.
    * @param {array=}      data         Array of objects containing data to list.
    * @param {number=}     limit        Number of results to show per page.
    * @param {string=}     sort         Name of field the results will be sorted by. To display results in descending order, prefix the field name with a minus (-). `sort="-fieldname"`
    * @param {string=}     q            Query string that filters results. Searches all fields within data object.
    * @param {string=}     on-init      Callback function on init.
    *
    * @usage
    * <hljs lang="html">
    *     <en-list-object name="listName" datat="obj.data.arr"></en-list-object>
    * </hljs>
    *
    */

    function ListObjectDirective($enList) {
        var randomName = function () {
            var length = 32;
            var chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
            var result = '';
            for (var i = length; i > 0; --i){
                result += chars[Math.round(Math.random() * (chars.length - 1))];
            }
            return result;
        };

        return {
            restrict    : 'E',
            link        : postLink
        };

        function postLink($scope, $element, $attrs){
            var listObjectData = randomName();

            var watchData;
            var watchList = $scope.$watch($attrs.data, function (val) {
                $scope[listObjectData] = $scope.$eval($attrs.data);

                watchData = $scope.$watch(function(){ return $scope[listObjectData]; }, function (val) {
                    if(angular.isDefined(val)) ListObject.setData(val);
                },true);
            });

            var ListObject = $enList.object({
                name:$scope.$eval($attrs.name),
                data: $scope[listObjectData] || [],
                limit: $attrs.limit || 0,
                onInit: function(){ $scope.$eval($attrs.onInit); } || undefined,
                sort: $attrs.sort || '',
                q: $attrs.q || ''
            });

            //console.log(ListObject);

            $scope[$attrs.name] = ListObject;

            $element.bind('$destroy', function(){
                ListObject.destroy();
                watchList();
                watchData();
            });
        }
    }
    ListObjectDirective.$inject = ["$enList"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.listObject')
        .provider('$enList', ListService);


    /**
     * @ngdoc service
     * @name $enList
     * @module enspire.ui.components.listObject
     *
     * @usage
     * <hljs lang="js">

     * </hljs>
     *
     */


    function ListService() {
        var self = this;

        this.lists = {};

        var apiObject = {
            name:'', //required (name of the object)
            data:[],
            limit:0,
            offset:0,
            page:0,
            pages:0, //read only
            total:0, //read only
            sort:'',
            q:'',
            filter:'',
            typing:false, //read only
            loading:false, //read only
            getting:false, //read only
            putting:false, //read only
            posting:false, //read only
            deleting:false, //read only
            sorting:'local', //local
            paging:'local', //local
            pagingUsesPageNumbers: false,
            onError:undefined,
            onInit:undefined,
            errors:[],
            segmentedData:{}, //read only
            _runCount: 0, //private (counter for how many times a server was called)
            _errorCount: 0, //private (counter for how many times a server returned an error for this call)
            _errorConsecutiveCount: 0, //private (counter for how many times a server returned a consecutive error for this call)
            _successCount: 0, //private (counter for how many times a server returned a success for this call);
            _isListObject:true
        };

        this.$get = ["$http", "$q", "$rootScope", "$interval", "$timeout", "$filter", function ($http,$q,$rootScope,$interval,$timeout,$filter) {

            var buildListObject = function(o){
                var objTemp = angular.copy(apiObject);

                var obj = angular.extend(objTemp,o);

                //Check required
                if(obj.name===''){
                    console.error('$enList: \'name\' property is not defined');
                    return false;
                }

                if(obj.data===''){
                    console.error('$enList: \'data\' property is not defined');
                    return false;
                }

                obj.limit = parseInt(obj.limit);

                //allows tracking what the default sort was
                obj.defaultSort = obj.sort;

                obj = buildMethods(obj);

                if(typeof obj.onInit === 'function'){
                    obj.onInit(obj);
                }

                $rootScope[obj.name] = obj;
                self.lists[obj.name] = obj;

                return obj;
            };

            var buildMethods = function(objList){

                objList.destroy = function(){
                    delete $rootScope[objList.name];
                    delete self.lists[objList.name];
                };

                var list = function(obj){
                    var passedObj = true;
                    var limit = 0;
                    var offset = 0;
                    var page = 0;
                    var refresh = false;

                    var localPaging = function(){
                        var tempData = angular.copy(objList.data);

                        if(objList.q!=='') {
                            tempData = $filter('filter')(tempData,objList.q);
                        }

                        objList.limit = limit;
                        objList.total = tempData.length;
                        objList.pages = Math.ceil(objList.total/objList.limit);
                        if(isNaN(objList.pages)){
                            objList.pages = 0;
                        }

                        if(offset >= (objList.total-1)){
                            offset = objList.pages*objList.limit-objList.limit;
                        }

                        if(offset < 0){
                            offset = 0;
                        }

                        if(objList.sort!=='') {
                            tempData = $filter('orderBy')(tempData,objList.sort);
                        }

                        if(angular.isObject(tempData)){
                            var keyList = Object.keys(tempData);
                            var segmentedKeys = [];

                            if(objList.limit>0){
                                segmentedKeys = keyList.slice(offset, offset+objList.limit);
                            }else{
                                segmentedKeys = keyList.slice(offset);
                            }

                            for(var x=0;x<segmentedKeys.length;x++){
                                objList.segmentedData = [];

                                objList.segmentedData.push({
                                    "key":segmentedKeys[x]+'',
                                    "value":tempData[segmentedKeys[x]]
                                });
                            }
                        }else{
                            if(objList.limit>0){
                                objList.segmentedData = tempData.slice(offset, offset+objList.limit);
                            }else{
                                objList.segmentedData = tempData.slice(offset);
                            }
                        }

                        objList.offset = offset;

                        objList.page = Math.floor(objList.pages-(objList.total-objList.offset)/objList.limit+1);
                        if(isNaN(objList.page)){
                            objList.page = 0;
                        }
                    };

                    if(obj === undefined){
                        obj = {};
                        passedObj = false;
                    }

                    (obj.limit !== undefined) ? limit = obj.limit : limit = objList.limit;
                    limit = (limit < 0) ? 0 : limit;
                    (obj.offset !== undefined) ? offset = obj.offset : offset = objList.offset;
                    offset = (offset < 0) ? 0 : offset;

                    if(offset>objList.total && objList.total!==0 && objList.pages>0){
                        if(objList.limit !== limit){
                            offset = 0;
                        }else{
                            offset = objList.pages*limit-1-limit;
                        }
                    }

                    if(obj.page !== undefined){
                        page = obj.page;
                    }
                    if(obj.refresh !== undefined){
                        refresh = obj.refresh;
                    }

                    var deferred = $q.defer();

                    localPaging();
                    $timeout(function(){
                        deferred.resolve(objList.data);
                    });

                    return deferred.promise;

                };


                objList.list = list;

                objList.refresh = function(bolResetOffset){
                    var obj = {refresh:true};
                    if(bolResetOffset) obj.offset = 0;
                    return objList.list(obj);
                };

                objList.next = function(){
                    return objList.list({offset:objList.offset+objList.limit});
                };
                objList.previous = function(){
                    return objList.list({offset:objList.offset-objList.limit});
                };
                objList.first = function(){
                    return objList.list({offset:0});
                };
                objList.last = function(){
                    return objList.list({offset:objList.total-objList.limit});
                };
                objList.begin = function(){
                    return objList.list({offset:0});
                };
                objList.setSort = function(field){
                    objList.sort = field;
                    return objList.list({offset:0});
                };
                objList.setData = function(data){
                    objList.data = data;
                    return objList.list();
                };

                return objList;
            };

            var factory = {
                object: buildListObject
            };
            return factory;
        }];
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
'use strict';

    angular.module('enspire.ui.components.loader').directive('enLoader', LoaderDirective);

    /**
     * @ngdoc directive
     * @name enLoader
     * @module enspire.ui.components.loader
     * @restrict A
     *
     * @description
     * Displays a loader over the element the directive is attached to when the provided expression evaluates to true.
     *
     * The en-loader element will be appended as a child of the element it was invoked by.
     *
     * @param {expression} en-loader The expression that is watched by en-loader.  It should eval to a boolean value.  If true, en-loader will be displayed.  When false, en-loader will hide or remain hidden.
     * @param {boolean=} [loader-blur=true] Either an expression or boolean value that evaluates to true/false. When true, en-loader will add a blur effect to all children of the element the en-loader was set on.
     * @param {string=} [loader-text=blank] The text you want displayed under the loading animation.  If the "more" dots (...) are found at the end of the text string `en-loader` will automatically convert them into a repeating animation where each dot flashes onto the text one by one.
     * @param {string=} loader-text-color The #hexidecimal value used to change the text color.
     * @param {string=} loader-color The #hexidecimal value used to change the loader color.  Shorthand hex values (ie. #fff instead of #ffffff) are allowed.
     * @param {string=} [loader-orientation=vertical|vertical, horizontal] Allows the en-loader text to be placed in-line with the loader or below the loader.
     * @param {string=} [loader-size=md|xs, sm, md, lg, xl] Sets the size class of the loader animation.
     * @param {string=} [loader-offset=0|n, n(%), n(px)] When `loader-offset` is set, the en-loader will automatically position itself with the top of its parent.  Using the offset value it will then add distance between itself and the top of its parent.  The `loader-offset` attribute will accept a clean numeric value or a numeric value with a _%_ or _px_ suffix.  It will not accept negative (-n) values.
     *
     */

    function LoaderDirective() {
        return {
            restrict    : 'A',
            compile     : compile
        };

        function compile($element, $attrs){
            var text        = $attrs.loaderText || '';
            var textColor   = $attrs.loaderTextColor;
            var color       = $attrs.loaderColor;
            var sizeClass   = $attrs.loaderSize ? ' '+$attrs.loaderSize : ' md';
            var orientation = $attrs.loaderOrientation==='horizontal' ? $attrs.loaderOrientation : 'vertical';
            var layout      = (orientation==='horizontal') ? 'row' : 'column';
            var loaderOffset= 0;
            var position    = 'center';
            var moreDots    = /(\.\.\.)+$/.test(text) ? ' circle-loader-text-dots' : '';

            var strokeCss   = color ? 'stroke: '+color+';' : '';

            text = text.replace(/(\.\.\.)+$/, '');

            var tmpl;

            if(textColor){
                textColor = 'color: '+textColor;
            }




            // matches px or whole num value
            if(/^([0-9]+)(?:px|)?$/.test($attrs.loaderOffset)){
                position = 'start';
                loaderOffset = parseFloat($attrs.loaderOffset)+'px';
            }
            //matches a percentage value
            else if(/^([0-9]+)(%)+$/.test($attrs.loaderOffset)){
                position = 'start';
                loaderOffset = parseFloat($attrs.loaderOffset)+'%';
            }

            tmpl =  '<div class="en-loader-overlay '+orientation+'" ng-if="'+$attrs.enLoader+'" layout="column" layout-align="'+position+' center" style="margin-top:'+loaderOffset+'">' +
                    '   <div class="en-loader-buffer-overlay" layout="'+ layout +'" layout-align="center center">' +
                    '       <div class="circle-loader'+sizeClass+'">' +
                    '           <svg class="circle-loader-circle" viewBox="25 25 50 50" xmlns="http://www.w3.org/2000/svg">' +
                    '               <circle class="circle-loader-path" cx="50" cy="50" r="20" fill="none" style="'+strokeCss+'" stroke-width="5" stroke-miterlimit="10"/>' +
                    '           </svg>' +
                    '       </div>';

            if(text){
                tmpl += '   <div class="circle-loader-text'+moreDots+'" style="'+ textColor +'">'+ text +'</div>';
            }

            tmpl += '   </div>' +
                    '</div>';

            $element.append(tmpl);

            return function postLink($scope, $element, $attrs){

                var blur = typeof $scope.$eval($attrs.loaderBlur) === 'boolean' ? $scope.$eval($attrs.loaderBlur) : true;

                var elePosition = $element.getStyle('position').toLowerCase();
                if(!(/(absolute|relative|fixed)/i).test(elePosition)){
                    $element.css('position', 'relative');
                }

                $scope.$watch(function(){
                    return $scope.$eval($attrs.enLoader);
                },function(){
                    if($scope.$eval($attrs.enLoader)){
                        if(blur) $element.children().addClass('en-loader-blur');
                    }else{
                        if(blur) $element.children().removeClass('en-loader-blur');
                    }
                });
            };
        }

    }

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';

    angular.module('enspire.ui.components.menu')
        .controller('enMenuController', MenuController);

    /*
     * @private
     * @ngdoc controller
     * @name MenuController
     * @module enspire.ui.components.menu
     *
     */
    function MenuController($scope, $element, $attrs) {
        var self = this;
        self.hasChildren    = 0;
        self.activeItem     = null;

        self.activate = function(ele){
            if(self.activeItem){ self.activeItem.removeClass('open') }
            self.activeItem = ele.addClass('open');

            function closeNav(event) {
                if (!ele.hasClass('hasSubMenu')) {
                    //$scope.offsideMenuActive = false;
                }
            }

            ele.bind('click touchend', closeNav);
        };

        self.getOrientation = function (orientation) {
            orientation = (angular.isDefined(orientation)) ? orientation.trim() : '';
            return (orientation && (/(horizontal|vertical|collapsed)/gi).test(orientation)) ? orientation : 'horizontal';
        }
    }
    MenuController.$inject = ["$scope", "$element", "$attrs"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
'use strict';


    angular.module('enspire.ui.components.menu').directive('enMenu', MenuDirective);


    /**
     * @ngdoc directive
     * @name enMenu
     * @module enspire.ui.components.menu
     * @restrict E
     * @description
     * `en-menu` creates an unordered list `<ul class="en-menu"></ul>` container. Can be used inside of `<en-nav>` to create a top or left sidebar menu.
     *
     * @element en-menu
     *
     * @param {string} [orientation=vertical] Currently, options are **horizontal | vertical | collapsed**. When using with `<en-nav>` position=left or position=offside should be used with orientation=vertical, position=top should be used with orientation=horizontal. default: horizontal
     *
     * @usage
     * <hljs lang="html">
 *       <en-menu orientation="vertical">
 *           <en-menu-item></en-menu-item>
 *       </en-menu>
     * </hljs>
     */
    function MenuDirective($timeout) {
        return {
            restrict    : 'E',
            require     : ['enMenu'],
            transclude  : true,
            replace     : true,
            controller  : 'enMenuController',
            template    : '<ul class="en-menu"></ul>',
            compile     : compile
        };

        function compile($scope, $element, $attrs){
            return function ($scope, $element, $attrs, $ctrls, $transclude) {
                $transclude($scope, function(clone){
                    $element.append(clone);
                    return $timeout(function(){ postLink($scope, $element, $attrs, $ctrls); });
                });
            };
        }

        function postLink($scope, $element, $attrs, $ctrls) {
            var $menuCtrl = $ctrls[0];

            $menuCtrl.hasChildren = ($element[0].childElementCount > 0);

            if ($menuCtrl.hasChildren) {
                $element.parent().addClass('hasSubMenu');
            }

            if ($element.attr('orientation') != undefined) {
                var orientation = $menuCtrl.getOrientation($attrs.orientation);
                $element.addClass(orientation);
            }
        }
    }
    MenuDirective.$inject = ["$timeout"];


})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.modal')
        .controller('enModalController', ModalController);

    /*
     * @private
     * @ngdoc controller
     * @name ModalController
     * @module enspire.ui.components.modal
     *
     */
    function ModalController($scope, $element, $attrs, $enModal, $location, $timeout) {
        var self = this;

        //exposes to the the code is inside a modal
        $scope.isModal = true;
        $scope.modalId = $attrs.id;
        $scope.modalPath = $attrs.path;

        // Properties
        self.isMinimized = false;
        self.isMaximized = false;

        // Methods
        self.showFooter = function(panel){
            $element.removeClass('noFooter');
        };

        $scope.centerModal = function(){
            $timeout(function(){
                $enModal.center($attrs.id);
            });
        };

        /**
         * @ ngdoc function
         * @name closeModal
         * @module enspire.ui.components.modal
         * @description
         * fires callback function when closes modal.
         */
        $scope.closeModal = function(){
            $enModal.close($attrs.id, arguments);
        };

        /**
         * @ ngdoc function
         * @name cancelModal
         * @module enspire.ui.components.modal
         * @description
         * closes modal without firing callback.
         */
        $scope.cancelModal = function(){
            $enModal.cancel($attrs.id);
        };

        $scope.showModal = function(modal,params,func){
            $enModal.open(modal,params,func);
        };

        $scope.showScreen = function(screen){
            $timeout(function(){ $location.url(screen); });
        };
    }
    ModalController.$inject = ["$scope", "$element", "$attrs", "$enModal", "$location", "$timeout"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.modal')
        .directive('enModal', ModalDirective);

    /**
     * @ngdoc directive
     * @name enModal
     * @module enspire.ui.components.modal
     * @restrict E
     * @description
     * Produces a modal.
     *
     * @element en-modal
     * @param {string=}      id                       Element id
     * @param {boolean=}     [data-overlay=false]     Adds translucent background overlay under modal.
     * @param {boolean=}     [show-close=false]       Adds close icon.
     * @param {string=}      width                    Width of modal.
     * @param {string=}      height                   Height of modal.
     *
     * @usage
     * <hljs lang="html">
     *   <en-modal show-close>
     *       <en-modal-header></en-modal-header>
     *       <en-modal-body></en-modal-body>
     *       <en-modal-footer></en-modal-footer>
     *   </en-modal>
     * </hljs>
     *
     * ## Available Functions
     *
     * Function         | Params | Description
     * -----------------|--------|------------
     * showModal() | path, data, callback function name | Opens modal.
     * closeModal() | callback args | Fires callback function from showModal() when closes modal.
     * cancelModal() | | Closes modal without firing callback.
     *
     */
    function ModalDirective($enModal,$timeout,$enTouch,$location) {
        return {
            restrict: 'E',
            controller: 'enModalController',
            link:postLink
        };

        function postLink($scope, $element, $attrs) {

            $scope.modalTitle = '';
            $scope.showClose = false;

            var showHeader = true;

            angular.isDefined($attrs.showClose) ? $scope.showClose = ($attrs.showClose==='false' ? false : true)  : true;
            angular.isDefined($attrs.header) ? showHeader = ($attrs.header==='false' ? false : true) : '';
            angular.isDefined($attrs.width) ? $element.css('width',$attrs.width+'px') : '';
            angular.isDefined($attrs.height) ? $element.css('height',$attrs.height+'px') : '';
            angular.isDefined($attrs.title) ? $scope.modalTitle = $attrs.title : '';

            $attrs.$observe('title', function(val){
                $scope.modalTitle = val;
            });

            if(showHeader===false){
                $element.find('.rpPopUpWindowHeader').hide();
                $element.find('.rpPopUpWindowHeaderClose').hide();
                $element.addClass('noHeader');
            }

            if($scope.showClose === true) {
                var headerAttributes = {'layout': 'row', 'layout-align': 'start center'};
                $element.append('<en-icon icon="x" class="en-modal-close is-clickable"></en-icon>');

                // bind cancelModal to close icon
                $element[0].querySelector('.en-modal-close').addEventListener("click", function(e) {
                    $scope.cancelModal();
                });
            }


            /*handle the focusing on input fields, keeping the tabbing rotation inside the modal*/
            $timeout(function(){
                var inputs = $element.find('select, input, textarea');

                if(inputs.length>0){
                    var firstInput = inputs.first();
                    var lastInput = inputs.last();

                    /*set focus on first input*/
                    if(!$enTouch.isTouch){
                        firstInput.focus();
                    }else{
                        var keyInputs = $element.find('input, textarea');
                        keyInputs.on('focus',function(e){
                            $enModal.moveToTop($attrs.id);
                        });
                        keyInputs.on('blur',function(e){
                            $timeout(function(){
                                if($("input:focus, textarea:focus",$element).length===0){
                                    $enModal.center($attrs.id);
                                }
                            });
                        });
                    }

                    /*redirect last tab to first input*/
                    lastInput.on('keydown', function (e) {
                        if ((e.which === 9 && !e.shiftKey)) {
                            e.preventDefault();
                            firstInput.focus();
                        }
                    });

                    /*redirect first shift+tab to last input*/
                    firstInput.on('keydown', function (e) {
                        if ((e.which === 9 && e.shiftKey)) {
                            e.preventDefault();
                            lastInput.focus();
                        }
                    });
                }

            });

        }
    }
    ModalDirective.$inject = ["$enModal", "$timeout", "$enTouch", "$location"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.modal')
        .factory('$enModal', ModalService);


    function ModalService($timeout, $document, $compile, $rootScope, $templateCache, $http, $enPosition, $enDraggable) {

        var $modal = {};

        $modal.windows = {};

        $modal.overlay = null;
        $modal.parent = null;
        $modal.zIndex = 10000;

        var modalCleanUp = function(moduleID, args, bolFireCallback){
            $timeout(function () {
                $modal.windows[moduleID].content.remove();
                if(bolFireCallback){
                    $modal.windows[moduleID].callback.apply(this, args);
                }
                $modal.windows[moduleID].scope.$destroy();

                var hasOverlay = !!$modal.windows[moduleID].overlay;
                delete $modal.windows[moduleID];

                if(hasOverlay){
                    var topWindow = '';
                    var topWindowZ = 1;
                    if (Object.keys($modal.windows).length > 0){
                        for (var win in $modal.windows) {
                            if ($modal.windows.hasOwnProperty(win)) {
                                var objWin = $modal.windows[win];
                                if(objWin.zIndex>=topWindowZ && objWin.overlay){
                                    topWindow = win;
                                    topWindowZ = objWin.zIndex;
                                }
                            }
                        }
                        if(topWindow!==''){
                            $modal.overlay.css({'z-index':topWindowZ-1, 'display':'block'});
                        }else{
                            $modal.overlay.css({'display':'none'});
                        }
                    }else{
                        $modal.overlay.css({'display':'none'});
                    }
                }

                if (Object.keys($modal.windows).length === 0) $modal.zIndex = 10000;
                return true;
            });
        };

        $modal.close = function (moduleID, args) {
            if ($modal.windows[moduleID] === undefined) return false;
            modalCleanUp(moduleID, args, true);
        };

        $modal.cancel = function (moduleID, args) {
            if ($modal.windows[moduleID] === undefined) return false;
            modalCleanUp(moduleID, args, false);
        };

        $modal.center = function (moduleID,module) {
            if ($modal.windows[moduleID] === undefined) return false;
            var modal = $modal.windows[moduleID].content;
            var moduleRect = $enPosition.rect(document.getElementById(moduleID));
            var b = angular.element(document.querySelector('en-win'))[0];
            var left = (b.clientWidth - moduleRect.width) / 2;
            var top = (b.clientHeight - moduleRect.height) / 2;
            modal.css({left: left+'px', top: top+'px'});
            return true;
        };

        $modal.moveToTop = function (moduleID) {
            //console.log('moveToTop');
            if ($modal.windows[moduleID] === undefined) return false;
            var modal = $modal.windows[moduleID].content;
            var moduleRect = $enPosition.rect(document.getElementById(moduleID));
            var b = angular.element(document.querySelector('en-win'));
            var left = (b.clientWidth - moduleRect.width) / 2;
            var top = 0;
            modal.css({left: left+'px', top: top+'px'});
            return true;
        };

        $modal.$$getId = function () {
            var fmt = 'fxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';

            return fmt.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        };

        $modal.open = function (templatePath, obj, func, useDataProp) {
            if (!func) func = function () {
                //console.log('no func')
            };

            if (!obj) obj = {};


            if(angular.isDefined(useDataProp) && (!useDataProp || useDataProp==false)){
                obj = obj;
            }else{
                obj = {data:obj};
            }


            /*ignores url param states*/
            obj.ignoreStateChange = true;

            /*create overlay*/
            if ($modal.overlay === null) {
                $modal.overlay = angular.element('<div class="en-modal-overlay"></div>');
                $modal.parent = $document.find('en-win').eq(0);
                $modal.parent.append($modal.overlay);
            }

            var body = $modal.parent;

            var modelReturnObj = {};

            var processTemplate = function (template) {
                var newScope = $rootScope.$new(true);
                var moduleContent = angular.element(template);
                var moduleID = moduleContent.attr('id');
                if (moduleID !== undefined && moduleID !== '') {
                    if ($modal.windows[moduleID] !== undefined) {
                        $modal.center(moduleID);
                        return false;
                    }
                } else {
                    moduleID = $modal.$$getId();
                    moduleContent.attr('id', moduleID);
                    moduleContent.addClass(moduleID);
                    moduleContent.attr('path', templatePath);
                }

                for (var value in obj) {
                    if (obj.hasOwnProperty(value)) {
                        newScope[value] = obj[value];
                    }
                }

                var modalDomEl = $compile(moduleContent)(newScope, function (clonedElement, $scope) {
                    $timeout(function () {
                        $modal.center(moduleID,clonedElement);
                        //clonedElement.draggable({containment: ".en-win", handle: '.en-modal-header'});

                        if($modal.windows[moduleID].draggable){
                            // create new draggable element
                            var dragEl = $enDraggable.init(clonedElement[0], {
                                'scope': $scope,
                                'containment': 'en-win',
                                'handle': 'en-modal-header'
                            });

                            // Remove bindings
                            $scope.$on('$destroy', function() {
                                $enDraggable.destroy(dragEl);
                            });
                        }


                        clonedElement.css({'z-index': $modal.zIndex, 'visibility':'visible'});
                        $modal.windows[moduleID].zIndex = $modal.zIndex+0;
                        $modal.zIndex = $modal.zIndex + 100;
                    }, 200);

                    /*injects params into the scope of controller*/
                    $timeout(function () {
                        var $$childHead = $scope.$$childHead;
                        if ($$childHead !== null) {
                            for (var value in obj) {
                                if (obj.hasOwnProperty(value)) {
                                    $$childHead[value] = obj[value];
                                }
                            }
                        }

                        //console.log($scope);
                    });

                    var hasOverlay = (moduleContent.attr('data-overlay') === 'true' || moduleContent.attr('overlay') === 'true');
                    var isDraggable = (moduleContent.attr('data-draggable') === 'true' || moduleContent.attr('draggable') === 'true');

                    $modal.windows[moduleID] = {
                        scope: newScope,
                        content: clonedElement,
                        overlay: hasOverlay,
                        draggable: isDraggable,
                        zIndex: $modal.zIndex,
                        callback: func
                    };
                    body.append(clonedElement);

                    if (hasOverlay) {
                        $modal.overlay.css({'z-index':$modal.zIndex, 'display':'block'});
                        $modal.zIndex = $modal.zIndex + 100;
                    }

                });

                modelReturnObj = {
                    close: function(){ $modal.close(moduleID); },
                    cancel: function(){ $modal.cancel(moduleID); },
                    center: function(){ $modal.center(moduleID); },
                    moveToTop: function(){ $modal.moveToTop(moduleID); }
                };


                return modelReturnObj;
            };

            var url = ('views/modals/' + templatePath + '.html').replace(/\/\//g, '/');
            if (templatePath.length > 5) {
                if (templatePath.substring(templatePath.length - 5) === '.html') url = templatePath;
            }

            return $http.get(url, {cache: $templateCache}).then(function (result) {
                return processTemplate(result.data);
            });

            //modelReturnObj;
        };

        return $modal;
    }
    ModalService.$inject = ["$timeout", "$document", "$compile", "$rootScope", "$templateCache", "$http", "$enPosition", "$enDraggable"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(window, angular, undefined){
'use strict';

    angular.module('enspire.ui.components.msg')
        .directive('enMsgs', MsgsDirective)
        .directive('enMsg', MsgDirective);


    //<en-msgs for="demoForm.firstName.$error" ng-show="(demoForm.$submitted || demoForm.firstName.$touched) && demoForm.firstName.$invalid" include="error-messages"></en-msgs>



   /**
    * @ngdoc directive
    * @module enspire.ui.components.msg
    * @name enMsgs
    *
    * @restrict AE
    *
    * @description
    * `enMsgs` is a directive that is designed to show and hide messages based on the state
    * of a key/value object that it listens on. The directive itself compliments error message
    * reporting with the `ngModel` $error object (which stores a key/value state of validation errors).
    *
    * `enMsgs` manages the state of internal messages within its container element. The internal
    * messages use the `enMsg` directive and will be inserted/removed from the page depending
    * on if they're present within the key/value object. By default, only one message will be displayed
    * at a time and this depends on the prioritization of the messages within the template. (This can
    * be changed by using the en-msgs-multiple on the directive container.)
    *
    * A remote template can also be used to promote message reusability and messages can also be
    * overridden.
    *
    * @usage
    * ```html
    * <!-- using attribute directives -->
    * <ANY en-msgs="expression">
    *   <ANY en-msg="keyValue1">...</ANY>
    *   <ANY en-msg="keyValue2">...</ANY>
    *   <ANY en-msg="keyValue3">...</ANY>
    * </ANY>
    *
    * <!-- or by using element directives -->
    * <en-msgs for="expression">
    *   <en-msg when="keyValue1">...</en-msg>
    *   <en-msg when="keyValue2">...</en-msg>
    *   <en-msg when="keyValue3">...</en-msg>
    * </en-msgs>
    * ```
    *
    * @param {string} en-msgs an angular expression evaluating to a key/value object
    *                 (this is typically the $error object on an ngModel instance).
    * @param {string=} en-msgs-multiple|multiple when set, all messages will be displayed with true
    * @param {string=} en-msgs-include|include when set, the specified template will be included into the en-msgs container
    *
    */


    function MsgsDirective($compile, $animate, $templateRequest){
        var ACTIVE_CLASS    = 'ng-active field-error';
        var INACTIVE_CLASS  = 'ng-inactive';

       var genericMsgTemplates = '<en-msg when="required" class="msg-error">This field is required</en-msg>' +
                                 '<en-msg when="min" class="msg-error">Greater value required</en-msg>' +
                                 '<en-msg when="max" class="msg-error">Lesser value required</en-msg>' +
                                 '<en-msg when="minlength" class="msg-error">This field is too short</en-msg>' +
                                 '<en-msg when="maxlength" class="msg-error">This field is too long</en-msg>' +
                                 '<en-msg when="pattern" class="msg-error">The input type is incorrect</en-msg>' +
                                 '<en-msg when="email" class="msg-error">Invalid email format</en-msg>'+
                                 '<en-msg when="enPasswordCheck" class="msg-error">Passwords do not match</en-msg>';


        return {
            restrict    : 'AE',
            require     : 'enMsgs',
            controller  : MsgsController,
            link        : postLink
        };

        function postLink($scope, element, $attrs, ctrl){
            ctrl.renderElementClasses = function(bool) {
              bool ? $animate.setClass(element, ACTIVE_CLASS, INACTIVE_CLASS)
                   : $animate.setClass(element, INACTIVE_CLASS, ACTIVE_CLASS);
            };

            //JavaScript treats empty strings as false, but en-msg-multiple by itself is an empty string
            var multiple = angular.isString($attrs.enMsgsMultiple) ||
                           angular.isString($attrs.multiple);

            var cachedValues,
                watchAttr = $attrs.enMsgs || $attrs['for']; //for is a reserved keyword

            var refs = watchAttr.split('.');
            ctrl.form  = refs[0];
            ctrl.field = refs[1] || null;

            var field = $scope.$eval(ctrl.form+'.'+ctrl.field);
            if(angular.isDefined(field)){
                $scope.$watchCollection(ctrl.form+'.'+ctrl.field, function(values) {
                    //ctrl.isInValid = (($scope[ctrl.form].$submitted || $scope[ctrl.form][ctrl.field].$touched) && $scope[ctrl.form][ctrl.field].$invalid);
                    cachedValues = values;
                    ctrl.renderMessages($scope, values.$error, multiple);
                });

                $scope.$watchCollection(ctrl.form+'.$submitted', function(values) {
                    var field = $scope.$eval(ctrl.form+'.'+ctrl.field);
                    ctrl.renderMessages($scope, field.$error, multiple);
                });

                $scope.$watchCollection(ctrl.form+'.$alwaysShowErrors', function(values) {
                    var field = $scope.$eval(ctrl.form+'.'+ctrl.field);
                    ctrl.renderMessages($scope, field.$error, multiple);
                });
            }else{
                console.warn('en-msg: '+ctrl.form+'.'+ctrl.field+' is undefined!');
            }


            ///*watch for invalid*/
            //$scope.$watch(function(){
            //    return angular.isDefined($ctrl[0][inputName]) ? $ctrl[0][inputName].$viewValue : false;
            //},function(newValue){
            //    if(newValue!==false && $ctrl[0][inputName].$dirty){
            //        $scope.inputErrors = $validationErrors.inputErrors($ctrl[0][inputName],$attrs);
            //    }
            //});

            processTemplate(genericMsgTemplates);
            var tpl = $attrs.enMsgsInclude || $attrs.include;
            if (tpl) {
              $templateRequest(tpl).then(processTemplate(html));
            }
            function processTemplate(html) {
              var after, container = angular.element('<div/>').html(html);
              angular.forEach(container.children(), function(elm) {
               elm = angular.element(elm);
               after ? after.after(elm) : element.prepend(elm); //start of the container
               after = elm;
               $compile(elm)($scope);
              });
              ctrl.renderMessages($scope, cachedValues, multiple);
            }
        }


        function MsgsController(){
            var self = this;

            this.form  = null;
            this.field = null;
            //this.isInValid = false;

            this.$renderNgMessageClasses = angular.noop;

            var messages = [];
            this.registerMessage = function(index, message) {
              for (var i = 0; i < messages.length; i++) {
                if (messages[i].type === message.type) {
                  if (index !== i) {
                    var temp = messages[index];
                    messages[index] = messages[i];
                    if (index < messages.length) {
                      messages[i] = temp;
                    } else {
                      messages.splice(0, i); //remove the old one (and shift left)
                    }
                  }
                  return;
                }
              }
              messages.splice(index, 0, message); //add the new one (and shift right)
            };

            this.renderMessages = function(scope, values, multiple) {
              values = values || {};

              var found;
              angular.forEach(messages, function(message) {
                //ctrl.parentForm  = refs[0];
                //ctrl.parentField = refs[1] || null;


                if ((!found || multiple) && truthyVal(values[message.type])) {

                    if((scope[self.form].$alwaysShowErrors || scope[self.form].$submitted || scope[self.form][self.field].$touched || scope[self.form][self.field].$dirty) && scope[self.form][self.field].$invalid){
                        message.attach();
                        found = true;
                    }

                } else {
                    message.detach();
                }
              });

              this.renderElementClasses(found);

              function truthyVal(value) {
                return value !== null && value !== false && value;
              }
            };
        }
    }
    MsgsDirective.$inject = ["$compile", "$animate", "$templateRequest"];


/**
    * @ngdoc directive
    * @name enMsg
    * @module enspire.ui.components.msg
    *
    * @restrict AE
    * @scope
    *
    * @description
    * `enMsg` is a directive with the purpose to show and hide a particular message.
    * For `enMsg` to operate, a parent `enMsgs` directive on a parent DOM element
    * must be situated since it determines which messages are visible based on the state
    * of the provided key/value map that `enMsgs` listens on.
    *
    * @usage
    * ```html
    * <!-- using attribute directives -->
    * <ANY en-msgs="expression">
    *   <ANY en-msg="keyValue1">...</ANY>
    *   <ANY en-msg="keyValue2">...</ANY>
    *   <ANY en-msg="keyValue3">...</ANY>
    * </ANY>
    *
    * <!-- or by using element directives -->
    * <en-msgs for="expression">
    *   <en-msg when="keyValue1">...</en-msg>
    *   <en-msg when="keyValue2">...</en-msg>
    *   <en-msg when="keyValue3">...</en-msg>
    * </en-msgs>
    * ```
    *
    * @param {string} enMsg a string value corresponding to the message key.
    */
    function MsgDirective($animate) {
        var COMMENT_NODE = 8;
        return {
            require     : '^enMsgs',
            transclude  : 'element',
            terminal    : true,
            restrict    : 'AE',
            link        : postLink
        };

        function postLink($scope, $element, $attrs, enMsgs, $transclude){
            var index, element;

            var commentNode = $element[0];
            var parentNode = commentNode.parentNode;
            for (var i = 0, j = 0; i < parentNode.childNodes.length; i++) {
              var node = parentNode.childNodes[i];
              if (node.nodeType === COMMENT_NODE && node.nodeValue.indexOf('enMsg') >= 0) {
                if (node === commentNode) {
                  index = j;
                  break;
                }
                j++;
              }
            }

            enMsgs.registerMessage(index, {
              type: $attrs.enMsg || $attrs.when,
              attach: function() {
                if (!element) {
                  $transclude($scope, function(clone) {
                    $animate.enter(clone, null, $element);
                    element = clone;
                  });
                }
              },
              detach: function(now) {
                if (element) {
                  $animate.leave(element);
                  element = null;
                }
              }
            });

        }
    }
    MsgDirective.$inject = ["$animate"];




















    //function MsgsDirective($timeout) {
    //    return {
    //        restrict    : 'E',
    //        transclude  : true,
    //        replace     : true,
    //        template    : '<en-msgs></en-msgs>',
    //        compile     : compile
    //    };
    //
    //    function compile($scope, $element, $attrs){
    //
    //        return function ($scope, $element, $attrs, $ctrls, $transclude) {
    //            //var html = $element.children();
    //            //console.log(html);
    //
    //            var forStr = $attrs.for || '';
    //
    //            if(angular.isDefined($attrs.for) && $attrs.for.indexOf('.$error') === -1){
    //                forStr += '.$error';
    //            }
    //
    //            var refs = forStr.split('.');
    //
    //            $element.attr('for', forStr);
    //            $element.attr('include', 'error-messages');
    //
    //            if(angular.isDefined($attrs.ngShow)){
    //                $element.attr('ng-show', $attrs.ngShow);
    //            }else{
    //                $element.attr('ng-show', '(' + refs[0] + '.$submitted || ' + refs[0] + '.' + refs[1] + '.$touched) && ' + refs[0] + '.' + refs[1] + '.$invalid');
    //            }
    //
    //            $transclude($scope, function(clone){
    //                $element.append(clone);
    //                //return $timeout(function(){ postLink($scope, $element, $attrs, $ctrls); });
    //            });
    //        };
    //    }
    //}
    //
    //
    //
    //function MsgDirective() {
    //    return {
    //        restrict    : 'E',
    //        transclude  : true,
    //        replace     : true,
    //        terminal    : true,
    //        template    : '<en-msg ng-transclude></en-msg>',
    //        link        : compile
    //    };
    //
    //    function compile($scope, $element, $attrs){
    //        //return function ($scope, $element, $attrs, $ctrls, $transclude) {
    //        //    $transclude($scope, function(clone){
    //        //        $element.append(clone);
    //        //    });
    //        //};
    //    }
    //}
    //
})(window, window.angular);

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

   /**
     * @ngdoc module
     * @name enspire.ui.components.multiSelect
     * @description
     * `en-multi-select` module.
     *
     */
    angular
        .module('enspire.ui.components.multiSelect', [])
        .run([ '$templateCache', function($templateCache) {

            /**
             * Store template into templateCache
             */
            var tpl = '<div class="en-multi-select {{labelPosition}}" ng-class="{\'disabled\':disabled,\'error\':inputErrors.length>0,\'warn\':warn===\'true\'}">'
                    + '    <label style="display:none;">Choose Attributes:</label><span style="display: inline-block;"><en-icon icon="help" ng-if="help" en-popover popover-title="{{ helpTitle }}" popover-content="{{ helpText }}"></en-icon></span>'
                    + '    <label for="{{selectID}}" data-ng-if="::label">{{label}}<sup ng-if="::required"> *</sup></label>'
                    + '    <div class="en-multi-select-field">'
                    + '        <div class="element-from">'
                    + '            <div class="en-multi-select-title" ng-if="::labelFrom">{{labelFrom}}</div>'
                    + '            <div class="wrapper">'
                    + '                <select class="select-box" id="{{selectID}}" ng-model="selectFrom" data-ng-options="{{options}}" multiple ng-disabled="disabled"></select>'
                    + '            </div>'
                    + '            <en-button class="group-action-button" en-tap="selectAll(\'from\')" ng-disabled="list.length===0 || disabled">{{(list.length===selectFrom.length) ? \'Deselect All\' :\'Select All\'}}</en-button>'
                    + '        </div>'
                    + '        <div class="element-controls">'
                    + '            <en-button ng-disabled="selectFrom.length===0 || disabled" en-tap="add()">'
                    + '                 <en-icon icon="chevron-right-double"></en-icon>'
                    + '            </en-button><br />'
                    + '            <en-button ng-disabled="selectTo.length===0 || disabled" en-tap="remove()">'
                    + '                 <en-icon icon="chevron-left-double"></en-icon>'
                    + '            </en-button>'
                    + '        </div>'
                    + '        <div class="element-to">'
                    + '            <div class="en-multi-select-title">{{labelTo}}</div>'
                    + '            <div class="wrapper">'
                    + '                <select class="select-box" ng-model="selectTo" data-ng-options="{{options.replace(\'in list\',\'in model\')}}" multiple ng-disabled="disabled" ng-required="required"></select>'
                    + '            </div>'
                    + '            <en-button class="group-action-button" data-stretch="true" en-tap="selectAll(\'to\')" ng-disabled="model.length===0 || disabled">{{(model.length===selectTo.length) ? \'Deselect All\' :\'Select All\'}}</en-button>'
                    + '        </div>'
                    + '    </div>'
                    + '    <en-form-error data-errors="inputErrors" data-ng-if="inputErrors.length>0"></en-form-error>'
                    + '</div>';

            $templateCache.put('multiselect/multiselect.tpl.html', tpl);
        } ]);

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.multiSelect').directive('enMultiSelect', MultiSelectDirective);

    /**
     * @ngdoc directive
     * @name enMultiSelect
     * @module enspire.ui.components.multiSelect
     * @restrict E
     * @description
     * `en-multi-select` creates two lists where items can be copied over from one list element to the other.
     *
     * @element en-multi-select
     *
     * @param {string}    ng-model         List model
     * @param {string}    list             Name of collection or array.
     * @param {string}    options          Specifies how to iterate over the collection.
     * @param {boolean=}  ng-disabled      Expression that evaluates to true|false and disables or enables the element.
     * @param {string=}   sort             Sort by specified key.
     * @param {string=}   key              key
     * @param {string=}   help             help
     * @param {string=}   help-title       help-title
     * @param {string=}   help-text        Help text to display.
     * @param {string=}   ng-required      ng-required
     * @param {string=}   warn             Warning message to display.
     * @param {string=}   label            label
     * @param {string=}   label-from       Sets the label to display on list of available items. *Defaults to 'Available'.*
     * @param {string=}   label-to         Sets the label to display on list of chosen items. *Defaults to 'Chosen'.*
     * @param {string=}   label-position   label-position
     *
     *
     * @usage
     * ### HTML:
     * <hljs lang="html">
     * <en-form data-ng-init="modelData=[];">
     *     <en-multi-select
     *         data-ng-model="modelData"
     *         data-list="colors"
     *         data-sort="name"
     *         data-key="name"
     *         data-options="color.name for color in list track by color.name">
     *     </en-multi-select>
     * </en-form>
     * </hljs>
     *
     *
     * ### JS:
     * <hljs lang="js">
     *     $scope.colors = [
     *         {name:'black', shade:'dark'},
     *         {name:'white', shade:'light'},
     *         {name:'red', shade:'dark'},
     *         {name:'blue', shade:'dark'},
     *         {name:'yellow', shade:'light'}
     *     ];
     * </hljs>
     */

    function MultiSelectDirective($filter, $timeout){
        return {
            restrict: 'E',
            transclude: true,
            replace:true,
            scope:{
                model           : '=ngModel',
                attrList        : '=list',
                options         : '@options',
                isDisabled      : '=ngDisabled',
                sort            : '@',
                key             : '@',
                help            : '@',
                helpTitle       : '@',
                helpText        : '@',
                required        : '=ngRequired',
                warn            : '@',
                label           : '@',
                attrLabelFrom   : '@labelFrom',
                attrLabelTo     : '@labelTo',
                attrLabelPosition:'@labelPosition'
            },
            require: ['^?form'],
            templateUrl: 'multiselect/multiselect.tpl.html',
            compile: function ($element, $attrs, $transclude) {
                var uniqueId = function(pre, post) {
                        pre  = pre  || '';
                        post = post || '';
                        return pre + new Date().getTime() + post;
                    },
                    select = $element.find('select'),
                    selectName = angular.isDefined($attrs.ngModel) ? $attrs.ngModel : uniqueId('id');

                /*If ng-model is not defined remove all attributes from template with dependencies*/
                if($attrs.ngModel!==selectName){
                    select.removeAttr('data-ng-model');
                    select.removeAttr('data-en-server-validation');
                }

                /*Grab parameter name of field*/
                var arySelectName = selectName.split('.');
                selectName= arySelectName[arySelectName.length-1];

                /*set name of input*/
                select.attr('name',selectName);

                return function ($scope, $element, $attrs) {
                    var eSelect = $element.find('select');
                    $transclude($scope, function (clone) { eSelect.append(clone); });


                    $scope.selectID = uniqueId('id');
                    $scope.inputErrors = [];
                    $scope.width = {};
                    $scope.widthValue = '';
                    $scope.focus = false;
                    $scope.disabledSelectAllFrom = true;
                    $scope.disabledSelectAllTo = true;
                    $scope.selectFrom = [];
                    $scope.selectTo = [];
                    $scope.orglist = [];
                    $scope.list = [];
                    //$scope.key = '';
                    $scope.sort = 'toString()';

                    $scope.disabled = $scope.isDisabled || false;

                    $scope.labelPosition    = (angular.isDefined($scope.attrLabelPosition)) ? $scope.attrLabelPosition : '';
                    $scope.labelFrom        = (angular.isDefined($scope.attrLabelFrom))     ? $scope.attrLabelFrom : 'Available';
                    $scope.labelTo          = (angular.isDefined($scope.attrLabelTo))       ? $scope.attrLabelTo   : 'Chosen';


                    $scope.toggleBtn = function(){
                        ($scope.disabledSelectAllFrom) ? $scope.disabledSelectAllFrom = false:  $scope.disabledSelectAllFrom = true;
                    };

                    $scope.add = function(){
                        if(!$scope.disabled) {
                            var lngList = $scope.selectFrom.length;
                            $scope.modelTemp = [];
                            angular.copy($scope.model, $scope.modelTemp);
                            for (var i = 0; i < lngList; i++) {
                                $scope.modelTemp.push($scope.selectFrom[i]);
                            }
                            $scope.selectFrom = [];
                            if ($scope.sort !== '') $scope.modelTemp = $filter('orderBy')($scope.modelTemp, $scope.sort, false);
                            angular.copy($scope.modelTemp, $scope.model);
                            compareLists();
                        }
                    };

                    $scope.remove = function(){
                        if(!$scope.disabled) {
                            var lngList = $scope.selectTo.length;
                            var lngModel = $scope.model.length;
                            $scope.modelTemp = [];
                            for (var i = 0; i < lngModel; i++) {
                                var itemSelected = $scope.model[i];
                                var bolSelected = false;
                                for (var x = 0; x < lngList; x++) {
                                    var itemDeselected = $scope.selectTo[x];
                                    if ($scope.key !== '' && $scope.key !== undefined) {
                                        if (itemSelected[$scope.key] === itemDeselected[$scope.key]) bolSelected = true;
                                    } else {
                                        if (itemSelected === itemDeselected) bolSelected = true;
                                    }
                                }
                                if (bolSelected === false) $scope.modelTemp.push(itemSelected);
                            }
                            $scope.selectTo = [];
                            if ($scope.sort !== '') $scope.modelTemp = $filter('orderBy')($scope.modelTemp, $scope.sort, false);
                            angular.copy($scope.modelTemp, $scope.model);
                            compareLists();
                        }
                    };

                    $scope.selectAll = function(dir){
                        if(!$scope.disabled) {
                            if (dir === 'from') {
                                ($scope.selectFrom.length === $scope.list.length) ? $scope.selectFrom = [] : $scope.selectFrom = angular.copy($scope.list);
                            } else {
                                ($scope.selectTo.length === $scope.model.length) ? $scope.selectTo = [] : $scope.selectTo = angular.copy($scope.model);
                            }
                        }
                    };

                    var runFirst = {
                        attrList: false,
                        model: false
                    };
                    $scope.$watch('isDisabled', function(n,o){
                        if(n!==o){
                            $scope.disabled = n;
                        }
                    });

                    $scope.$watch('attrList',function(n,o){
                        if(n!==o && $scope.sort!=='' || runFirst.attrList===false && $scope.sort!==''){
                            $scope.orglist = $filter('orderBy')(n,$scope.sort,false);
                            compareLists();
                            runFirst.attrList = true;
                        }
                    });
                    $scope.$watch('model', function(n,o){
                        if(n!==o || runFirst.model===false){
                            compareLists();
                            runFirst.model = true;
                        }
                    });

                    var compareLists = function(){
                        if(!angular.isDefined($scope.model)) $scope.model = [];
                        if(angular.isArray($scope.orglist) && angular.isArray($scope.model)) {
                            var listLen = $scope.orglist.length;
                            var modelLen = $scope.model.length;
                            $scope.modelTemp = [];
                            var newObj = [];


                            //loop through all options
                            for (var i = 0; i < listLen; i++) {
                                var listItem = $scope.orglist[i];
                                var itemInModel = false;

                                //loop through selected options
                                for (var x = 0; x < modelLen; x++) {
                                    var modelItem = $scope.model[x];

                                    if(angular.isDefined($scope.key) && $scope.key!=='') {
                                        if (listItem[$scope.key] === modelItem[$scope.key]){
                                            itemInModel = true;
                                        }
                                    }else{
                                        if (listItem === modelItem){
                                            itemInModel = true;
                                        }
                                    }
                                }
                                (itemInModel === false) ? newObj.push(listItem) : $scope.modelTemp.push(listItem);
                            }
                            angular.copy($scope.modelTemp, $scope.model);
                            $scope.list = newObj;

                            $timeout(function() {
                                var option = document.createElement("option");
                                eSelect[1].add(option,null);
                                eSelect[1].remove(eSelect[1].options.length-1);
                            });

                        }
                    };
                };
            }
        };
    }
    MultiSelectDirective.$inject = ["$filter", "$timeout"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';

    angular.module('enspire.ui.components.nav')
        .controller('enNavController', NavController)

    /*
     * @private
     * @ngdoc controller
     * @name NavController
     * @module enspire.ui.components.nav
     *
     */
    function NavController($scope, $element, $attrs) {
        var self = this;
        self.position    = '';
        self.collapsed   = false;
        self.activeItems = [];

        self.getPosition = function (pos) {
            pos = (angular.isDefined(pos)) ? pos.trim() : '';
            return (pos && (/(left|top|right|offside|collapsed)/gi).test(pos)) ? pos : 'left';
        }
    }
    NavController.$inject = ["$scope", "$element", "$attrs"];

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
'use strict';


    angular.module('enspire.ui.components.nav').directive('enNav', NavDirective);


    /**
     * @ngdoc directive
     * @name enNav
     * @module enspire.ui.components.nav
     * @restrict E
     * @description
     * `en-nav` creates a customizable app navigation structure.
     *
     * @element en-nav
     *
     * @param {string=} [position=left] Positions the `<en-nav>` element, relative to the `<en-win>`. Currently, options are **left | top | offside | collapsed**.
     *
     * @usage
     * <hljs lang="html">
     *   <en-nav position="top">
     *   </en-nav>
     * </hljs>
     */
    function NavDirective() {
        return {
            restrict    : 'E',
            controller  : 'enNavController',
            link        : postLink
        };

        function postLink($scope, $element, $attrs, $navCtrl){
            var position = $navCtrl.getPosition($attrs.position);
            $element.addClass('en-nav '+position);
        }
    }

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2014-2015 Alexander Wendland
 *
 * This code has been modified and altered from the original code authored
 * by Alexander Wendland.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

(function(){
    'use strict';

    /**
     * @ngdoc module
     * @name enspire.ui.components.objectTree
     * @description
     * `objectTree` module.
     *
     */

    angular.module('enspire.ui.components.objectTree', [])
        .run(["$templateCache", function($templateCache){
            $templateCache.put('enObjTree/jsonTree', '<en-json-obj-tree key="\'Object\'" value="object" start-expanded="startExpanded()"></en-json-obj-tree>');

            $templateCache.put('enObjTree/jsonNode',
                '<span class="key" en-tap="toggleExpanded()">{{key}}</span>' +
                '<span class="leaf-value" ng-if="!isExpandable">{{value}}</span>' +
                '<span class="branch-preview" ng-if="isExpandable" ng-show="!isExpanded" en-tap="toggleExpanded()">{{preview}}</span>' +
                '<ul class="branch-value" ng-if="isExpandable && shouldRender" ng-show="isExpanded">' +
                '    <li ng-repeat="(subkey,subval) in value track by subkey" class="branch-handle">' +
                '        <en-json-obj-tree key="subkey" value="subval"></en-json-obj-tree>' +
                '    </li>' +
                '</ul>'
            );
        }]);
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    /**
     * @ngdoc directive
     * @name enObjectTree
     * @module enspire.ui.components.objectTree
     *
     * @description
     * Object tree.
     *
     * @param {object} [object] The JSON object to parse.
     * @param {boolean=} [startExpanded=false] Whether or not to expand the tree during inital load.
     *
     ** @usage
     * ### Basic Example
     * <hljs lang="html">
     *   <en-obj-tree object="someObject"></en-obj-tree>
     * </hljs>
     */

    angular.module('enspire.ui.components.objectTree').directive('enObjTree', ComponentDirective);

    function ComponentDirective($parse) {
        return {
            restrict: 'E',
            scope: {
                object: '=',
                startExpanded: '&?'

            },
            templateUrl: 'enObjTree/jsonTree'
        };
    }
    ComponentDirective.$inject = ["$parse"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.objectTree').factory('enObjTreeParser', ComponentFactory);

    function ComponentFactory( $compile ) {
        return {
            /**
             * Manually compiles the element, fixing the recursion loop.
             * @param element
             * @param [link] A post-link function, or an object with function(s) registered via pre and post properties.
             * @returns An object containing the linking functions.
             */
            compile: function (element, link) {
                // Normalize the link parameter
                if (angular.isFunction(link)) {
                    link = {
                        post: link
                    };
                }

                // Break the recursion loop by removing the contents
                var contents = element.contents().remove();
                var compiledContents;
                return {
                    pre: (link && link.pre) ? link.pre : null,
                    /**
                     * Compiles and re-adds the contents
                     */
                    post: function (scope, element) {
                        // Compile the contents
                        if (!compiledContents) {
                            compiledContents = $compile(contents);
                        }
                        // Re-add the compiled contents to the element
                        compiledContents(scope, function (clone) {
                            element.append(clone);
                        });

                        // Call the post-linking function, if any
                        if (link && link.post) {
                            link.post.apply(null, arguments);
                        }
                    }
                };
            }
        }
    }
    ComponentFactory.$inject = ["$compile"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.objectTree').directive('enJsonObjTree', ComponentDirective);

    function ComponentDirective(enObjTreeParser, $timeout) {
        var utils = {
            /* See link for possible type values to check against.
             * http://stackoverflow.com/questions/4622952/json-object-containing-array
             *
             * Value               Class      Type
             * -------------------------------------
             * "foo"               String     string
             * new String("foo")   String     object
             * 1.2                 Number     number
             * new Number(1.2)     Number     object
             * true                Boolean    boolean
             * new Boolean(true)   Boolean    object
             * new Date()          Date       object
             * new Error()         Error      object
             * [1,2,3]             Array      object
             * new Array(1, 2, 3)  Array      object
             * new Function("")    Function   function
             * /abc/g              RegExp     object (function in Nitro/V8)
             * new RegExp("meow")  RegExp     object (function in Nitro/V8)
             * {}                  Object     object
             * new Object()        Object     object
             */
            is: function is(obj, clazz) {
                return Object.prototype.toString.call(obj).slice(8, -1) === clazz;
            },

            // See above for possible values
            whatClass: function whatClass(obj) {
                return Object.prototype.toString.call(obj).slice(8, -1);
            },

            // Iterate over an objects keyset
            forKeys: function forKeys(obj, f) {
                for (var key in obj) {
                    if (obj.hasOwnProperty(key) && typeof obj[key] !== 'function') {
                        if (f(key, obj[key])) {
                            break;
                        }
                    }
                }
            }
        };


        return {
            restrict: 'E',
            scope: {
                key: '=',
                value: '=',
                startExpanded: '&?'
            },
            require: '?^enObjTree',
            compile: function(element, attrs) {
                // Compile the JSON tree node
                return enObjTreeParser.compile(element, this);
            },
            templateUrl: 'enObjTree/jsonNode',
            pre: function(scope, element, attrs, ctrl) {

                // Set value's type as Class for CSS styling
                element.addClass(utils.whatClass(scope.value).toLowerCase());

                // If the value is an Array or Object, use expandable view type
                if (utils.is(scope.value, 'Object') || utils.is(scope.value, 'Array')) {
                    scope.isExpandable = true;

                    // Add expandable class for CSS usage
                    element.addClass('expandable');

                    // Setup preview text
                    var isArray = utils.is(scope.value, 'Array');
                    scope.preview = isArray ? '[ ' : '{ ';
                    utils.forKeys(scope.value, function(key, value) {
                        if (isArray) {
                            scope.preview += value + ', ';
                        } else {
                            scope.preview += key + ': ' + value + ', ';
                        }
                    });

                    scope.preview = scope.preview.substring(0, scope.preview.length - (scope.preview.length > 2 ? 2 : 0)) + (isArray ? ' ]' : ' }');
                    // If directive initially has isExpanded set, also set shouldRender to true
                    if (scope.startExpanded && scope.startExpanded()) {
                        scope.shouldRender = true;
                        element.addClass('expanded');
                    }

                    // Setup isExpanded state handling
                    scope.isExpanded = scope.startExpanded ? scope.startExpanded() : false;
                    scope.toggleExpanded = function() {
                        scope.isExpanded = !scope.isExpanded;
                        if (scope.isExpanded) {
                            element.addClass('expanded');
                        } else {
                            element.removeClass('expanded');
                        }
                        // For delaying subnode render until requested
                        scope.shouldRender = true;
                    };

                } else {
                    scope.isExpandable = false;
                    // Add expandable class for CSS usage
                    element.addClass('not-expandable');
                }
            }
        }
    }
    ComponentDirective.$inject = ["enObjTreeParser", "$timeout"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * deep-diff.
 * Licensed under the MIT License.
 *
 * Note: Modifed from original source to fit specific needs.
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.objectDiff')
        .provider('enObjectDiffEngine', ComponentService);

    function ComponentService() {
        var self = this;

        self.$get = function() {
            function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            }

            function Diff(kind, path) {
                Object.defineProperty(this, 'kind', {
                    value: kind,
                    enumerable: true
                });
                if (path && path.length) {
                    Object.defineProperty(this, 'path', {
                        value: path,
                        enumerable: true
                    });
                }
            }

            function DiffEdit(path, origin, value) {
                DiffEdit.super_.call(this, 'E', path);
                Object.defineProperty(this, 'lhs', {
                    value: origin,
                    enumerable: true
                });
                Object.defineProperty(this, 'rhs', {
                    value: value,
                    enumerable: true
                });
            }
            inherits(DiffEdit, Diff);

            function DiffNew(path, value) {
                DiffNew.super_.call(this, 'N', path);
                Object.defineProperty(this, 'rhs', {
                    value: value,
                    enumerable: true
                });
            }
            inherits(DiffNew, Diff);

            function DiffDeleted(path, value) {
                DiffDeleted.super_.call(this, 'D', path);
                Object.defineProperty(this, 'lhs', {
                    value: value,
                    enumerable: true
                });
            }
            inherits(DiffDeleted, Diff);

            function DiffArray(path, index, item) {
                DiffArray.super_.call(this, 'A', path);
                Object.defineProperty(this, 'index', {
                    value: index,
                    enumerable: true
                });
                Object.defineProperty(this, 'item', {
                    value: item,
                    enumerable: true
                });
            }
            inherits(DiffArray, Diff);

            function arrayRemove(arr, from, to) {
                var rest = arr.slice((to || from) + 1 || arr.length);
                arr.length = from < 0 ? arr.length + from : from;
                arr.push.apply(arr, rest);
                return arr;
            }

            function realTypeOf(subject) {
                var type = typeof subject;
                if (type !== 'object') {
                    return type;
                }

                if (subject === Math) {
                    return 'math';
                } else if (subject === null) {
                    return 'null';
                } else if (Array.isArray(subject)) {
                    return 'array';
                } else if (subject instanceof Date) {
                    return 'date';
                } else if (/^\/.*\//.test(subject.toString())) {
                    return 'regexp';
                }
                return 'object';
            }

            function deepDiff(lhs, rhs, changes, prefilter, path, key, stack) {
                path = path || [];
                var currentPath = path.slice(0);
                if (typeof key !== 'undefined') {
                    if (prefilter) {
                        var prefilterResult = prefilter(currentPath, key, {
                            lhs: lhs,
                            rhs: rhs
                        });
                        if (prefilterResult) {
                            // Just pass along as new
                            currentPath.push(key);
                            changes(new DiffNew(currentPath, rhs));
                            return;
                        } else if (prefilterResult === -1) {
                            // Do not filter
                            return;
                        }
                        // Otherwise continue filtering
                    }
                    currentPath.push(key);
                }
                var ltype = typeof lhs;
                var rtype = typeof rhs;
                if (ltype === 'undefined') {
                    if (rtype !== 'undefined') {
                        changes(new DiffNew(currentPath, rhs));
                    }
                } else if (rtype === 'undefined') {
                    changes(new DiffDeleted(currentPath, lhs));
                } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {
                    changes(new DiffEdit(currentPath, lhs, rhs));
                } else if (lhs instanceof Date && rhs instanceof Date && ((lhs - rhs) !== 0)) {
                    changes(new DiffEdit(currentPath, lhs, rhs));
                } else if (ltype === 'object' && lhs !== null && rhs !== null) {
                    stack = stack || [];
                    if (stack.indexOf(lhs) < 0) {
                        stack.push(lhs);
                        if (Array.isArray(lhs)) {
                            var i, len = lhs.length;
                            for (i = 0; i < lhs.length; i++) {
                                if (i >= rhs.length) {
                                    changes(new DiffArray(currentPath, i, new DiffDeleted(undefined, lhs[i])));
                                } else {
                                    deepDiff(lhs[i], rhs[i], changes, prefilter, currentPath, i, stack);
                                }
                            }
                            while (i < rhs.length) {
                                changes(new DiffArray(currentPath, i, new DiffNew(undefined, rhs[i++])));
                            }
                        } else {
                            var akeys = Object.keys(lhs);
                            var pkeys = Object.keys(rhs);
                            akeys.forEach(function(k, i) {
                                var other = pkeys.indexOf(k);
                                if (other >= 0) {
                                    deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack);
                                    pkeys = arrayRemove(pkeys, other);
                                } else {
                                    deepDiff(lhs[k], undefined, changes, prefilter, currentPath, k, stack);
                                }
                            });
                            pkeys.forEach(function(k) {
                                deepDiff(undefined, rhs[k], changes, prefilter, currentPath, k, stack);
                            });
                        }
                        stack.length = stack.length - 1;
                    }
                } else if (lhs !== rhs) {
                    if (!(ltype === "number" && isNaN(lhs) && isNaN(rhs))) {
                        changes(new DiffEdit(currentPath, lhs, rhs));
                    }
                }
            }

            function accumulateDiff(lhs, rhs, prefilter, accum) {
                accum = accum || [];
                deepDiff(lhs, rhs,
                    function(diff) {
                        if (diff) {
                            accum.push(diff);
                        }
                    },
                    prefilter);
                return (accum.length) ? accum : undefined;
            }

            function applyArrayChange(arr, index, change) {
                if (change.path && change.path.length) {
                    var it = arr[index],
                        i, u = change.path.length - 1;
                    for (i = 0; i < u; i++) {
                        it = it[change.path[i]];
                    }
                    switch (change.kind) {
                        case 'A':
                            applyArrayChange(it[change.path[i]], change.index, change.item);
                            break;
                        case 'D':
                            delete it[change.path[i]];
                            break;
                        case 'E':
                        case 'N':
                            it[change.path[i]] = change.rhs;
                            break;
                    }
                } else {
                    switch (change.kind) {
                        case 'A':
                            applyArrayChange(arr[index], change.index, change.item);
                            break;
                        case 'D':
                            arr = arrayRemove(arr, index);
                            break;
                        case 'E':
                        case 'N':
                            arr[index] = change.rhs;
                            break;
                    }
                }
                return arr;
            }

            function applyChange(target, source, change) {
                if (target && source && change && change.kind) {
                    var it = target,
                        i = -1,
                        last = change.path.length - 1;
                    while (++i < last) {
                        if (typeof it[change.path[i]] === 'undefined') {
                            it[change.path[i]] = (typeof change.path[i] === 'number') ? [] : {};
                        }
                        it = it[change.path[i]];
                    }
                    switch (change.kind) {
                        case 'A':
                            applyArrayChange(it[change.path[i]], change.index, change.item);
                            break;
                        case 'D':
                            delete it[change.path[i]];
                            break;
                        case 'E':
                        case 'N':
                            it[change.path[i]] = change.rhs;
                            break;
                    }
                }
            }

            function revertArrayChange(arr, index, change) {
                if (change.path && change.path.length) {
                    // the structure of the object at the index has changed...
                    var it = arr[index],
                        i, u = change.path.length - 1;
                    for (i = 0; i < u; i++) {
                        it = it[change.path[i]];
                    }
                    switch (change.kind) {
                        case 'A':
                            revertArrayChange(it[change.path[i]], change.index, change.item);
                            break;
                        case 'D':
                            it[change.path[i]] = change.lhs;
                            break;
                        case 'E':
                            it[change.path[i]] = change.lhs;
                            break;
                        case 'N':
                            delete it[change.path[i]];
                            break;
                    }
                } else {
                    // the array item is different...
                    switch (change.kind) {
                        case 'A':
                            revertArrayChange(arr[index], change.index, change.item);
                            break;
                        case 'D':
                            arr[index] = change.lhs;
                            break;
                        case 'E':
                            arr[index] = change.lhs;
                            break;
                        case 'N':
                            arr = arrayRemove(arr, index);
                            break;
                    }
                }
                return arr;
            }

            function revertChange(target, source, change) {
                if (target && source && change && change.kind) {
                    var it = target,
                        i, u;
                    u = change.path.length - 1;
                    for (i = 0; i < u; i++) {
                        if (typeof it[change.path[i]] === 'undefined') {
                            it[change.path[i]] = {};
                        }
                        it = it[change.path[i]];
                    }
                    switch (change.kind) {
                        case 'A':
                            // Array was modified...
                            // it will be an array...
                            revertArrayChange(it[change.path[i]], change.index, change.item);
                            break;
                        case 'D':
                            // Item was deleted...
                            it[change.path[i]] = change.lhs;
                            break;
                        case 'E':
                            // Item was edited...
                            it[change.path[i]] = change.lhs;
                            break;
                        case 'N':
                            // Item is new...
                            delete it[change.path[i]];
                            break;
                    }
                }
            }

            function applyDiff(target, source, filter) {
                if (target && source) {
                    var onChange = function(change) {
                        if (!filter || filter(target, source, change)) {
                            applyChange(target, source, change);
                        }
                    };
                    deepDiff(target, source, onChange);
                }
            }

            Object.defineProperties(accumulateDiff, {

                diff: {
                    value: accumulateDiff,
                    enumerable: true
                },
                observableDiff: {
                    value: deepDiff,
                    enumerable: true
                },
                applyDiff: {
                    value: applyDiff,
                    enumerable: true
                },
                applyChange: {
                    value: applyChange,
                    enumerable: true
                },
                revertChange: {
                    value: revertChange,
                    enumerable: true
                },
                isConflict: {
                    value: function() {
                        return 'undefined' !== typeof conflict;
                    },
                    enumerable: true
                },
                noConflict: {
                    value: function() {
                        if (conflictResolution) {
                            conflictResolution.forEach(function(it) {
                                it();
                            });
                            conflictResolution = null;
                        }
                        return accumulateDiff;
                    },
                    enumerable: true
                }
            });

            return accumulateDiff;

        }

    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */

(function() {
    'use strict';

    angular.module('enspire.ui.components.objectDiff').provider('enObjectDiff', ComponentService);

    /**
     * @ngdoc service
     * @name enObjectDiff
     * @module enspire.ui.components.objectDiff
     *
     * @description
     * A diff function that calculates the difference between two objects and returns only changed items and newly added items.
     *
     * @param {obect} [leftObj] The left-hand operand; the origin object.
     * @param {obect} [rightObj] The right-hand operand; the object being compared structurally with the origin object.
     * @param {obect=} [filters] Optional pre-filters to run on whether to process a path.
     */

    function ComponentService() {
        var self = this;

        self.$get = ["enObjectDiffEngine", function(enObjectDiffEngine) {

            /**
             * A diff function calculates the difference between two objects
             * and returns only changed items and new items.
             *
             * @params {Object} config
             *      leftObj  - the left-hand operand; the origin object
             *      rightObj - the right-hand operand; the object being compared structurally with the origin object.
             *      filters  - Optional prefilters to run on whether to process a path
             */
            var ObjectDiff = function(config) {
                return this.process(config);
            };

            ObjectDiff.prototype = {
                /**
                 * Optional prefilters to run on whether to process a path normally
                 * with diff, automatically add or reject.
                 *
                 * @params {Array} filterList - List of prefilters to check against
                 * The function needs to return
                 *          truthy : To not filter and pass along in output.
                 *          -1     : Do not filter and do not pass along in output.
                 *          falsey : Continue to filter. Note falsey and undefined is treated
                 *                   as same in JavaScript.
                 */
                prefilter: function(path, key, objValues, filters) {
                    var me = this,
                        action;

                    filters.some(function(func) {
                        action = func.filter.apply(null, [path, key, objValues]);
                        if (action !== undefined) return true;
                    });

                    return action;
                },

                /**
                 * Process the object diff.
                 */
                process: function(config) {
                    var me = this,
                        DELETE_FLAG = 'D',
                        output = {},
                        rawOutput,
                        args;

                    function filter(path, key, objValues) {
                        var filters = me.filters || [];
                        return me.prefilter(path, key, objValues, filters);
                    }

                    // Get config options
                    me.leftObj = config.leftObj;
                    me.rightObj = config.rightObj;
                    me.filters = config.filters;

                    // Default basic parameters
                    args = [me.leftObj, me.rightObj];

                    // Apply a prefilter?
                    if (me.filters) args.push(filter);

                    // Get annotated version of diffs
                    rawOutput = enObjectDiffEngine.diff.apply(null, args);

                    // Process raw output
                    if(typeof rawOutput !== 'undefined'){
                        rawOutput.forEach(function(change){
                            // Process everything but deleted items
                            if (change.kind !== DELETE_FLAG) {
                                var obj = output,
                                    pathLen = change.path.length - 1;

                                // Walk threw raw output and build out structure of what's changed or added.
                                change.path.forEach(function(key, index, array){
                                    if (obj[key]) {
                                        obj = obj[key];
                                    } else if (index < pathLen) {
                                        obj = obj[key] = {};
                                    } else {
                                        obj[key] = change.rhs;
                                    }
                                });
                            }
                        });
                    }

                    return output;
                }
            };

            return ObjectDiff;
        }];

    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';

    angular.module('enspire.ui.components.panel')
        .controller('enPanelController', PanelController)

    /*
     * @private
     * @ngdoc controller
     * @name PanelController
     * @module enspire.ui.components.panel
     *
     */
    function PanelController($scope, $element, $attrs) {
        var self = this;
        self.$panel             = $element;
        self.isCollapsible      = angular.isDefined($attrs.collapsible);
        self.collapsed          = angular.isDefined($attrs.collapsed);
        self.collapseTrigger    = null;
        self.collapseIcon       = null;
        self.destroy            = destroyScope;
        

        self.makeCollapsible = function(){
            self.isCollapsible = true;
            self.hammertime = new Hammer(self.collapseTrigger[0]);
            self.hammertime.on('tap', self.togglePanelCollapse);
        };
        
        self.togglePanelCollapse = function(){
            self.collapsed = !self.collapsed;
            self.$panel[self.collapsed ? 'addClass':'removeClass']('collapsed');
            self.collapseIcon.attr('icon', self.collapsed ? 'chevron-right':'chevron-down');
        };
        
        $element.on('$destroy', destroyScope);

        function destroyScope(){
            if(angular.isDefined(self.hammertime)){ self.hammertime.destroy(); }
        }

    }
    PanelController.$inject = ["$scope", "$element", "$attrs"];

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.panel').directive('enPanel', PanelDirective);


    /**
     * @ngdoc directive
     * @name enPanel
     * @module enspire.ui.components.panel
     * @restrict E
     * @description
     * `en-panel` creates a styled boxed in container structure.
     *
     * @element en-panel
     *
     * @param {boolean=} [collapsible=false] Adding the collapsible attribute will force the panel to
     * display in a collapsed state if `collapsible="true"`.
     *
     * @param {string=} theme Name of the css theme that will be applied to the `<en-panel>`.
     *
     * @usage
     * <hljs lang="html">
     *   <en-panel collapsible="false" collapsed="true">
     *       <en-header></en-header>
     *       <en-subheader></en-subheader>
     *       <en-body></en-body>
     *       <en-footer></en-footer>
     *   </en-panel>
     * </hljs>
     *
     */
    function PanelDirective(){
        return {
            restrict  : 'E',
            controller: 'enPanelController',
            link      : postLink
        };

        function postLink($scope, $element, $attrs, $panelCtrl){
            //var classNames = ['en-panel'];
            var classNames = [];
            if(angular.isDefined($attrs.theme)){    classNames.push($attrs.theme);  }
            if(angular.isDefined($attrs.type)) {    classNames.push($attrs.type);   }

            //Apply all found classNames to the panel element.
            $element.addClass(classNames.join(' '));
            $element.on('$destroy', $panelCtrl.destroy);
        }
    }

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.passwordCheck').directive('enPasswordCheck', ComponentDirective);

    /**
     * @ngdoc directive
     * @name enPasswordCheck
     * @module enspire.ui.components.passwordCheck
     * @restrict A
     * @description
     * Confirms two passwords match.
     *
     * @usage
     * ### Basic Example
     * <hljs lang="html">
     *   <input type="password" ng-model="password01" />
     *   <input type="password" ng-model="password02" en-password-check="password01" />
     * </hljs>
     */

    function ComponentDirective($parse, $timeout) {
        return {
            restrict: 'A',
            scope: {
                compareTo: "=enPasswordCheck"
            },
            require: 'ngModel',
            link: function($scope, $element, $attrs, ngModel) {
                var offWatch;

                ngModel.$validators.enPasswordCheck = function( modelValue ) {
                    return modelValue == $scope.compareTo;
                };

                offWatch = $scope.$watch( "compareTo", function(newVal, oldVal) {
                    ngModel.$validate();
                });

                $scope.$on('$destroy', function(){
                    offWatch();
                });
            }
        }
    }
    ComponentDirective.$inject = ["$parse", "$timeout"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.popover')
    .controller('enPopoverController', PopoverController);
    
    /*
     * @private
     * @ngdoc function
     * @name PopoverController
     * @module enspire.ui.components.popover
     */
    function PopoverController($scope, $element, $attrs) {
        var self = this;

    }
    PopoverController.$inject = ["$scope", "$element", "$attrs"];
    
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.popover').directive('enPopover', PopoverDirective);

    /**
     * @ngdoc directive
     * @name enPopover
     * @module enspire.ui.components.popover
     * @restrict A
     * @description
     * Adds a small overlay of content on tap to any element for housing secondary information.
     *
     *
     * @usage
     * ### As Popover
     * <hljs lang="html">
     *   <en-icon icon="help" en-popover popover-title="My Title" popover-content="Hello World!"></en-icon>
     * </hljs>
     *
     *
     * ## Default Options
     * You can override global defaults for the plugin with $enPopoverProvider.defaults
     * <hljs lang="js">
     *     angular.module('myApp')
     *     .config(function($enPopoverProvider) {
     *          angular.extend($enPopoverProvider.defaults, {
     *              animation: 'am-flip-x',
     *              trigger: 'hover'
     *          });
     *     })
     * </hljs>
     *
     * ## Options
     * Options can be passed via popover-attributes on the directive or as an object hash to configure the service. For data attributes, append the option name to `popover-`, as in `popover-placement="right"`.
     * **NOTE**: For the service passing values using camelCase. For the directive use snake-case. Values below are in camel case, convert to snake case for use in directive.
     *
     *
     * For directives, you can naturally inherit the contextual $scope or leverage a custom one with an AngularJS expression to evaluate as an object directly on the `en-popover` attribute.
     *
     * Name      | Type     | Default | Description
     * ----------|----------| --------|------------
     * animation | *string* |  | apply a CSS animation powered by `ngAnimate` See http://mgcrea.github.io/angular-motion/ for more documentation. To have it fade in use **'am-fade'**
     * customClass | *string* |  | apply a custom class name to your tooltip. Example: `tooltip-custom-class="classname"`
     * placement | *string* | 'auto'  | how to position the popover - *top* &#124; *bottom* &#124; *left* &#124; *right* &#124; *auto*, or any combination like *bottom-left* or *auto bottom-left*. When *"auto"* is specified, it will dynamically reorient the popover. For example, if placement is *"auto left"*, the popover will display to the left when possible, otherwise it will display right.
     * trigger   | *string* | 'click' | how popover is triggered - *click* &#124; *hover* &#124; *focus* &#124; *manual*
     * title     | *string* | ''      | default `title` value if `title` attribute isn't present
     * html      | *boolean*  | *false*   | replace `ng-bind` with `ng-bind-html`, requires `ngSanitize` to be loaded
     * delay     | *number* &#124; *object* | 0 | delay showing and hiding the popover (ms) - does not apply to manual trigger type <br><br> If a number is supplied, delay is applied to both hide/show <br><br> Object structure is: `delay: { show: 500, hide: 100 }`
     * container | *string* &#124; *false* | *false* | Appends the popover to a specific element. Example: `container: 'body'`. This option is particularly useful in that it allows you to position the popover in the flow of the document near the triggering element - which will prevent the popover from floating away from the triggering element during a window resize.
     * target    | *string* &#124; DOMElement &#124; *false* | *false* | Position the tooltip relative to a specific target element.
     * template  | path     | *false* | If provided, overrides the default template, can be either a remote URL or a cached template id.
     * contentTemplate | path | *false* | If provided, fetches the partial and includes it as the inner content, can be either a remote URL or a cached template id.
     * autoClose | *boolean* | *false* | If provided, auto closes the tooltip when clicking outside of it.
     * id        | *string*  | ''      | The popover instance id for usage in event handlers.
     * isolatedScope | *boolean* | *false* | If set will create an isolated scope for popover.
     * inlineTemplate | *boolean* | *false* | Set to true if you want to include ng-repeat, additional directives or just rather inline the conent template and not use `contentTemplate` url option. Only applies to content template. Use `template` to override template structure.
     * **viewport** | *string* &#124; *object* | `{ selector: 'body', padding: 0 }` | *If your popover is getting cut-off set this attribute. Use id or class of parent container. <br><br> Keeps the popover within the bounds of this element. Example: `popover-viewport: 'querySelector'` or `popover-viewport: { "selector": "querySelector", "padding": 20 }`. Types of query selectors: `#elementId`, `.elementClass`, `elementTagName`
     * data | *object* | | Adds key-values from object to the scope. Used to pass extra data to custom templates. Example: `popover-data="{'foo':'bar','version': '1.0'}"`
     *
     *
     * ##Events
     *
     * Use $scope.$on() to listen for the event. Even though this is popover it is merely an extension of tooltip.
     *
     * ### **tooltip.show.before**
     * Triggers before the tooltip is about to show.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object, DOM Element is not present.
     *
     * ### **tooltip.show**
     * Triggers when the tooltip is shown.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object, DOM Element is present.
     *
     * ### **tooltip.hide.before**
     * Triggers before the tooltip is hidden.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object, DOM Element is present.
     *
     * ### **tooltip.hide**
     * Triggers when the tooltip is hidden.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object.
     *
     *
     */

    function PopoverDirective($window, $sce, $enPopover, $parse) {
        var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;

        return {
            restrict: 'A',
            scope: true,
            compile: function(element, attrs) {
                var compileVars = {
                        title: String(attrs.popoverTitle || ''),
                        content: String(attrs.popoverContent || '')
                    };

                attrs.popoverTitle = '';
                attrs.popoverContent = '';


                return function postLink ($scope, $element, $attrs) {

                    // Directive options
                    var options = {},
                        availableOptions = [
                            'template',
                            'contentTemplate',
                            'placement',
                            'container',
                            'target',
                            'delay',
                            'trigger',
                            'keyboard',
                            'html',
                            'animation',
                            'customClass',
                            'autoClose',
                            'id',
                            'inlineTemplate',
                            'isolatedScope'
                        ];

                    // Normalize attr names, convert tooltip-* into data-*
                    function normalizeAttrs() {
                        var key, newKey;
                        for (key in $attrs) {
                            if (String(key).indexOf('popover') === 0) {
                                newKey = key.replace('popover','');
                                newKey = newKey.substr(0, 1).toLowerCase() + newKey.substr(1);
                                options[newKey] = $attrs[key];
                            }
                        }
                    }

                    options.data = $parse($attrs.popoverData)() || {};
                    options.scope = $scope;

                    angular.forEach(availableOptions, function(key) {
                        if (angular.isDefined($attrs[key])){
                            options[key] = $attrs[key];
                        }
                    });

                    normalizeAttrs();

                    options.delay = $scope.$eval(options.delay);

                    // Default to auto placement
                    if (!options.placement) {
                        options.placement = 'auto';
                    }


                    // Support scope as data-attrs
                    angular.forEach(['popoverTitle', 'popoverContent'], function(key) {
                        var newKey = key.replace('popover','').toLowerCase();
                        ($attrs[key] !== undefined) && $attrs.$observe(key, function(newValue, oldValue) {
                            if (newValue !== '') {
                                $scope[newKey] = options[newKey] = $sce.trustAsHtml(newValue);
                            }

                            angular.isDefined(oldValue) && requestAnimationFrame(function() {
                                popover && popover.$applyPlacement();
                            });
                        });

                        if (compileVars[newKey] && $attrs[key] === '') {
                            $scope[newKey] = options[newKey] = $sce.trustAsHtml(compileVars[newKey]);

                        }
                    });

                    // Support scope as an object
                    $attrs.enPopover && $scope.$watch($attrs.enPopover, function(newValue, oldValue) {
                        if (angular.isObject(newValue)) {
                            angular.extend($scope, newValue);
                        } else {
                            $scope.content = newValue;
                        }
                        $scope.title   = ($scope.title)   ? $sce.trustAsHtml(String($scope.title))   : undefined;
                        $scope.content = ($scope.content) ? $sce.trustAsHtml(String($scope.content)) : undefined;

                        angular.isDefined(oldValue) && requestAnimationFrame(function() {
                            popover && popover.$applyPlacement();
                        });
                    }, true);

                    // Visibility binding support
                    $attrs.enShow && $scope.$watch($attrs.popoverEnShow, function(newValue, oldValue) {
                        if (!popover || !angular.isDefined(newValue)) return;
                        if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);
                        newValue === true ? popover.show() : popover.hide();
                    });

                    // Viewport support
                    $attrs.viewport && $scope.$watch($attrs.popoverViewport, function(newValue) {
                        if (!popover || !angular.isDefined(newValue)) return;
                        popover.setViewport(newValue);
                    });

                    // Initialize popover
                    var popover = $enPopover($element, options);

                    // Garbage collection
                    $scope.$on('$destroy', function() {
                        if (popover) popover.destroy();
                        options = null;
                        popover = null;
                    });
                }
            }
        };
    }
    PopoverDirective.$inject = ["$window", "$sce", "$enPopover", "$parse"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.popover')
        .provider('$enPopover', PopoverService);


    /**
     * @ngdoc service
     * @name $enPopover
     * @module enspire.ui.components.popover
     *
     * @usage
     * <hljs lang="js">
     * var myPopover = $enPopover(element, {title: 'My Title', content: 'My Content'});
     * </hljs>
     *
     * * ## Scope methods
     * - **$show()** - Reveals the popover.
     * - **$hide()** - Hides the popover.
     * - **$toggle()** - Toggles the popover.
     *
     *
     * ##Events
     *
     * Use $scope.$on() to listen for the event. Even though this is popover it is merely an extension of tooltip.
     *
     * ### **tooltip.show.before**
     * Triggers before the tooltip is about to show.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object, DOM Element is not present.
     *
     * ### **tooltip.show**
     * Triggers when the tooltip is shown.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object, DOM Element is present.
     *
     * ### **tooltip.hide.before**
     * Triggers before the tooltip is hidden.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object, DOM Element is present.
     *
     * ### **tooltip.hide**
     * Triggers when the tooltip is hidden.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object.
     */


    function PopoverService() {
        var self = this;

        var defaults = this.defaults = {
            animation: '',
            customClass: '',
            container: false,
            target: false,
            placement: 'right',
            template: 'popover/popover.tpl.html',
            contentTemplate: false,
            trigger: 'click',
            keyboard: true,
            html: false,
            title: '',
            content: '',
            delay: 0,
            autoClose: false
        };

        self.$get = ["$enTooltip", "$sce", function($enTooltip, $sce) {

            function PopoverFactory(element, config) {

                // Common vars
                var options = angular.extend({}, defaults, config);

                var $popover = $enTooltip(element, options);

                return $popover;

            }

            return PopoverFactory;
        }];
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.progress').directive('enProgress', ComponentDirective);

    /**
     * @ngdoc directive
     * @name enProgress
     * @module enspire.ui.components.progress
     * @restrict E
     * @description
     * Progress bar.
     *
     * @param {boolean=} [animate=true] Boolean or expression indicating whether the progress bar should animate.
     *                                   Works only on striped progress bars.
     *
     * @param {string=} [class=  ] Optional classes to pass along to the element.
     *
     * @param {string=} [label=  ] Optional label. If specified a label is shown for progress bar.
     *
     * @param {number=} [min=0] Minimum value of progress bar.
     *
     * @param {number=} [max=100] Maximum value of progress bar.
     *
     * @param {boolean=} [striped=false] Uses a gradient to create a striped effect.
     *
     * @param {string=} [type=  ] Keys off the class name. Type of progress to show: info, warn, success, danger.
     *
     * @param {number=} [value=0] The value of the progress bar. Progress bar will update when value changes.
     *                            Works the same as ng-model, only difference is you can specify non-assignable
     *                            values here. `Example: value="50"`.
     *
     * @param {object=} [ng-model=  ] The value for the progress bar. Progress bar will update when model changes.
     *
     * @usage
     * ### Basic Example
     * <hljs lang="html">
     *   <en-progress value="25" type="success"></en-progress>
     * </hljs>
     *
     *
     * ### ngModel Example
     * <hljs lang="html">
     *   <en-progress ng-model="myModel" type="success" striped="true" animate="true" label="Complete"></en-progress>
     * </hljs>
     */

    function ComponentDirective($parse, $timeout) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                'animate': '@?',
                'class': '@?',
                'label': '@?',
                'min': '@?',
                'max': '@?',
                'striped': '@?',
                'type': '@?',
                'value': '@?'
            },
            require: '?ngModel',
            templateUrl: 'progress/progress.html',
            link: function(scope, element, attrs, ngModel) {
                var isAnimated = $parse(scope.animate)(scope) == false ? false: true,
                    isStriped = $parse(scope.striped)(scope) || false,
                    label = scope.label || '',
                    value = scope.value || 0,
                    min = scope.min || 0,
                    max = scope.max || 100,
                    cssClass = scope.class || '',
                    offValue,
                    offAnimate;

                // Add type class
                if (scope.type) {
                    cssClass += ' progress-bar-' + scope.type;
                }

                // Striped progressbar?
                if (isStriped) {
                    cssClass += ' progress-bar-striped';
                }

                // ngModel Assigned?
                if (ngModel) {
                    // Assign intial value
                    value = ngModel.$viewValue;

                    // Apply value when model changes
                    ngModel.$render = function(){
                        $timeout(function(){
                            scope.progress.value = ngModel.$viewValue;
                        });
                    }
                }
                // ngModel not assigned, use value attr
                else {
                     offValue = attrs.$observe('value', function(val) {
                        scope.progress.value = $parse(val)(scope);
                    });
                }

                // Allow animation to be toggled
                offAnimate = attrs.$observe('animate', function(val) {
                    if (val === undefined) return;
                    scope.progress.animate = $parse(val)(scope);
                });

                scope.progress = {
                    'min': min,
                    'max': max,
                    'label': label,
                    'value': value,
                    'css': cssClass,
                    'animate': isAnimated
                }


                element.bind('$destroy', function() {
                    offValue && offValue();
                    offAnimate && offAnimate();
                });
            }
        }
    }
    ComponentDirective.$inject = ["$parse", "$timeout"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
'use strict';

    //angular.module('enspire.ui.components.quote').directive('enQuote', QuoteDirective);

    /**
     * @ngdoc directive
     * @name enQuote
     * @module enspire.ui.components.quote
     * @restrict E
     * @element en-quote
     * 
     * @description
     * Produces a styled quote content block.
     *
     * 
     * @usage
     * <hljs lang="html">
     *     <en-quote>
     *       [Content]
     *     </en-quote>
     * </hljs>
     *
     * 
     * ## Color <a name="quoteColor"></a>
     * Change the colors of a `quote` by adding a class attribute and using one of the following classnames.
     * 
     * <en-quote class="">(default)</en-quote> 
     * 
     * <en-quote class="primary">primary</en-quote>  
     * 
     * <en-quote class="secondary">secondary</en-quote>  
     * 
     * <en-quote class="info">info</en-quote>  
     * 
     * <en-quote class="error">error</en-quote>  
     * 
     * <en-quote class="success">success</en-quote>  
     * 
     * <en-quote class="warn">warn</en-quote>  
     * 
     * <hljs lang="html"><en-quote class="[primary|secondary|info|error|success|warn]">quote content...</en-quote></hljs>
     *
     */
    
    //function QuoteDirective($enTouch) {
    //    return {
    //        restrict    : 'E',
    //        link        : postLink
    //    };
    //    
    //    function postLink($scope, $element, $attrs){
    //    
    //    }
    //}

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.screen')
        .directive('enScreen', screenDirective);

    /**
     * @ngdoc directive
     * @name enScreen
     * @module enspire.ui.components.screen
     *
     * @restrict E
     *
     * @description
     * The `<en-screen>` directive...
     *
     */
    function screenDirective() {
        return {
            restrict: 'E'
        };
    }

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.scrollbar').directive('enScrollbar', ['$timeout', ScrollbarDirective]);

    /**
     * @ngdoc directive
     * @name enScrollbar
     * @module enspire.ui.components.scrollbar
     * @restrict A
     * @element en-scrollbar
     * @description
     * `en-scrollbar` is a custom HTML scrollbar.  It will take the content of the container it is applied to and wrap it as needed to produce a scrollable inner container and adds the scrollbar track and bar to the main element.
     *
     * @usage
     *
     * ### Standard Scrollbar
     * <hljs lang="html">
     *  <div en-scrollbar>
     *
     *  </div>
     * </hljs>
     *
     *
     */

    function ScrollbarDirective($timeout){
        var SCROLLBAR_WIDTH = scrollbarWidth();

        return {
            restrict    : 'A',
            link        : postLink
        };

        function postLink($scope, $element, $attrs){
            var $trackY,
                $trackX,
                $barY,
                $barX,
                $contentWrapper    = $element,
                $contentScroller   = $element,
                flashTimeout,
                dragOffset,
                collHdr;

            var options = {
                direction   : $attrs.enScrollbar || 'both',
                wrapContent : $attrs.wrapContent || true,
                autoHide    : $attrs.autoHide || true,
                flexible    : $attrs.hasOwnProperty('flex')
            };

            function wrapContents(){
                var contents         = $element.contents();
                    $contentWrapper  = angular.element('<div class="en-scrollbar-content-wrapper"></div>');
                    $contentScroller = angular.element('<div class="en-scrollbar-content"></div>');

                    if(!options.flexible){
                        $contentScroller.css('position','relative');
                    }

                    $element.append($contentScroller.append($contentWrapper.append(contents)));
            }

            function init(){
                // If scrollbar is a floating scrollbar, disable the directive for $element
                if(SCROLLBAR_WIDTH === 0) {
                  $element.css('overflow', 'auto');
                  return;
                }

                if(options.wrapContent) {
                    wrapContents();
                }

                $trackY = angular.element('<div class="en-scrollbar-track"></div>');
                $barY   = angular.element('<div class="en-scrollbar-bar"></div>');
                $element.prepend($trackY.prepend($barY));

                $trackX = angular.element('<div class="en-scrollbar-track horizontal"></div>');
                $barX   = angular.element('<div class="en-scrollbar-bar"></div>');
                $element.prepend($trackX.prepend($barX));

                if($element.hasClass('en-collection-body')){
                   //console.log('isCollection Body');
                    var collId = $element[0].id.replace(/_collectionBody/gi, '');
                   collHdr = document.getElementById(collId+'_collectionHeader');
                   if(collHdr){
                       collHdr = angular.element(collHdr.querySelector('div'));
                   }
                }

                resizeScrollContent();

                resizeScrollbar();

                registerBarDrag('Y');
                registerBarDrag('X');

                $contentScroller.on('scroll', function(){
                        resizeScrollbar();
                        flashScrollbar();
                    });

                if(options.autoHide) {
                    $element.on('mouseenter', function(){
                        resizeScrollbar();
                        flashScrollbar();
                    });
                } else {
                    showScrollbar();
                }
            }

            function resizeScrollContent() {
                var isFirefox = /firefox/i.test(navigator.userAgent);
                if (!isFirefox){ return; }
                $contentScroller[0].style.width  = ($element[0].offsetWidth + SCROLLBAR_WIDTH)+'px';
                $contentScroller[0].style.height = ($element[0].offsetHeight + SCROLLBAR_WIDTH)+'px';
            }

            function resizeScrollbar() {
                if(SCROLLBAR_WIDTH === 0) {
                    return;
                }

                //resizeScrollContent();

                var trackH          = $trackY[0].offsetHeight,
                    contentH        = $contentWrapper[0].scrollHeight,
                    trackW          = $trackX[0].offsetWidth,
                    contentW        = $contentWrapper[0].scrollWidth,
                    overlap         = 2;

                // If both tracks are visible, this will offset the bottom right so the 2 bars do not overlap.
                if(trackH < contentH && trackW < contentW){
                    overlap = 11;
                }

                if (trackH < contentH) {
                    var scrollT         = $contentScroller[0].scrollTop,
                        barRatioY       = trackH / contentH,
                        handleT         = Math.round(barRatioY * scrollT) + 2,
                        handleH         = Math.floor(barRatioY * (trackH - 2)) - overlap;

                    $barY.css('top', handleT+'px');
                    $barY.css('height', handleH+'px');
                    $trackY[0].style.display = 'block';
                } else {
                    $trackY[0].style.display = 'none';
                }

                if (trackW < contentW) {
                    var scrollL         = $contentScroller[0].scrollLeft,
                        barRatioX       = trackW / contentW,
                        handleL         = Math.round(barRatioX * scrollL) + 2,
                        handleW         = Math.floor(barRatioX * (trackW - 2)) - overlap;

                    if(angular.isDefined(collHdr) && collHdr.length > 0){
                        collHdr[0].scrollLeft = scrollL;
                    }

                    $barX.css('left', handleL+'px');
                    $barX.css('width', handleW+'px');
                    $trackX[0].style.display = 'block';
                } else {
                    $trackX[0].style.display = 'none';
                }
            }

            function registerBarDrag(axis){
                if(!axis) axis='Y';
                axis = axis.toUpperCase();
                var barEle   = (axis==='X'? $barX[0] : $barY[0]);
                var trackEle = (axis==='X'? $trackX[0] : $trackY[0]);

                var hammer = new Hammer(barEle);
                hammer.get('pan').set({
                    direction: Hammer.DIRECTION_ALL,
                    threshold: 1
                });

                hammer.on('panstart', function(event){
                    event.preventDefault();
                    dragOffset = event.srcEvent['page'+axis] - barEle[(axis==='X'? 'offsetLeft' : 'offsetTop')];
                });

                hammer.on('panmove', function(event){
                    event.preventDefault();

                    var eventOffset = event.srcEvent['page'+axis],
                        dragPos     = null,
                        dragPerc    = null,
                        scrollPos   = null;

                    dragPos = eventOffset - trackEle[(axis==='X'? 'offsetLeft' : 'offsetTop')] - dragOffset;
                    dragPerc = dragPos / trackEle[(axis==='X' ? 'offsetWidth':'offsetHeight')];
                    scrollPos = dragPerc * $contentWrapper[0][(axis==='X' ? 'scrollWidth':'scrollHeight')];

                    $contentScroller[0][(axis==='X' ? 'scrollLeft':'scrollTop')] = scrollPos;
                    if(angular.isDefined(collHdr) && axis==='X'){
                        collHdr[0].scrollLeft = scrollPos;
                    }

                });

                hammer.on('panend', function(event){

                });

                $element.on('$destroy', function(){
                    if(angular.isDefined(hammer)){
                        hammer.destroy();
                    }
                });
            }

            function flashScrollbar() {
                resizeScrollbar();
                showScrollbar();
            }

            function showScrollbar() {

                $barY.addClass('visible');
                $barX.addClass('visible');

                if (!options.autoHide) {
                    return;
                }
                if(typeof flashTimeout === 'number') {
                    window.clearTimeout(flashTimeout);
                }
                flashTimeout = window.setTimeout(hideScrollbar, 1000);
            }

            function hideScrollbar() {
                $barY.removeClass('visible');
                $barX.removeClass('visible');
                if(typeof flashTimeout === 'number') {
                    window.clearTimeout(flashTimeout);
                }
            }

            $timeout(function(){ init(); });

            $element.on('$destroy', function(){

            });
        }

        function scrollbarWidth () {
            var tempEl  = angular.element('<div style="width:50px;height:50px;overflow-y:scroll;top:-200px;left:-200px;"><div style="height:100px;"></div>'),
                width   = 0,
                widthMinusScrollbars = 0;

            angular.element(document.body).append(tempEl);

            width = tempEl[0].offsetWidth;
            widthMinusScrollbars = tempEl[0].querySelector('div').offsetWidth;

            tempEl.remove();

            return (width - widthMinusScrollbars);
        }
    }
})();






























/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
'use strict';

angular.module('enspire.ui.components.section')
    .controller('enSectionController', SectionController);
    
    /*
     * @private
     * @ngdoc controller
     * @name SectionController
     * @module enspire.ui.components.section
     *
     */
    function SectionController($scope, $element, $attrs){
        var self = this;
        self.$section         = $element;
        self.isCollapsible    = false;
        self.collapsed        = false;

        if(angular.isDefined($attrs.collapsible) && $attrs.collapsible=='true'){
            self.isCollapsible = true;
        }

        // Allows the section to be initialized as collapsed.
        if(angular.isDefined($attrs.collapsed) && $attrs.collapsed=='true'){
            self.collapsed = true;
        }
    }
    SectionController.$inject = ["$scope", "$element", "$attrs"];
    
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';


    angular.module('enspire.ui.components.section')
        .directive('enSection', SectionDirective);


    /**
     * @ngdoc directive
     * @name enSection
     * @module enspire.ui.components.section
     * @restrict E
     * @description
     * `en-section`...
     *
     * @element en-section
     *
     */

    function SectionDirective($timeout, $compile) {
        return {
            restrict: 'E',
            controller: 'enSectionController',
            link: postLink
        };

        function postLink($scope, $element, $attrs, sectionCtrl) {

        }
    }
    SectionDirective.$inject = ["$timeout", "$compile"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.sortable').directive('enSortableElement', ComponentDirective);


    function ComponentDirective($parse) {
        var dde = document.documentElement,
            matchingFunction = dde.matches ? 'matches' :
                                dde.matchesSelector ? 'matchesSelector' :
                                dde.webkitMatches ? 'webkitMatches' :
                                dde.webkitMatchesSelector ? 'webkitMatchesSelector' :
                                dde.msMatches ? 'msMatches' :
                                dde.msMatchesSelector ? 'msMatchesSelector' :
                                dde.mozMatches ? 'mozMatches' :
                                dde.mozMatchesSelector ? 'mozMatchesSelector' : null;

        var closestElement = angular.element.prototype.closest || function (selector){
            var el = this[0].parentNode;
            while(el !== document.documentElement && !el[matchingFunction](selector))
                el = el.parentNode;

            if(el[matchingFunction](selector))
                return angular.element(el);
            else
                return angular.element();
        };


        return {
            restrict: 'A',
            require: ['^enSortablePart', '^enSortableRoot'],
            controller: ["$scope", function($scope){
                $scope.$ctrl = this;
            }],
            link: linkFn
        };


        function touchFix(e){
            if(!('clientX' in e) && !('clientY' in e)) {
                var touches = e.touches || e.originalEvent.touches;
                if(touches && touches.length) {
                    e.clientX = touches[0].clientX;
                    e.clientY = touches[0].clientY;
                }
                e.preventDefault();
            }
        }

        function linkFn ($scope, $element, $attrs, $controllers){
            var elem = $element[0],
                rootCtrl = $controllers[1],
                origScope,
                newScope;

            // No ng-repeat
            if (!elem.hasAttribute('ng-repeat') && !rootCtrl.disabled) {
                origScope = $scope;
                newScope = $scope.$new();
                $scope = newScope;
                $scope.$index = parseInt(elem.getAttribute('data-en-sort-index'));
            }
            elem.removeAttribute('data-en-sort-index');


            // Skip if directive is disabled
            if (rootCtrl.disabled) return;


            var sortableElement = {
                element: $element,
                getPart: $controllers[0].getPart,
                getIndex: function(){
                    return $scope.$index;
                }
            };
            $controllers[1].addToSortableElements(sortableElement);
            $scope.$on('$destroy', function(){
                $controllers[1].removeFromSortableElements(sortableElement);
            });

            var handle = $element;
            handle.on('mousedown touchstart', onMousedown);
            $scope.$watch('$ctrl.handle', function(customHandle){
                if(customHandle){
                    handle.off('mousedown touchstart', onMousedown);
                    handle = customHandle;
                    handle.on('mousedown touchstart', onMousedown);
                }
            });

            var helper;
            $scope.$watch('$ctrl.helper', function(customHelper){
                if(customHelper){
                    helper = customHelper;
                }
            });

            var placeholder;
            $scope.$watch('$ctrl.placeholder', function(customPlaceholder){
                if(customPlaceholder){
                    placeholder = customPlaceholder;
                }
            });

            var body = angular.element(document.body);
            var html = angular.element(document.documentElement);

            var moveExecuted;

            function onMousedown(e){
                touchFix(e);

                if($controllers[1].sortingInProgress()) return;
                if(e.button != 0 && e.type === 'mousedown') return;

                moveExecuted = false;
                var opts = $parse($attrs.enSortableElement)($scope);
                opts = angular.extend({}, {
                    tolerance: 'pointer',
                    revert: 200,
                    containment: 'html'
                }, opts);
                if(opts.containment){
                    var containmentRect = closestElement.call($element, opts.containment)[0].getBoundingClientRect();
                }

                var target = $element;
                var clientRect = $element[0].getBoundingClientRect();
                var clone;

                if(!helper) helper = $controllers[0].helper;
                if(!placeholder) placeholder = $controllers[0].placeholder;
                if(helper){
                    clone = helper.clone();
                    clone.removeClass('ng-hide');
                    clone.css({
                        'left': clientRect.left + document.body.scrollLeft + 'px',
                        'top': clientRect.top + document.body.scrollTop + 'px'
                    });
                    target.addClass('sortable-visibility-hidden');
                }
                else{
                    clone = target.clone();
                    clone.addClass('sortable-helper').css({
                        'left': clientRect.left + document.body.scrollLeft + 'px',
                        'top': clientRect.top + document.body.scrollTop + 'px',
                        'width': clientRect.width + 'px'
                    });
                }

                clone[0].reposition = function(coords){
                    var targetLeft = coords.x;
                    var targetTop = coords.y;
                    var helperRect = clone[0].getBoundingClientRect();

                    var body = document.body;

                    if(containmentRect){
                        if(targetTop < containmentRect.top + body.scrollTop) // top boundary
                            targetTop = containmentRect.top + body.scrollTop;
                        if(targetTop + helperRect.height > containmentRect.top + body.scrollTop + containmentRect.height) // bottom boundary
                            targetTop = containmentRect.top + body.scrollTop + containmentRect.height - helperRect.height;
                        if(targetLeft < containmentRect.left + body.scrollLeft) // left boundary
                            targetLeft = containmentRect.left + body.scrollLeft;
                        if(targetLeft + helperRect.width > containmentRect.left + body.scrollLeft + containmentRect.width) // right boundary
                            targetLeft = containmentRect.left + body.scrollLeft + containmentRect.width - helperRect.width;
                    }
                    this.style.left = targetLeft - body.scrollLeft + 'px';
                    this.style.top = targetTop - body.scrollTop + 'px';
                };

                var pointerOffset = {
                    x: (e.clientX - clientRect.left)/clientRect.width,
                    y: (e.clientY - clientRect.top)/clientRect.height
                };
                html.addClass('sortable-sorting-in-progress');
                html.on('mousemove touchmove', onMousemove).on('mouseup touchend touchcancel', function mouseup(e){
                    html.off('mousemove touchmove', onMousemove);
                    html.off('mouseup touchend', mouseup);
                    html.removeClass('sortable-sorting-in-progress');
                    if(moveExecuted)
                        $controllers[0].$drop($scope.$index, opts);
                    else
                        $element.removeClass('sortable-visibility-hidden');
                });

                // onMousemove(e);
                function onMousemove(e){
                    touchFix(e);
                    if(!moveExecuted){
                        $element.parent().prepend(clone);
                        moveExecuted = true;
                    }
                    $controllers[1].$moveUpdate(opts, {
                        x: e.clientX,
                        y: e.clientY,
                        offset: pointerOffset
                    }, clone, $element, placeholder, $controllers[0].getPart(), $scope.$index);
                }
            }
        } //linkFn
    }
    ComponentDirective.$inject = ["$parse"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.sortable').directive('enSortableHandle', ComponentDirective);

    function ComponentDirective() {
        return {
            require: '?^enSortableElement',
            link: function($scope, $element, $attrs, $ctrl){
                if($ctrl)
                    $ctrl.handle = $element.add($ctrl.handle); // support multiple handles
            }
        };
    }

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.sortable').directive('enSortableHelper', ComponentDirective);

    function ComponentDirective() {
        return {
            require: ['?^enSortablePart', '?^enSortableElement'],
            link: function($scope, $element, $attrs, $ctrl){
                $element.addClass('sortable-helper').addClass('ng-hide');
                if($ctrl[1])
                    $ctrl[1].helper = $element;
                else if($ctrl[0])
                    $ctrl[0].helper = $element;
            }
        };
    }

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.sortable').directive('enSortablePart', ComponentDirective);


    function ComponentDirective($parse) {
        return {
            restrict: 'A',
            require: '^enSortableRoot',
            controller: ["$scope", function($scope){
                $scope.$ctrl = this;
                this.getPart = function(){
                    return $scope.part;
                };
                this.$drop = function(index, options){
                    $scope.$sortableRoot.$drop($scope.part, index, options);
                };
            }],
            scope: true,
            link: {
                pre: function($scope, $element, $attrs, $sortable){
                    // Skip if directive is disabled
                    if ($sortable.disabled) return;

                    if(!$attrs.enSortablePart) throw new Error('no model provided');

                    var model = $parse($attrs.enSortablePart);
                    if(!model.assign) throw new Error('model not assignable');

                    $scope.part = {
                        id: $scope.$id,
                        element: $element,
                        model: model,
                        scope: $scope
                    };
                    $scope.$sortableRoot = $sortable;

                    var sortablePart = {
                        element: $element,
                        getPart: $scope.$ctrl.getPart,
                        container: true
                    };

                    $sortable.addToSortableElements(sortablePart);
                    $scope.$on('$destroy', function(){
                        $sortable.removeFromSortableElements(sortablePart);
                    });
                }
            }
        };
    }
    ComponentDirective.$inject = ["$parse"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.sortable').directive('enSortablePlaceholder', ComponentDirective);

    function ComponentDirective() {
        return {
            require: ['?^enSortablePart', '?^enSortableElement'],
            link: function($scope, $element, $attrs, $ctrl){
                $element.addClass('sortable-placeholder').addClass('ng-hide');
                if($ctrl[1])
                    $ctrl[1].placeholder = $element;
                else if($ctrl[0])
                    $ctrl[0].placeholder = $element;
            }
        };        
    }

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.sortable').directive('enSortableRoot', ComponentDirective);

    /**
     * @ngdoc directive
     * @name enSortable
     * @module enspire.ui.components.sortable
     * @restrict A
     * @description
     * Fully declarative angular (multi)sortable directive.
     *
     * <style>.api-section table th:nth-of-type(1) { width: 150px;  } </style>
     *
     * @param {object} [en-sortable= ] This is where all the logic is happening. If multiple lists should
     *                                be connected with each other so that elements can be moved between
     *                                them and they have a common ancestor, put this attribute on that element.
     *                                If not and you still want the multi-sortable behaviour a value for that attribue
     *                                must be provided. That value will be used as an identifier to connect those roots
     *                                together.
     *
     *
     * @param {object} [en-sortable-part= ] This attribute should be placed on an element that is a container for the `ng-repeat`
     *                              Its value should be the same as the right hand side expression in `ng-repeat` attribute.
     *
     * @param {object} [en-sortable-element= ] Placed on the same element as the `ng-repeat`. You can optionally pass in
     *                                          an options object as literal object or object off the $scope.<br /><br />
     *                                          Available options to pass in:
     *                                          <ul style="padding-left: 30px;"><li>**containment**: CSS selector to contain the element to when dragging. Defaults `html` tag.</li>
     *                                          <li>**revert**: Defaults to `200`.</li>
     *                                          <li>**tolerance**: Defaults to `pointer`.</li></ul>
     *
     * @param [en-sortable-handle (Optional)= ] If needed it can be placed on an element within the sortable element. This element will be the handle for sorting operations.
     *
     * @param [en-sortable-helper (Optional)= ] The element with this attribute will serve as a custom helper for sorting operations.
     *
     * @param [en-sortable-placeholder (Optional)= ] The element with this attribute will serve as a custom placeholder for sorting operations.
     *
     *
     * @usage
     * ### Example of single sortable list
     * <hljs lang="html">
     *   <div en-sortable-root en-sortable-part="modelArray">
     *       <div ng-repeat="item in modelArray" en-sortable-element>
     *           <div>{{item}}</div>
     *       </div>
     *   </div>
     * </hljs>
     *
     *
     * ### Example of single sortable list with dragging containment.
     * <hljs lang="html">
     *   <div en-sortable-root en-sortable-part="modelArray">
     *       <div ng-repeat="item in modelArray" en-sortable-element="{'containment': '.mySelector'}">
     *           <div>{{item}}</div>
     *       </div>
     *   </div>
     * </hljs>
     *
     *
     * ### Example of multiple sortable lists _WITH_ common ancestor
     * <hljs lang="html">
     *   <div en-sortable-root>
     *       <div en-sortable-part="modelArray1">
     *           <div ng-repeat="item in modelArray1" en-sortable-element>
     *               <div>{{item}}</div>
     *           </div>
     *       </div>
     *       <div en-sortable-part="modelArray2">
     *           <div ng-repeat="item in modelArray2" en-sortable-element>
     *               <div>{{item}}</div>
     *           </div>
     *       </div>
     *   </div>
     * </hljs>
     *
     *
     * ### Example of multiple sortable lists _WITHOUT_ common ancestor
     * <hljs lang="html">
     *   <div>
     *       <div en-sortable-root="someUniqueId" en-sortable-part="modelArray1">
     *           <div ng-repeat="item in modelArray1" en-sortable-element>
     *               <div>{{item}}</div>
     *           </div>
     *       </div>
     *       <div en-sortable-root="someUniqueId" en-sortable-part="modelArray2">
     *           <div ng-repeat="item in modelArray2" en-sortable-element>
     *               <div>{{item}}</div>
     *           </div>
     *       </div>
     *   </div>
     * </hljs>
     *
     *
     * <h3>Example of using custom helpers <span style="background-color: #A9D0F5">per part</span></h3>
     * <hljs lang="html">
     *   <div en-sortable-root en-sortable-part="modelArray">
     *       <div en-sortable-helper>
     *           custom helper
     *       </div>
     *       <div ng-repeat="item in modelArray" en-sortable-element>
     *           {{item}}
     *       </div>
     *   </div>
     * </hljs>
     *
     *
     * <h3>Example of using custom helpers <span style="background-color: #D8CEF6">per element</span></h3>
     * <hljs lang="html">
     *   <div en-sortable-root en-sortable-part="modelArray">
     *       <div ng-repeat="item in modelArray" en-sortable-element>
     *           <div en-sortable-helper>
     *               custom helper {{item}}
     *           </div>
     *           {{item}}
     *       </div>
     *   </div>
     * </hljs>
     *
     *
     * ### Example of using custom placeholders <span style="background-color: #A9D0F5">per part</span>
     * <hljs lang="html">
     *   <div en-sortable-root en-sortable-part="modelArray">
     *       <div en-sortable-placeholder>
     *           custom placeholder
     *       </div>
     *       <div ng-repeat="item in modelArray" en-sortable-element>
     *           {{item}}
     *       </div>
     *   </div>
     * </hljs>
     *
     *
     * ### Example of using custom placeholders <span style="background-color: #D8CEF6">per element</span>
     * <hljs lang="html">
     *   <div en-sortable-root en-sortable-part="modelArray">
     *       <div ng-repeat="item in modelArray" en-sortable-element>
     *           <div en-sortable-placeholder>
     *               custom placeholder {{item}}
     *           </div>
     *           {{item}}
     *       </div>
     *   </div>
     * </hljs>
     */

    function ComponentDirective() {

        function shouldBeAfter(elem, pointer, isGrid){
            return isGrid ? elem.x - pointer.x < 0 : elem.y - pointer.y < 0;
        }
        function getSortableElements(key){
            return ROOTS_MAP[key];
        }
        function removeSortableElements(key){
            delete ROOTS_MAP[key];
        }

        function getPreviousSibling(element){
            element = element[0];
            if(element.previousElementSibling)
                return angular.element(element.previousElementSibling);
            else{
                var sib = element.previousSibling;
                while(sib != null && sib.nodeType != 1)
                    sib = sib.previousSibling;
                return angular.element(sib);
            }
        }

        function insertElementBefore(element, newElement){
            var prevSibl = getPreviousSibling(element);
            if(prevSibl.length > 0){
                prevSibl.after(newElement);
            }
            else{
                element.parent().prepend(newElement);
            }
        }
        var dde = document.documentElement,
            matchingFunction = dde.matches ? 'matches' :
                                dde.matchesSelector ? 'matchesSelector' :
                                dde.webkitMatches ? 'webkitMatches' :
                                dde.webkitMatchesSelector ? 'webkitMatchesSelector' :
                                dde.msMatches ? 'msMatches' :
                                dde.msMatchesSelector ? 'msMatchesSelector' :
                                dde.mozMatches ? 'mozMatches' :
                                dde.mozMatchesSelector ? 'mozMatchesSelector' : null;

        if (matchingFunction == null) throw 'This browser doesn\'t support the HTMLElement.matches method';

        function elementMatchesSelector(element, selector){
            if(element instanceof angular.element) element = element[0];
            if(matchingFunction !== null)
                return element[matchingFunction](selector);
        }


        var sortingInProgress;
        var ROOTS_MAP = Object.create(null);
        // window.ROOTS_MAP = ROOTS_MAP; // for debug purposes

        return {
            restrict: 'A',
            compile: function($element, $attrs) {
                var sortableElem = $element[0].querySelectorAll('[en-sortable-element]');

                for (var i = 0, len = sortableElem.length; i < len; i++) {
                    sortableElem.item(i).setAttribute('data-en-sort-index', i);
                }
            },
            controller: ["$scope", "$attrs", "$interpolate", "$parse", function($scope, $attrs, $interpolate, $parse){
                var mapKey = $interpolate($attrs.enSortableRoot)($scope) || $scope.$id;
                if(!ROOTS_MAP[mapKey]) ROOTS_MAP[mapKey] = [];

                var that         = this;
                var candidates;  // set of possible destinations
                var $placeholder;// placeholder element
                var options;     // sortable options
                var $helper;     // helper element - the one thats being dragged around with the mouse pointer
                var $original;   // original element
                var $target;     // last best candidate
                var isGrid       = false;
                var onSort       = $parse($attrs.sortableOnSort);

                // ----- hack due to https://github.com/angular/angular.js/issues/8044
                $attrs.sortableOnStart = $attrs.$$element[0].attributes['sortable-on-start'];
                $attrs.sortableOnStart = $attrs.sortableOnStart && $attrs.sortableOnStart.value;

                $attrs.sortableOnStop = $attrs.$$element[0].attributes['sortable-on-stop'];
                $attrs.sortableOnStop = $attrs.sortableOnStop && $attrs.sortableOnStop.value;
                // -------------------------------------------------------------------

                var onStart = $parse($attrs.sortableOnStart);
                var onStop = $parse($attrs.sortableOnStop);

                this.sortingInProgress = function(){
                    return sortingInProgress;
                };

                // Ignore undefined en-sortable-part, invalid model
                if ($attrs.enSortablePart !== undefined && $parse($attrs.enSortablePart)($scope) === undefined) {
                    this.disabled = true;
                    return;
                }

                if($attrs.sortableGrid){ // sortable-grid determined explicite
                    isGrid = $attrs.sortableGrid === "true" ? true : $attrs.sortableGrid === "false" ? false : null;
                    if(isGrid === null)
                        throw 'Invalid value of sortable-grid attribute';
                }
                else{
                    // check if at least one of the lists have a grid like layout
                    $scope.$watchCollection(function(){
                        return getSortableElements(mapKey);
                    }, function(collection){
                        isGrid = false;
                        var array = collection.filter(function(item){
                            return !item.container;
                        }).map(function(item){
                            return {
                                part: item.getPart().id,
                                y: item.element[0].getBoundingClientRect().top
                            };
                        });
                        var dict = Object.create(null);
                        array.forEach(function(item){
                            if(dict[item.part])
                                dict[item.part].push(item.y);
                            else
                                dict[item.part] = [item.y];
                        });
                        Object.keys(dict).forEach(function(key){
                            dict[key].sort();
                            dict[key].forEach(function(item, index){
                                if(index < dict[key].length - 1){
                                    if(item > 0 && item === dict[key][index + 1]){
                                        isGrid = true;
                                    }
                                }
                            });
                        });
                    });
                }

                this.$moveUpdate = function(opts, mouse, svElement, svOriginal, svPlaceholder, originatingPart, originatingIndex){
                    var svRect = svElement[0].getBoundingClientRect();
                    if(opts.tolerance === 'element')
                        mouse = {
                            x: ~~(svRect.left + svRect.width/2),
                            y: ~~(svRect.top + svRect.height/2)
                        };

                    sortingInProgress = true;
                    candidates = [];
                    if(!$placeholder){
                        if(svPlaceholder){ // custom placeholder
                            $placeholder = svPlaceholder.clone();
                            $placeholder.removeClass('ng-hide');
                        }
                        else{ // default placeholder
                            $placeholder = svOriginal.clone();
                            $placeholder.addClass('sortable-visibility-hidden');
                            $placeholder.addClass('sortable-placeholder');
                            $placeholder.css({
                                'height': svRect.height + 'px',
                                'width': svRect.width + 'px'
                            });
                        }

                        svOriginal.after($placeholder);
                        svOriginal.addClass('ng-hide');

                        // cache options, helper and original element reference
                        $original = svOriginal;
                        options = opts;
                        $helper = svElement;

                        onStart($scope, {
                            $helper: $helper,
                            $part: originatingPart.model(originatingPart.scope),
                            $index: originatingIndex,
                            $item: originatingPart.model(originatingPart.scope)[originatingIndex]
                        });
                        $scope.$root && $scope.$root.$$phase || $scope.$apply();
                    }

                    // ----- move the element
                    $helper[0].reposition({
                        x: mouse.x + document.body.scrollLeft - mouse.offset.x*svRect.width,
                        y: mouse.y + document.body.scrollTop - mouse.offset.y*svRect.height
                    });

                    // ----- manage candidates
                    getSortableElements(mapKey).forEach(function(se, index){
                        if(opts.containment != null){
                            // TODO: optimize this since it could be calculated only once when the moving begins
                            if(
                                !elementMatchesSelector(se.element, opts.containment) &&
                                !elementMatchesSelector(se.element, opts.containment + ' *')
                            ) return; // element is not within allowed containment
                        }
                        var rect = se.element[0].getBoundingClientRect();
                        var center = {
                            x: ~~(rect.left + rect.width/2),
                            y: ~~(rect.top + rect.height/2)
                        };
                        if(!se.container && // not the container element
                            (se.element[0].scrollHeight || se.element[0].scrollWidth)){ // element is visible
                            candidates.push({
                                element: se.element,
                                q: (center.x - mouse.x)*(center.x - mouse.x) + (center.y - mouse.y)*(center.y - mouse.y),
                                view: se.getPart(),
                                targetIndex: se.getIndex(),
                                after: shouldBeAfter(center, mouse, isGrid)
                            });
                        }
                        if(se.container && !se.element[0].querySelector('[sortable-element]:not(.sortable-placeholder):not(.sortable-source)')){ // empty container
                            candidates.push({
                                element: se.element,
                                q: (center.x - mouse.x)*(center.x - mouse.x) + (center.y - mouse.y)*(center.y - mouse.y),
                                view: se.getPart(),
                                targetIndex: 0,
                                container: true
                            });
                        }
                    });
                    var pRect = $placeholder[0].getBoundingClientRect();
                    var pCenter = {
                        x: ~~(pRect.left + pRect.width/2),
                        y: ~~(pRect.top + pRect.height/2)
                    };
                    candidates.push({
                        q: (pCenter.x - mouse.x)*(pCenter.x - mouse.x) + (pCenter.y - mouse.y)*(pCenter.y - mouse.y),
                        element: $placeholder,
                        placeholder: true
                    });
                    candidates.sort(function(a, b){
                        return a.q - b.q;
                    });

                    candidates.forEach(function(cand, index){
                        if(index === 0 && !cand.placeholder && !cand.container){
                            $target = cand;
                            cand.element.addClass('sortable-candidate');
                            if(cand.after)
                                cand.element.after($placeholder);
                            else
                                insertElementBefore(cand.element, $placeholder);
                        }
                        else if(index === 0 && cand.container){
                            $target = cand;
                            cand.element.append($placeholder);
                        }
                        else
                            cand.element.removeClass('sortable-candidate');
                    });
                };

                this.$drop = function(originatingPart, index, options){
                    if(!$placeholder) return;

                    if(options.revert){
                        var placeholderRect = $placeholder[0].getBoundingClientRect();
                        var helperRect = $helper[0].getBoundingClientRect();
                        var distance = Math.sqrt(
                            Math.pow(helperRect.top - placeholderRect.top, 2) +
                            Math.pow(helperRect.left - placeholderRect.left, 2)
                        );

                        var duration = +options.revert*distance/200; // constant speed: duration depends on distance
                        duration = Math.min(duration, +options.revert); // however it's not longer that options.revert

                        ['-webkit-', '-moz-', '-ms-', '-o-', ''].forEach(function(prefix){
                            if(typeof $helper[0].style[prefix + 'transition'] !== "undefined")
                                $helper[0].style[prefix + 'transition'] = 'all ' + duration + 'ms ease';
                        });
                        setTimeout(afterRevert, duration);
                        $helper.css({
                            'top': placeholderRect.top + document.body.scrollTop + 'px',
                            'left': placeholderRect.left + document.body.scrollLeft + 'px'
                        });
                    }
                    else
                        afterRevert();

                    function afterRevert(){
                        sortingInProgress = false;
                        $placeholder.remove();
                        $helper.remove();
                        $original.removeClass('ng-hide');

                        candidates = void 0;
                        $placeholder = void 0;
                        options = void 0;
                        $helper = void 0;
                        $original = void 0;

                        // sortable-on-stop callback
                        onStop($scope, {
                            $part: originatingPart.model(originatingPart.scope),
                            $index: index,
                            $item: originatingPart.model(originatingPart.scope)[index]
                        });

                        if($target){
                            $target.element.removeClass('sortable-candidate');
                            var spliced = originatingPart.model(originatingPart.scope).splice(index, 1);
                            var targetIndex = $target.targetIndex;
                            if($target.view === originatingPart && $target.targetIndex > index)
                                targetIndex--;
                            if($target.after)
                                targetIndex++;
                            $target.view.model($target.view.scope).splice(targetIndex, 0, spliced[0]);

                            // sortable-on-sort callback
                            if($target.view !== originatingPart || index !== targetIndex)
                                onSort($scope, {
                                    $partTo: $target.view.model($target.view.scope),
                                    $partFrom: originatingPart.model(originatingPart.scope),
                                    $item: spliced[0],
                                    $indexTo: targetIndex,
                                    $indexFrom: index
                                });

                        }
                        $target = void 0;

                        $scope.$root && $scope.$root.$$phase || $scope.$apply();
                    }
                };

                this.addToSortableElements = function(se){
                    getSortableElements(mapKey).push(se);
                };
                this.removeFromSortableElements = function(se){
                    var elems = getSortableElements(mapKey);
                    var index = elems.indexOf(se);
                    if(index > -1){
                        elems.splice(index, 1);
                        if(elems.length === 0)
                            removeSortableElements(mapKey);
                    }
                };
            }]
        };
    }

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.src')
        .directive('enSrc', srcDirective);

    /**
     * @ngdoc directive
     * @name enSrc
     * @module enspire.ui.components.src
     *
     * @restrict A
     *
     * @description
     * The `<img en-src="">` directive...
     *
     */
    function srcDirective() {

        var isCSP;

        /*down and dirty way to check for CSP*/
        try {
            new Function('');
            isCSP = false;
        } catch (e) {
            isCSP = true;
        }

        return {
            restrict: 'A',
            replace: false,
            priority: 99, //after all build-in directive are compiled
            link: postLink
        };

        function postLink($scope, $element, $attrs) {
            $attrs.$observe('enSrc', function(value) {
                if (!value){
                    return false;
                }

                if($element[0].nodeName.toLowerCase() === 'img' && value.indexOf('blob') !== 0 && isCSP) {
                    //if it is img tag then use XHR to load image.
                    var localSrc = null;
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', value, true);
                    xhr.responseType = 'blob';
                    xhr.onload = function(e) {
                        localSrc = URL.createObjectURL(this.response);
                        $element[0].src = localSrc;
                    };
                    xhr.send();
                    $scope.$on('$destroy', function() {
                        if (localSrc) {
                            URL.revokeObjectURL(localSrc);
                        }
                    });


                } else {
                    $attrs.$set('src', value);
                }
            });
        }

    }

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.tabs')
    .controller('enTabsController', TabsController);
    
    /**
     * @private
     * @ngdoc function
     * @name TabsController
     * @module enspire.ui.components.tabs
     *
     */
    function TabsController($scope, $element, $attrs, $location, $rootScope, $enTabs, $timeout, $stateParams) {
        var self = this;

        self.onState = function(ref,location){
            if(!angular.isDefined(location)) {
                location = '';
                var setName = false;
                for (var segment in $stateParams) {
                    if ($stateParams.hasOwnProperty(segment)) {
                        if ($attrs.view === segment) {
                            location += '/' + ref;
                            setName = true;
                        } else {
                            if (setName) {
                                location += '/';
                                break;
                            } else {
                                location += '/' + $stateParams[segment];
                            }
                        }
                    }
                }
            }
            $timeout(function() { $location.url(location); });
        };

        self.onPane = function(pane){
            if(angular.isDefined($attrs.panes)){
                $timeout(function() { $enTabs.select($attrs.panes, pane); });
            }
        };

        self.view = function(){
            return $attrs.view;
        };

        self.panes = function(){
            return $attrs.panes;
        };

    }
    TabsController.$inject = ["$scope", "$element", "$attrs", "$location", "$rootScope", "$enTabs", "$timeout", "$stateParams"];
    
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.tabs')
        .directive('enTabs', TabsDirective);


    /**
     * @ngdoc directive
     * @name enTabs
     * @module enspire.ui.components.tabs
     * @restrict E
     * @description
     * `en-tabs`...
     *
     * @element en-tabs
     *
     * @param {string=} panes       Defines name of container that the tabs reside in.
     * @param {string=} view        Sets content of tab or accepts a state/url.
     *
     */

    function TabsDirective() {
        return {
            restrict: 'E',
            controller: 'enTabsController',
            link: postLink
        };

        function postLink($scope, $element, $attrs) {
            
        }
    }
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.tabs')
        .provider('$enTabs', TabsService);


/**
* @ngdoc service
* @name $enTabs
* @module enspire.ui.components.tabs
*
* @description
* Manages tab containers and selected tabs.
*
*/


    function TabsService() {
        var self = this;

        var container = {};

        self.$get = ['$rootScope',function $enTabFactory($rootScope) {
             var obj = {
                /**
                 * @ngdoc method
                 * @name $enTabs#addContainer
                 *
                 * @description
                 * Adds a new container to the private TabsService container object.
                 *
                 * @param {string} tabPanesName The name of the tab panes container to be added.
                 */
                addContainer: function (name) {
                    container[name] = '';
                },
                /**
                 * @ngdoc method
                 * @name $enTabs#removeContainer
                 *
                 * @description
                 * Removes a container from the private TabsService container object.
                 *
                 * @param {string} tabPanesName The name of the tab panes container to be removed.
                 */
                removeContainer: function (name) {
                    delete container[name];
                },
                /**
                 * @ngdoc method
                 * @name $enTabs#select
                 *
                 * @description
                 * Activates a tab inside of a tab container.
                 *
                 * @param {string} tabPanesName    The name of the tab panes container that the pane, to activate, resides in.
                 * @param {string} tabPaneName     The name of the tab pane to be activated.
                 */
                select: function (tainer, pane) {
                    container[tainer] = pane;
                },
                /**
                 * @ngdoc method
                 * @name $enTabs#selected
                 *
                 * @description
                 * Activates a tab inside of a tab container.
                 *
                 * @param {string} tabPanesName    The name of the tab panes container that the selected pane resides in.
                 *
                 * @returns {string} If found, returns the tabPanesName argument. Otherwise it returns `undefined`.
                 */
                selected: function (tainer) {
                    return container[tainer];
                }
            };

            $rootScope.$enTabs = obj;
            return obj;
        }];
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.time').directive('enTime', ComponentDirective);

    /**
     * @ngdoc directive
     * @name enTime
     * @module enspire.ui.components.time
     * @restrict E
     * @description
     * Conforms to new angular requirements of models belonging to input type="time" being Date objects.
     *
     *
     * @usage
     * ### Basic Example
     * <hljs lang="html">
     *   <en-time ng-model="someModel" >
     * </hljs>
     */

    function ComponentDirective() {
        return {
            restrict: 'E',
            replace: true,
            require: 'ngModel',
            template: function($element, $attrs) {
                return '<input type="time" />';
            },
            link: function($scope, $element, $attrs, modelCtrl) {
                modelCtrl.$formatters.push(function(modelValue){
                    return new Date(modelValue);
                });
            }
        }
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.timeDuration').directive('enTimeDuration', ComponentDirective);

    /**
     * @ngdoc directive
     * @name enTimeDuration
     * @module enspire.ui.components.timeDuration
     * @restrict E
     * @description
     * Displays time duration along with the units; Captures model data in seconds.
     *
     *
     * @usage
     * ### Basic Example
     * <hljs lang="html">
     *   <en-time-duration ng-model="someModel" >
     * </hljs>
     */

    function ComponentDirective() {
        return {
            restrict: 'E',
            replace: true,
            require: 'ngModel',
            template: function($element, $attrs) {
                return "<div layout='row'>"
                +"<input type='number' min='1' ng-model='num' size='5'/>"
                +"<select ng-model='unit'>"
                +"<option value='hours'>Hour(s)</option>"
                +"<option value='days'>Day(s)</option>"
                +"</select>"
                +"</div>";
            },
            link: function($scope, $element, $attrs, modelCtrl) {

                // Units of time
              var  multiplierMap = {hours: 3600, days: 86400};
              var multiplierTypes = ['hours', 'days'];

                modelCtrl.$formatters.push(function(modelValue) {
                    var unit = 'hours', num = 1, i, unitName;

                    modelValue = parseInt(modelValue || 0);

                    // Fetch the units
                    for (i = multiplierTypes.length-1; i >= 0; i--) {
                        unitName = multiplierTypes[i];
                        if (modelValue % multiplierMap[unitName] === 0) {
                            unit = unitName;
                            break;
                        }
                    }

                    if (modelValue) {
                        num = modelValue / multiplierMap[unit]
                    }

                    return {
                        unit: unit,
                        num:  num
                    };
                });

                modelCtrl.$parsers.push(function(viewValue) {
                    var unit = viewValue.unit, num = viewValue.num, multiplier;
                    multiplier = multiplierMap[unit];
                    return num * multiplier;
                });

                $scope.$watch('unit + num', function() {
                    modelCtrl.$setViewValue({ unit: $scope.unit, num: $scope.num });
                });

                modelCtrl.$render = function() {
                    if (!modelCtrl.$viewValue) modelCtrl.$viewValue = { unit: 'hours', num: 1 };
                    $scope.unit = modelCtrl.$viewValue.unit;
                    $scope.num  = modelCtrl.$viewValue.num;
                };

            }
        }
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
'use strict';

    angular.module('enspire.ui.components.title').directive('enTitle', TitleDirective);

    /**
     * @ngdoc directive
     * @name enTitle
     * @module enspire.ui.components.title
     * @restrict E
     * @element en-title
     * 
     * @description
     * Produces an inline title element.
     * 
     * @usage
     * <hljs lang="html">
     *     <en-title class="[xs|sm|md|lg]">
     *       [Title Text]
     *     </en-title>
     * </hljs>
     *
     * 
     * ## Size <a name="titleSize"></a>
     * A title can have different sizes.
     * 
     * <en-title class="xs">XS Title</en-title>  
     * 
     * <en-title class="sm">SM Title</en-title>  
     * 
     * <en-title class="md">MD Title</en-title>  
     * 
     * <en-title class="lg">Lg Title</en-title>
     */
    
    function TitleDirective($enTouch) {
        return {
            restrict    : 'E',
            link        : postLink
        };
        
        function postLink($scope, $element, $attrs){
            
        }
    }
    TitleDirective.$inject = ["$enTouch"];

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.tooltip')
    .controller('enTooltipController', TooltipController);
    
    /**
     * @private
     * @ngdoc function
     * @name TooltipController
     * @module enspire.ui.components.tooltip
     *
     */
    function TooltipController($scope, $element, $attrs) {
        var self = this;

    }
    TooltipController.$inject = ["$scope", "$element", "$attrs"];
    
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.tooltip').directive('enTooltip', TooltipDirective);

    /**
     * @ngdoc directive
     * @name enTooltip
     * @module enspire.ui.components.tooltip
     * @restrict A
     * @description
     * Adds small overlay of content on action event (hover, click, etc.) to any element for housing secondary information.
     *
     *
     * @usage
     * ### As Tooltip Icon
     * <hljs lang="html">
     *   <en-icon data-icon="help" en-tooltip popover-title="Hello World!"></en-icon>
     * </hljs>
     *
     *
     * ## Default Options
     * You can override global defaults for the plugin with $enPopoverProvider.defaults
     * <hljs lang="js">
     *     angular.module('myApp')
     *     .config(function($enTooltipProvider) {
     *          angular.extend($enTooltipProvider.defaults, {
     *              animation: 'am-flip-x',
     *              trigger: 'hover'
     *          });
     *     })
     * </hljs>
     *
     * ## Options
     * Options can be passed via popover-attributes on the directive or as an object hash to configure the service. For data attributes, append the option name to `popover-`, as in `popover-placement="right"`.
     * **NOTE**: For the service passing values using camelCase. For the directive use snake-case. Values below are in camel case, convert to snake case for use in directive.
     *
     *
     * For directives, you can naturally inherit the contextual $scope or leverage a custom one with an AngularJS expression to evaluate as an object directly on the `en-popover` attribute.
     *
     * Name      | Type     | Default | Description
     * ----------|----------| --------|------------
     * animation | *string* | | apply a CSS animation powered by `ngAnimate` See http://mgcrea.github.io/angular-motion/ for more documentation. To have it fade in use **'am-fade'**
     * customClass | *string* |  | apply a custom class name to your tooltip. Example: `tooltip-custom-class="classname"`
     * placement | *string* | 'auto'  | how to position the popover - *top* &#124; *bottom* &#124; *left* &#124; *right* &#124; *auto*, or any combination like *bottom-left* or *auto bottom-left*. When *"auto"* is specified, it will dynamically reorient the popover. For example, if placement is *"auto left"*, the popover will display to the left when possible, otherwise it will display right.
     * trigger   | *string* | 'click' | how popover is triggered - *click* &#124; *hover* &#124; *focus* &#124; *manual*
     * title     | *string* | ''      | default `title` value if `title` attribute isn't present
     * html      | *boolean*  | *false*   | replace `ng-bind` with `ng-bind-html`, requires `ngSanitize` to be loaded
     * delay     | *number* &#124; *object* | 0 | delay showing and hiding the popover (ms) - does not apply to manual trigger type <br><br> If a number is supplied, delay is applied to both hide/show <br><br> Object structure is: `delay: { show: 500, hide: 100 }`
     * container | *string* &#124; *false* | *false* | Appends the popover to a specific element. Example: `container: 'body'`. This option is particularly useful in that it allows you to position the popover in the flow of the document near the triggering element - which will prevent the popover from floating away from the triggering element during a window resize.
     * target    | *string* &#124; DOMElement &#124; *false* | *false* | Position the tooltip relative to a specific target element.
     * template  | path     | *false* | If provided, overrides the default template, can be either a remote URL or a cached template id.
     * contentTemplate | path | *false* | If provided, fetches the partial and includes it as the inner content, can be either a remote URL or a cached template id.
     * autoClose | *boolean* | *false* | If provided, auto closes the tooltip when clicking outside of it.
     * id        | *string*  | ''      | The popover instance id for usage in event handlers.
     * isolatedScope | *boolean* | *false* | If set will create an isolated scope for popover.
     * **viewport** | *string* &#124; *object* | `{ selector: 'body', padding: 0 }` | *If your popover is getting cut-off set this attribute. Use id or class of parent container. <br><br> Keeps the popover within the bounds of this element. Example: `popover-viewport: 'querySelector'` or `popover-viewport: { "selector": "querySelector", "padding": 20 }`. Types of query selectors: `#elementId`, `.elementClass`, `elementTagName`
     * data | *object* | | Adds key-values from object to the scope. Used to pass extra data to custom templates. Example: `popover-data="{'foo':'bar','version': '1.0'}"`
     *
     *
     * ##Events
     *
     * Use $scope.$on() to listen for the event.
     *
     * ### **tooltip.show.before**
     * Triggers before the tooltip is about to show.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object, DOM Element is not present.
     *
     * ### **tooltip.show**
     * Triggers when the tooltip is shown.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object, DOM Element is present.
     *
     * ### **tooltip.hide.before**
     * Triggers before the tooltip is hidden.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object, DOM Element is present.
     *
     * ### **tooltip.hide**
     * Triggers when the tooltip is hidden.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object.
     *
     *
     */

    function TooltipDirective($window, $location, $sce, $enTooltip, $$rAF, $parse) {
        return {
            restrict: 'A',
            scope   : true,
            link: postLink
        };

        function postLink($scope, $element, $attrs) {
            // Directive options
            var options = {},
                availableSettings = [
                    'title',
                    'template',
                    'contentTemplate',
                    'placement',
                    'container',
                    'delay',
                    'trigger',
                    'keyboard',
                    'html',
                    'animation',
                    'backdropAnimation',
                    'type',
                    'customClass',
                    'id'
                ];

            // Normalize attr names, convert popover-* into data-*
            function normalizeAttrs() {
                var key, newKey;
                for (key in $attrs) {
                    if (String(key).indexOf('popover') === 0) {
                        newKey = key.replace('popover','');
                        newKey = newKey.substr(0, 1).toLowerCase() + newKey.substr(1);
                        options[newKey] = $attrs[key];
                    }
                }
            }

            options.data = $parse($attrs.popoverData)() || {};
            options.scope = $scope;

            angular.forEach(availableSettings, function(key) {
                if (angular.isDefined($attrs[key])) options[key] = $attrs[key];
            });

            normalizeAttrs();

            // Default to auto placement
            if (!options.placement) {
                options.placement = 'auto';
            }

            // should not parse target attribute, only data-target
            if ($element.attr('data-target')) {
                options.target = $element.attr('data-target');
            }

            // overwrite inherited title value when no value specified
            // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11
            if (!$scope.hasOwnProperty('title')) {
                $scope.title = '';
            }

            // Observe scope attributes for change
            $attrs.$observe('popoverTitle', function(newValue) {
                if (angular.isDefined(newValue) || !$scope.hasOwnProperty('title')) {
                    var oldValue = $scope.title;
                    $scope.title = $sce.trustAsHtml(newValue);
                    angular.isDefined(oldValue) && $$rAF(function() {
                        tooltip && tooltip.$applyPlacement();
                    });
                }
            });

            // Support scope as an object
            /**
             * Support scope as an object.
             *
             * Ex: en-tooltip
             *
             */
            $attrs.enTooltip && $scope.$watch($attrs.enTooltip, function(newValue, oldValue) {
                if (angular.isObject(newValue)) {
                    angular.extend($scope, newValue);
                } else {
                    $scope.title = newValue;
                }
                angular.isDefined(oldValue) && $$rAF(function() {
                    tooltip && tooltip.$applyPlacement();
                });
            }, true);

            /**
             * Show or hide the tooltip
             */
            $attrs.enShow && $scope.$watch($attrs.popoverEnShow, function(newValue, oldValue) {
                if (!tooltip || !angular.isDefined(newValue)) return;
                if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);
                newValue === true ? tooltip.show() : tooltip.hide();
            });

            /**
             * Enable or disable tooltip.
             */
            $attrs.enEnabled && $scope.$watch($attrs.popoverEnEnabled, function(newValue, oldValue) {
                if (!tooltip || !angular.isDefined(newValue)) return;
                if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);
                newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);
            });


            // Viewport support
            $attrs.viewport && $scope.$watch($attrs.popoverViewport, function(newValue) {
                if (!tooltip || !angular.isDefined(newValue)) return;
                tooltip.setViewport(newValue);
            });

            // Initialize popover
            var tooltip = $enTooltip($element, options);

            // Garbage collection
            $scope.$on('$destroy', function() {
                if (tooltip) tooltip.destroy();
                options = null;
                tooltip = null;
            });
        }
    }
    TooltipDirective.$inject = ["$window", "$location", "$sce", "$enTooltip", "$$rAF", "$parse"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.tooltip')
        .provider('$enTooltip', TooltipService);


    /**
     * @ngdoc service
     * @name $enTooltip
     * @module enspire.ui.components.tooltip
     *
     * @description
     * Adds small overlay of content on action event (hover, click, etc.) to any element for housing secondary information.
     *
     * @usage
     * <hljs lang="js">
     * var myTooltip = $enTooltip(element, {title: 'My Title'});
     * </hljs>
     *
     * ## Scope methods
     * - **$show()** - Reveals the tooltip.
     * - **$hide()** - Hides the tooltip.
     * - **$toggle()** - Toggles the tooltip.
     *
     *
     *
     * ##Events
     *
     * Use $scope.$on() to listen for the event.
     *
     * ### **tooltip.show.before**
     * Triggers before the tooltip is about to show.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object, DOM Element is not present.
     *
     * ### **tooltip.show**
     * Triggers when the tooltip is shown.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object, DOM Element is present.
     *
     * ### **tooltip.hide.before**
     * Triggers before the tooltip is hidden.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object, DOM Element is present.
     *
     * ### **tooltip.hide**
     * Triggers when the tooltip is hidden.
     * - `event` - **Type:** Event - the event object, gives access to the target scope.
     * - `tooltip` - **Type:** *Tooltip* - the tooltip object.
     */

    function TooltipService() {
        var self = this;

        var defaults = self.defaults = {
                animation: '',
                customClass: '',
                prefixClass: 'tooltip',
                prefixEvent: 'tooltip',
                container: false,
                target: false,
                placement: 'top',
                template: 'tooltip/tooltip.tpl.html',
                contentTemplate: false,
                trigger: 'hover focus',
                keyboard: false,
                html: false,
                show: false,
                title: '',
                type: '',
                delay: 0,
                autoClose: false,
                enEnabled: true,
                viewport: {
                    selector: 'body',
                    padding: 0
                },
                isolatedScope: false,
                inlineTemplate: false
            };

        self.$get = ["$window", "$rootScope", "$compile", "$q", "$templateCache", "$http", "$animate", "$sce", "$enDimensions", "$$rAF", "$timeout", "$parse", function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, $enDimensions, $$rAF, $timeout, $parse) {
                var trim = String.prototype.trim;
                var isTouch = 'createTouch' in $window.document;
                var htmlReplaceRegExp = /ng-bind="/ig;
                var $body = angular.element($window.document);


                function TooltipFactory(element, config) {
                    var $tooltip = {};

                    // Common vars
                    var nodeName = element[0].nodeName.toLowerCase();
                    var options = $tooltip.$options = angular.extend({}, defaults, config);
                    $tooltip.$promise = fetchTemplate(options.template);

                    var scope;
                    if (options.isolatedScope) {
                        // create isolated scope
                        $tooltip.$scope = $rootScope.$new();
                    } else {
                        // create a scope off given scope, or new scope if none passed in
                        $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();
                    }
                    scope = $tooltip.$scope;

                    if (options.delay && angular.isString(options.delay)) {
                        var split = options.delay.split(',').map(parseFloat);
                        options.delay = split.length > 1 ? {
                            show: split[0],
                            hide: split[1]
                        } : split[0];
                    }

                    // store $id to identify the triggering element in events
                    // give priority to options.id, otherwise, try to use
                    // element id if defined
                    $tooltip.$id = options.id || element.attr('id') || '';


                    // Merge options into scope if none provided
                    if (options.scope === undefined || options.isolatedScope) {
                        scope.title = options.title;
                        scope.content = options.content;
                    }

                    // Parse Viewport
                    if (typeof options.viewport === 'string' && options.viewport.match(/\{[^\}]+\}/)) {
                        options.viewport = $parse(options.viewport)();
                    }

                    // Provide scope helpers
                    scope.$setEnabled = function(isEnabled) {
                        $timeout(function() {
                            $tooltip.setEnabled(isEnabled);
                        });
                    };
                    scope.$hide = function() {
                        $timeout(function() {
                            $tooltip.hide();
                        });
                    };

                    scope.$show = function() {
                        $timeout(function() {
                            $tooltip.show();
                        });
                    };
                    scope.$toggle = function() {
                        $timeout(function() {
                            $tooltip.toggle();
                        });
                    };
                    // Publish isShown as a protected var on scope
                    $tooltip.$isShown = scope.$isShown = false;

                    // Private vars
                    var timeout, hoverState;

                    // Support contentTemplate option
                    if (options.contentTemplate) {
                        $tooltip.$promise = $tooltip.$promise.then(function(template) {
                            var templateEl = angular.element(template);
                            return fetchTemplate(options.contentTemplate)
                                .then(function(contentTemplate) {
                                    var contentEl = findElement('[ng-bind="content"]', templateEl[0]);
                                    if (!contentEl.length) contentEl = findElement('[ng-bind="title"]', templateEl[0]);
                                    contentEl.removeAttr('ng-bind').html(contentTemplate);
                                    return templateEl[0].outerHTML;
                                });
                        });
                    }


                    // Fetch, compile then initialize tooltip
                    var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;
                    $tooltip.$promise.then(function(template) {
                        if (angular.isObject(template)) template = template.data;
                        if (options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html="');

                        // Support inline content template
                        if (options.inlineTemplate && !options.contentTemplate) {
                            // Overwrite default template with inline template
                            // for those who want to inline template html without using template url
                            var tpl = angular.element(template);
                            var tplContentEl = tpl[0].querySelector('[ng-bind="content"]') || tpl[0].querySelector('[ng-bind-html="content"]');
                            tplContentEl.removeAttribute('ng-bind');
                            tplContentEl.removeAttribute('ng-bind-html');
                            tplContentEl.innerHTML = options.content;
                            template = tpl[0].outerHTML;
                            tplContentEl = tpl = null;
                        }

                        template = trim.apply(template);
                        tipTemplate = template;
                        tipLinker = $compile(template);
                        $tooltip.init();
                    });

                    $tooltip.init = function() {

                        // Options: delay
                        if (options.delay && angular.isNumber(options.delay)) {
                            options.delay = {
                                show: options.delay,
                                hide: options.delay
                            };
                        }

                        // Replace trigger on touch devices ?
                        // if(isTouch && options.trigger === defaults.trigger) {
                        //   options.trigger.replace(/hover/g, 'click');
                        // }

                        // Options : container
                        if (options.container === 'self') {
                            tipContainer = element;
                        } else if (angular.isElement(options.container)) {
                            tipContainer = options.container;
                        } else if (options.container) {
                            tipContainer = findElement(options.container);
                        }

                        // Options: trigger
                        bindTriggerEvents();

                        // Options: target
                        if (options.target) {
                            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);
                        }

                        // Options: show
                        if (options.show) {
                            $timeout(function() {
                                options.trigger === 'focus' ? element[0].focus() : $tooltip.show();
                            });
                        }

                    };

                    $tooltip.destroy = function() {

                        // Unbind events
                        unbindTriggerEvents();

                        // Remove element
                        destroyTipElement();

                        // Destroy scope
                        scope.$destroy();

                    };

                    $tooltip.enter = function() {

                        clearTimeout(timeout);
                        hoverState = 'in';
                        if (!options.delay || !options.delay.show) {
                            return $tooltip.show();
                        }

                        timeout = setTimeout(function() {
                            if (hoverState === 'in') $tooltip.show();
                        }, options.delay.show);

                    };

                    $tooltip.show = function() {
                        if (!options.enEnabled || $tooltip.$isShown) return;

                        scope.$emit(options.prefixEvent + '.show.before', $tooltip);
                        var parent, after;
                        if (options.container) {
                            parent = tipContainer;
                            if (tipContainer[0].lastChild) {
                                after = angular.element(tipContainer[0].lastChild);
                            } else {
                                after = null;
                            }
                        } else {
                            parent = null;
                            after = element;
                        }

                        // Hide any existing tipElement
                        if (tipElement) destroyTipElement();

                        tipScope = $tooltip.$scope.$new();

                        // Bind variables to childScope without hard coding which ones
                        for (var key in config.data) {
                            tipScope[key] = config.data[key];
                        }

                        // Fetch a cloned element linked from template
                        tipElement = $tooltip.$element = tipLinker(tipScope, function(clonedElement, scope) {});

                        // Set the initial positioning.  Make the tooltip invisible
                        // so IE doesn't try to focus on it off screen.
                        tipElement.css({
                            top: '-9999px',
                            left: '-9999px',
                            right: 'auto',
                            display: 'block',
                            visibility: 'hidden'
                        });

                        // Options: animation
                        if (options.animation) tipElement.addClass(options.animation);
                        // Options: type
                        if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);
                        // Options: custom classes
                        if (options.customClass) tipElement.addClass(options.customClass);

                        // Append the element, without any animations.  If we append
                        // using $animate.enter, some of the animations cause the placement
                        // to be off due to the transforms.
                        after ? after.after(tipElement) : parent.prepend(tipElement);

                        $tooltip.$isShown = scope.$isShown = true;
                        safeDigest(scope);

                        // Now, apply placement
                        $tooltip.$applyPlacement();

                        // Once placed, animate it.
                        // Support v1.2+ $animate
                        // https://github.com/angular/angular.js/issues/11713
                        if(angular.version.minor <= 2) {
                            $animate.enter(tipElement, parent, after, enterAnimateCallback);
                        } else {
                            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);
                        }
                        safeDigest(scope);

                        $$rAF(function() {
                            // Once the tooltip is placed and the animation starts, make the tooltip visible
                            if (tipElement) tipElement.css({
                                visibility: 'visible'
                            });
                        });

                        // Bind events
                        if (options.keyboard) {
                            if (options.trigger !== 'focus') {
                                $tooltip.focus();
                            }
                            bindKeyboardEvents();
                        }

                        if (options.autoClose) {
                            bindAutoCloseEvents();
                        }

                    };

                    function enterAnimateCallback() {
                        scope.$emit(options.prefixEvent + '.show', $tooltip);
                    }

                    $tooltip.leave = function() {

                        clearTimeout(timeout);
                        hoverState = 'out';
                        if (!options.delay || !options.delay.hide) {
                            return $tooltip.hide();
                        }
                        timeout = setTimeout(function() {
                            if (hoverState === 'out') {
                                $tooltip.hide();
                            }
                        }, options.delay.hide);

                    };

                    var _blur;
                    var _tipToHide;
                    $tooltip.hide = function(blur) {

                        if (!$tooltip.$isShown) return;
                        scope.$emit(options.prefixEvent + '.hide.before', $tooltip);

                        // store blur value for leaveAnimateCallback to use
                        _blur = blur;

                        // store current tipElement reference to use
                        // in leaveAnimateCallback
                        _tipToHide = tipElement;

                        // Support v1.2+ $animate
                        // https://github.com/angular/angular.js/issues/11713
                        if(angular.version.minor <= 2) {
                            $animate.leave(tipElement, leaveAnimateCallback);
                        } else {
                            $animate.leave(tipElement).then(leaveAnimateCallback);
                        }

                        $tooltip.$isShown = scope.$isShown = false;
                        safeDigest(scope);

                        // Unbind events
                        if (options.keyboard && tipElement !== null) {
                            unbindKeyboardEvents();
                        }

                        if (options.autoClose && tipElement !== null) {
                            unbindAutoCloseEvents();
                        }
                    };

                    function leaveAnimateCallback() {
                        scope.$emit(options.prefixEvent + '.hide', $tooltip);

                        // check if current tipElement still references
                        // the same element when hide was called
                        if (tipElement === _tipToHide) {
                            // Allow to blur the input when hidden, like when pressing enter key
                            if (_blur && options.trigger === 'focus') {
                                return element[0].blur();
                            }

                            // clean up child scopes
                            destroyTipElement();
                        }
                    }

                    $tooltip.toggle = function(e) {
                        $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();
                    };

                    $tooltip.focus = function() {
                        tipElement[0].focus();
                    };

                    $tooltip.setEnabled = function(isEnabled) {
                        options.enEnabled = isEnabled;
                    };

                    $tooltip.setViewport = function(viewport) {
                        options.viewport = viewport;
                    };

                    // Protected methods

                    $tooltip.$applyPlacement = function() {
                        if (!tipElement) return;

                        // Determine if we're doing an auto or normal placement
                        var placement = options.placement,
                            autoToken = /\s?auto?\s?/i,
                            autoPlace = autoToken.test(placement);

                        if (autoPlace) {
                            placement = placement.replace(autoToken, '') || defaults.placement;
                        }

                        // Need to add the position class before we get
                        // the offsets
                        tipElement.addClass(options.placement);

                        // Get the position of the target element
                        // and the height and width of the tooltip so we can center it.
                        var elementPosition = getPosition(),
                            tipWidth = tipElement.prop('offsetWidth'),
                            tipHeight = tipElement.prop('offsetHeight');

                        // If we're auto placing, we need to check the positioning
                        if (autoPlace) {
                            var originalPlacement = placement;
                            var container = options.container ? findElement(options.container) : element.parent();
                            var containerPosition = getPosition(container);

                            // Determine if the vertical placement
                            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > containerPosition.bottom) {
                                placement = originalPlacement.replace('bottom', 'top');
                            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < containerPosition.top) {
                                placement = originalPlacement.replace('top', 'bottom');
                            }

                            // Determine the horizontal placement
                            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right
                            // and flow in the opposite direction of their placement.
                            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&
                                elementPosition.right + tipWidth > containerPosition.width) {

                                placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');
                            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&
                                elementPosition.left - tipWidth < containerPosition.left) {

                                placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');
                            }

                            tipElement.removeClass(originalPlacement).addClass(placement);
                        }

                        // Get the tooltip's top and left coordinates to center it with this directive.
                        var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);

                        applyPlacement(tipPosition, placement);
                    };

                    $tooltip.$onKeyUp = function(evt) {
                        if (evt.which === 27 && $tooltip.$isShown) {
                            $tooltip.hide();
                            evt.stopPropagation();
                        }
                    };

                    $tooltip.$onFocusKeyUp = function(evt) {
                        if (evt.which === 27) {
                            element[0].blur();
                            evt.stopPropagation();
                        }
                    };

                    $tooltip.$onFocusElementMouseDown = function(evt) {
                        evt.preventDefault();
                        evt.stopPropagation();
                        // Some browsers do not auto-focus buttons (eg. Safari)
                        $tooltip.$isShown ? element[0].blur() : element[0].focus();
                    };

                    // bind/unbind events
                    function bindTriggerEvents() {
                        var triggers = options.trigger.split(' ');
                        angular.forEach(triggers, function(trigger) {
                            if (trigger === 'click') {
                                element.on('click', $tooltip.toggle);
                                element.on('mousedown touchstart', function(e) {
                                    e.stopPropagation();
                                });
                            } else if (trigger !== 'manual') {
                                element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);
                                element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);
                                nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);
                            }
                        });
                    }

                    function unbindTriggerEvents() {
                        var triggers = options.trigger.split(' ');
                        for (var i = triggers.length; i--;) {
                            var trigger = triggers[i];
                            if (trigger === 'click') {
                                element.off('click', $tooltip.toggle);
                                element.off('mousedown touchstart', function(e) {
                                    e.stopPropagation();
                                });
                            } else if (trigger !== 'manual') {
                                element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);
                                element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);
                                nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);
                            }
                        }
                    }

                    function bindKeyboardEvents() {
                        if (options.trigger !== 'focus') {
                            tipElement.on('keyup', $tooltip.$onKeyUp);
                        } else {
                            element.on('keyup', $tooltip.$onFocusKeyUp);
                        }
                    }

                    function unbindKeyboardEvents() {
                        if (options.trigger !== 'focus') {
                            tipElement.off('keyup', $tooltip.$onKeyUp);
                        } else {
                            element.off('keyup', $tooltip.$onFocusKeyUp);
                        }
                    }

                    var _autoCloseEventsBinded = false;

                    function bindAutoCloseEvents() {
                        // use timeout to hookup the events to prevent
                        // event bubbling from being processed imediately.
                        $timeout(function() {
                            // Stop propagation when clicking inside tooltip
                            tipElement.on('click mousedown touchstart', stopEventPropagation);

                            // Hide when clicking outside tooltip
                            $body.on('click', $tooltip.hide);

                            _autoCloseEventsBinded = true;
                        }, 0, false);
                    }

                    function unbindAutoCloseEvents() {
                        if (_autoCloseEventsBinded) {
                            tipElement.off('click mousedown touchstart', stopEventPropagation);
                            $body.off('click', $tooltip.hide);
                            _autoCloseEventsBinded = false;
                        }
                    }

                    function stopEventPropagation(event) {
                        event.stopPropagation();
                    }

                    // Private methods

                    function getPosition($element) {
                        $element = $element || (options.target || element);

                        var el = $element[0],
                            isBody = el.tagName === 'BODY';

                        var elRect = el.getBoundingClientRect();
                        var rect = {};

                        // IE8 has issues with angular.extend and using elRect directly.
                        // By coping the values of elRect into a new object, we can continue to use extend
                        for (var p in elRect) {
                            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.
                            rect[p] = elRect[p];
                        }

                        if (rect.width === null) {
                            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
                            rect = angular.extend({}, rect, {
                                width: elRect.right - elRect.left,
                                height: elRect.bottom - elRect.top
                            });
                        }
                        var elOffset = isBody ? {
                                top: 0,
                                left: 0
                            } : $enDimensions.offset(el),
                            scroll = {
                                scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0
                            },
                            outerDims = isBody ? {
                                width: document.documentElement.clientWidth,
                                height: $window.innerHeight
                            } : null;

                        return angular.extend({}, rect, scroll, outerDims, elOffset);
                    }

                    function getCalculatedOffset(placement, position, actualWidth, actualHeight) {
                        var offset;
                        var split = placement.split('-');

                        switch (split[0]) {
                            case 'right':
                                offset = {
                                    top: position.top + position.height / 2 - actualHeight / 2,
                                    left: position.left + position.width
                                };
                                break;
                            case 'bottom':
                                offset = {
                                    top: position.top + position.height,
                                    left: position.left + position.width / 2 - actualWidth / 2
                                };
                                break;
                            case 'left':
                                offset = {
                                    top: position.top + position.height / 2 - actualHeight / 2,
                                    left: position.left - actualWidth
                                };
                                break;
                            default:
                                offset = {
                                    top: position.top - actualHeight,
                                    left: position.left + position.width / 2 - actualWidth / 2
                                };
                                break;
                        }

                        if (!split[1]) {
                            return offset;
                        }

                        // Add support for corners @todo css
                        if (split[0] === 'top' || split[0] === 'bottom') {
                            switch (split[1]) {
                                case 'left':
                                    offset.left = position.left;
                                    break;
                                case 'right':
                                    offset.left = position.left + position.width - actualWidth;
                            }
                        } else if (split[0] === 'left' || split[0] === 'right') {
                            switch (split[1]) {
                                case 'top':
                                    offset.top = position.top - actualHeight;
                                    break;
                                case 'bottom':
                                    offset.top = position.top + position.height;
                            }
                        }

                        return offset;
                    }

                    function applyPlacement(offset, placement) {
                        var tip = tipElement[0],
                            width = tip.offsetWidth,
                            height = tip.offsetHeight;

                        // manually read margins because getBoundingClientRect includes difference
                        var marginTop = parseInt($enDimensions.css(tip, 'margin-top'), 10),
                            marginLeft = parseInt($enDimensions.css(tip, 'margin-left'), 10);

                        // we must check for NaN for ie 8/9
                        if (isNaN(marginTop)) marginTop = 0;
                        if (isNaN(marginLeft)) marginLeft = 0;

                        offset.top = offset.top + marginTop;
                        offset.left = offset.left + marginLeft;

                        // $enDimensions setOffset doesn't round pixel values
                        // so we use setOffset directly with our own function
                        $enDimensions.setOffset(tip, angular.extend({
                            using: function(props) {
                                tipElement.css({
                                    top: Math.round(props.top) + 'px',
                                    left: Math.round(props.left) + 'px',
                                    right: ''
                                });
                            }
                        }, offset), 0);

                        // check to see if placing tip in new offset caused the tip to resize itself
                        var actualWidth = tip.offsetWidth,
                            actualHeight = tip.offsetHeight;

                        if (placement === 'top' && actualHeight !== height) {
                            offset.top = offset.top + height - actualHeight;
                        }

                        // If it's an exotic placement, exit now instead of
                        // applying a delta and changing the arrow
                        if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;

                        var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);

                        // Fix for incorrect offset calculations
                        if (/top|bottom/.test(placement)) {
                            var deltaSign = (delta.left) ? -1: 1;
                            if (Math.abs(delta.left) > actualWidth / 2) {
                                delta.left = deltaSign * actualWidth / 2.5;
                            }
                        }

                        if (delta.left) {
                            offset.left += delta.left;
                        } else {
                            offset.top += delta.top;
                        }

                        $enDimensions.setOffset(tip, offset);

                        if (/top|right|bottom|left/.test(placement)) {
                            var isVertical = /top|bottom/.test(placement),
                                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,
                                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';

                            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);
                        }
                    }

                    function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {
                        var delta = {
                                top: 0,
                                left: 0
                            },
                            $viewport = options.viewport && findElement(options.viewport.selector || options.viewport);

                        if (!$viewport) {
                            return delta;
                        }

                        var viewportPadding = options.viewport && options.viewport.padding || 0,
                            viewportDimensions = getPosition($viewport);

                        if (/right|left/.test(placement)) {
                            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll,
                                bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;
                            if (topEdgeOffset < viewportDimensions.top) { // top overflow
                                delta.top = viewportDimensions.top - topEdgeOffset;
                            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
                                delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
                            }
                        } else {
                            var leftEdgeOffset = position.left - viewportPadding,
                                rightEdgeOffset = position.left + viewportPadding + actualWidth;
                            if (leftEdgeOffset < viewportDimensions.left) { // left overflow
                                delta.left = viewportDimensions.left - leftEdgeOffset;
                            } else if (rightEdgeOffset > (viewportDimensions.width + viewportDimensions.left))  { // right overflow
                                delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
                            }
                        }
                        return delta;
                    }

                    function replaceArrow(delta, dimension, isHorizontal) {
                        var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);

                        $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
                            .css(isHorizontal ? 'top' : 'left', '');
                    }

                    function destroyTipElement() {
                        // Cancel pending callbacks
                        clearTimeout(timeout);

                        if ($tooltip.$isShown && tipElement !== null) {
                            if (options.autoClose) {
                                unbindAutoCloseEvents();
                            }

                            if (options.keyboard) {
                                unbindKeyboardEvents();
                            }
                        }

                        if (tipScope) {
                            tipScope.$destroy();
                            tipScope = null;
                        }

                        if (tipElement) {
                            tipElement.remove();
                            tipElement = $tooltip.$element = null;
                        }
                    }

                    return $tooltip;

                }

                // Helper functions

                function safeDigest(scope) {
                    scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();
                }

                function findElement(query, element) {
                    return angular.element((element || document).querySelectorAll(query));
                }

                var fetchPromises = {};

                function fetchTemplate(template) {
                    if (fetchPromises[template]) return fetchPromises[template];
                    return (fetchPromises[template] = $http.get(template, {
                        cache: $templateCache
                    }).then(function(res) {
                        return res.data;
                    }));
                }

                return TooltipFactory;
        }];
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
// ---- Angular Hammer ----

// Copyright (c) 2014 Ryan S Mullins <ryan@ryanmullins.org>
// Licensed under the MIT Software License

// THIS SCRIPT WAS MODIFIED TO FIT ENSPIRE UI NEEDS

(function (window, angular, Hammer) {
    'use strict';

    /**
     * Mapping of the gesture event names with the Angular attribute directive
     * names. Follows the form: <directiveName>:<eventName>.
     *
     * @type {Array}
     */
    var gestureTypes = [
        'enCustom:custom',
        'enSwipe:swipe',
        'enSwipeleft:swipeleft',
        'enSwiperight:swiperight',
        'enSwipeup:swipeup',
        'enSwipedown:swipedown',
        'enPan:pan',
        'enPanstart:panstart',
        'enPanmove:panmove',
        'enPanend:panend',
        'enPancancel:pancancel',
        'enPanleft:panleft',
        'enPanright:panright',
        'enPanup:panup',
        'enPandown:pandown',
        'enPress:press',
        'enPressup:pressup',
        'enRotate:rotate',
        'enRotatestart:rotatestart',
        'enRotatemove:rotatemove',
        'enRotateend:rotateend',
        'enRotatecancel:rotatecancel',
        'enPinch:pinch',
        'enPinchstart:pinchstart',
        'enPinchmove:pinchmove',
        'enPinchend:pinchend',
        'enPinchcancel:pinchcancel',
        'enPinchin:pinchin',
        'enPinchout:pinchout',
        'enTap:tap',
        'enClick:tap',
        'enDoubletap:doubletap'
    ];


    /**
     * Iterates through each gesture type mapping and creates a directive for
     * each of the
     *
     * @param  {String} type Mapping in the form of <directiveName>:<eventName>
     * @return None
     */
    angular.forEach(gestureTypes, function (type) {
        var directive = type.split(':'),
            directiveName = directive[0],
            eventName = directive[1];

        angular.module('enspire.ui.components.touch')
            .directive(directiveName, ['$parse', '$window', function ($parse, $window) {
            return {
                'restrict' : 'A',
                'link' : function (scope, element, attrs) {

                    // Check for Hammer and required functionality
                    // If no Hammer, maybe bind tap and doubletap to click and dblclick

                    if (!Hammer || !$window.addEventListener) {
                        console.warn('no HammerJS found!');
                        if (directiveName === 'enTap') {
                            element.bind('click', handler);
                        }

                        if (directiveName === 'enDoubletap') {
                            element.bind('dblclick', handler);
                        }

                        return;
                    }

                    var hammer = element.data('hammer'),
                        managerOpts = angular.fromJson(attrs.enManagerOptions),
                        recognizerOpts = angular.fromJson(attrs.enRecognizerOptions);


                    // Check for a manager, make one if needed and destroy it when
                    // the scope is destroyed

                    if (!hammer) {
                        hammer = propagating(new Hammer.Manager(element[0], managerOpts));
                        element.data('hammer', hammer);
                        scope.$on('$destroy', function () {
                            hammer.destroy();
                        });
                    }

                    // Instantiate the handler

                    var handlerName = attrs[directiveName],
                        handlerExpr = $parse(handlerName),
                        handler = function (event) {
                            var phase = scope.$root.$$phase,
                                recognizer = hammer.get(event.type);

                            event.element = element;

                            if (recognizer) {
                                if (recognizer.options.preventDefault) {
                                    event.preventDefault();
                                }

                                if (recognizer.options.stopPropagation) {
                                    event.srcEvent.stopPropagation();
                                }
                            }

                            if (phase === '$apply' || phase === '$digest') {
                                callHandler();
                            } else {
                                scope.$apply(callHandler);
                            }

                            function callHandler () {
                                var fn = handlerExpr(scope, {'$event':event});

                                if (typeof fn === 'function') {
                                    fn.call(scope, event);
                                }
                            }
                        };

                    // Setting up the recognizers based on the supplied options

                    if (angular.isArray(recognizerOpts)) {
                        // The recognizer options may be stored in an array. In this
                        // case, Angular Hammer iterates through the array of options
                        // trying to find an occurrence of the options.type in the event
                        // name. If it find the type in the event name, it applies those
                        // options to the recognizer for events with that name. If it
                        // does not find the type in the event name it moves on.

                        angular.forEach(recognizerOpts, function (options) {
                            if (directiveName === 'enCustom') {
                                eventName = options.event;
                            } else {
                                if (!options.type) {
                                    options.type = getRecognizerTypeFromeventName(eventName);
                                }

                                if (options.event) {
                                    delete options.event;
                                }
                            }

                            if (directiveName === 'enCustom' ||
                                eventName.indexOf(options.type) > -1) {
                                setupRecognizerWithOptions(
                                    hammer,
                                    applyManagerOptions(managerOpts, options),
                                    element);
                            }
                        });
                    } else if (angular.isObject(recognizerOpts)) {
                        // Recognizer options may be stored as an object. In this case,
                        // Angular Hammer checks to make sure that the options type
                        // property is found in the event name. If the options are
                        // designated for this general type of event, Angular Hammer
                        // applies the options directly to the manager instance for
                        // this element.

                        if (directiveName === 'enCustom') {
                            eventName = recognizerOpts.event;
                        } else {
                            if (!recognizerOpts.type) {
                                recognizerOpts.type = getRecognizerTypeFromeventName(eventName);
                            }

                            if (recognizerOpts.event) {
                                delete recognizerOpts.event;
                            }
                        }

                        if (directiveName === 'enCustom' ||
                            eventName.indexOf(recognizerOpts.type) > -1) {
                            setupRecognizerWithOptions(
                                hammer,
                                applyManagerOptions(managerOpts, recognizerOpts),
                                element);
                        }
                    } else if (directiveName !== 'enCustom') {
                        // If no options are supplied, or the supplied options do not
                        // match any of the above conditions, Angular Hammer sets up
                        // the default options that a manager instantiated using
                        // Hammer() would have.

                        recognizerOpts = {
                            'type': getRecognizerTypeFromeventName(eventName)
                        };

                        if (directiveName === 'enDoubletap') {
                            recognizerOpts.event = eventName;
                            recognizerOpts.taps = 2;

                            if (hammer.get('tap')) {
                                recognizerOpts.recognizeWith = 'tap';
                            }
                        }

                        if (recognizerOpts.type.indexOf('pan') > -1 &&
                            hammer.get('swipe')) {
                            recognizerOpts.recognizeWith = 'swipe';
                        }

                        if (recognizerOpts.type.indexOf('pinch') > -1 &&
                            hammer.get('rotate')) {
                            recognizerOpts.recognizeWith = 'rotate';
                        }

                        setupRecognizerWithOptions(
                            hammer,
                            applyManagerOptions(managerOpts, recognizerOpts),
                            element);
                    } else {
                        eventName = null;
                    }

                    if (eventName) {
                        hammer.on(eventName, handler);
                    }
                }
            };
        }]);
    });

    // ---- Private Functions -----

    /**
     * Adds a gesture recognizer to a given manager. The type of recognizer to
     * add is determined by the value of the options.type property.
     *
     * @param {Object}  manager Hammer.js manager object assigned to an element
     * @param {String}  type    Options that define the recognizer to add
     * @return {Object}         Reference to the new gesture recognizer, if
     *                          successful, null otherwise.
     */
    function addRecognizer (manager, type) {
        if (manager === undefined || type === undefined) { return null; }

        var recognizer;

        if (type.indexOf('pan') > -1) {
            recognizer = new Hammer.Pan();
        } else if (type.indexOf('pinch') > -1) {
            recognizer = new Hammer.Pinch();
        } else if (type.indexOf('press') > -1) {
            recognizer = new Hammer.Press();
        } else if (type.indexOf('rotate') > -1) {
            recognizer = new Hammer.Rotate();
        } else if (type.indexOf('swipe') > -1) {
            recognizer = new Hammer.Swipe();
        } else {
            recognizer = new Hammer.Tap();
        }

        manager.add(recognizer);
        return recognizer;
    }

    /**
     * Applies certain manager options to individual recognizer options.
     *
     * @param  {Object} managerOpts    Manager options
     * @param  {Object} recognizerOpts Recognizer options
     * @return None
     */
    function applyManagerOptions (managerOpts, recognizerOpts) {
        if (managerOpts) {
            recognizerOpts.preventGhosts = managerOpts.preventGhosts;
        }

        return recognizerOpts;
    }

    /**
     * Extracts the type of recognizer that should be instantiated from a given
     * event name. Used only when no recognizer options are provided.
     *
     * @param  {String} eventName Name to derive the recognizer type from
     * @return {string}           Type of recognizer that fires events with that name
     */
    function getRecognizerTypeFromeventName (eventName) {
        if (eventName.indexOf('pan') > -1) {
            return 'pan';
        } else if (eventName.indexOf('pinch') > -1) {
            return 'pinch';
        } else if (eventName.indexOf('press') > -1) {
            return 'press';
        } else if (eventName.indexOf('rotate') > -1) {
            return 'rotate';
        } else if (eventName.indexOf('swipe') > -1) {
            return 'swipe';
        } else {
            return 'tap';
        }
    }

    /**
     * Applies the passed options object to the appropriate gesture recognizer.
     * Recognizers are created if they do not already exist. See the README for a
     * description of the options object that can be passed to this function.
     *
     * @param  {Object} manager Hammer.js manager object assigned to an element
     * @param  {Object} options Options applied to a recognizer managed by manager
     * @return None
     */
    function setupRecognizerWithOptions (manager, options, element) {
        if (manager == null || options == null || options.type == null) {
            return console.error('ERROR: Angular Hammer could not setup the' +
            ' recognizer. Values of the passed manager and options: ', manager, options);
        }

        var recognizer = manager.get(options.type);

        if (!recognizer) {
            recognizer = addRecognizer(manager, options.type);
        }

        if (!options.directions) {
            if (options.type === 'pan' || options.type === 'swipe') {
                options.directions = 'DIRECTION_ALL';
            } else if (options.type.indexOf('left') > -1) {
                options.directions = 'DIRECTION_LEFT';
            } else if (options.type.indexOf('right') > -1) {
                options.directions = 'DIRECTION_RIGHT';
            } else if (options.type.indexOf('up') > -1) {
                options.directions = 'DIRECTION_UP';
            } else if (options.type.indexOf('down') > -1) {
                options.directions = 'DIRECTION_DOWN';
            } else {
                options.directions = '';
            }
        }

        options.direction = parseDirections(options.directions);
        recognizer.set(options);

        if (typeof options.recognizeWith === 'string') {
            var recognizeWithRecognizer;

            if (manager.get(options.recognizeWith) == null){
                recognizeWithRecognizer = addRecognizer(manager, {type:options.recognizeWith});
            }

            if (recognizeWithRecognizer != null) {
                recognizer.recognizeWith(recognizeWithRecognizer);
            }
        }

        if (typeof options.dropRecognizeWith  === 'string' &&
            manager.get(options.dropRecognizeWith) != null) {
            recognizer.dropRecognizeWith(manager.get(options.dropRecognizeWith));
        }

        if (typeof options.requireFailure  === 'string') {
            var requireFailureRecognizer;

            if (manager.get(options.requireFailure) == null){
                requireFailureRecognizer = addRecognizer(manager, {type:options.requireFailure});
            }

            if (requireFailureRecognizer != null) {
                recognizer.requireFailure(requireFailureRecognizer);
            }
        }

        if (typeof options.dropRequireFailure === 'string' &&
            manager.get(options.dropRequireFailure) != null) {
            recognizer.dropRequireFailure(manager.get(options.dropRequireFailure));
        }

        if (options.preventGhosts === true && element != null) {
            preventGhosts(element);
        }
    }

    /**
     * Parses the value of the directions property of any Angular Hammer options
     * object and converts them into the standard Hammer.js directions values.
     *
     * @param  {String} dirs Direction names separated by '|' characters
     * @return {Number}      Hammer.js direction value
     */
    function parseDirections (dirs) {
        var directions = 0;

        angular.forEach(dirs.split('|'), function (direction) {
            if (Hammer.hasOwnProperty(direction)) {
                directions = directions | Hammer[direction];
            }
        });

        return directions;
    }

    // ---- Preventing Ghost Clicks ----

    /**
     * Modified from: https://gist.github.com/jtangelder/361052976f044200ea17
     *
     * Prevent click events after a touchend.
     *
     * Inspired/copy-paste from this article of Google by Ryan Fioravanti
     * https://developers.google.com/mobile/articles/fast_buttons#ghost
     */

    function preventGhosts (element) {
        if (!element) { return; }

        var coordinates = [],
            threshold = 25,
            timeout = 2500;

        if ('ontouchstart' in window) {
            element[0].addEventListener('touchstart', resetCoordinates, true);
            element[0].addEventListener('touchend', registerCoordinates, true);
            element[0].addEventListener('click', preventGhostClick, true);
            element[0].addEventListener('mouseup', preventGhostClick, true);
        }

        /**
         * prevent clicks if they're in a registered XY region
         * @param {MouseEvent} ev
         */
        function preventGhostClick (ev) {
            for (var i = 0; i < coordinates.length; i++) {
                var x = coordinates[i][0];
                var y = coordinates[i][1];

                // within the range, so prevent the click
                if (Math.abs(ev.clientX - x) < threshold &&
                    Math.abs(ev.clientY - y) < threshold) {
                    ev.stopPropagation();
                    ev.preventDefault();
                    break;
                }
            }
        }

        /**
         * reset the coordinates array
         */
        function resetCoordinates () {
            coordinates = [];
        }

        /**
         * remove the first coordinates set from the array
         */
        function popCoordinates () {
            coordinates.splice(0, 1);
        }

        /**
         * if it is an final touchend, we want to register it's place
         * @param {TouchEvent} ev
         */
        function registerCoordinates (ev) {
            // touchend is triggered on every releasing finger
            // changed touches always contain the removed touches on a touchend
            // the touches object might contain these also at some browsers (firefox os)
            // so touches - changedTouches will be 0 or lower, like -1, on the final touchend
            if(ev.touches.length - ev.changedTouches.length <= 0) {
                var touch = ev.changedTouches[0];
                coordinates.push([touch.clientX, touch.clientY]);

                setTimeout(popCoordinates, timeout);
            }
        }
    }
})(window, window.angular, window.Hammer);

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.tree').directive('enTreeBranch', ComponentDirective);

    /**
     * Used internally by enTree directive
     */

    function ComponentDirective($compile, enTree, $enPopover, $parse, $timeout) {
        return {
            restrict: 'E',
            controller: 'enTreeController',
            link: function($scope, $element, $attrs, treeCtrl) {
                var childScope = $scope.$new(),
                    nodeConfig = {},
                    $branch,
                    branchLevel,
                    branchNode,
                    branchElem,
                    branchName;

                // Hide child nodes until user opens it
                childScope.node = {};
                childScope.node.open = ($scope.startExpanded) ? true: false;
                // Track node level
                childScope.node.level = function() {
                    var elem = $scope.rootTree.element[0];
                    return elem.querySelectorAll('ul.tree').length;
                }
                branchLevel = childScope.node.level();

                // Set scope values for new branch
                childScope.$branch = $parse($attrs.object)($scope);
                $branch = childScope.$branch;
                // Set branch node name
                nodeConfig.nodeChildren = $scope.nodeChildren;

                 // Read Only - Exposed For User Convenience

                 // Set value for branch label
                $branch.$label = function(label) {
                    // return current label
                    if (!label) {
                        return $branch[ $scope.nodeLabel ];
                    }
                    // update label
                    $branch[ $scope.nodeLabel ] = label;
                }
                // Set if branch is open
                $branch.$isOpen = function() {
                    return childScope.node.open;
                }
                // Set if branch has children
                $branch.$hasChildren = function() {
                    return $branch[ nodeConfig.nodeChildren ] && !!$branch[ nodeConfig.nodeChildren ].length;
                }


                // Open the branch and show children
                $branch.$open = function() {
                    childScope.node.open = true;
                }
                // Close the branch and hide children
                $branch.$close = function() {
                    childScope.node.open = false;
                }
                // Toggle branch
                $branch.$toggle = function() {
                    childScope.node.open = !childScope.node.open;
                }
                // Keep reference to parent object so we can perform CRUD operations
                $branch.$parent = function(){
                    return $parse($attrs.parent)($scope);
                };
                // Add common helper functions
                // Add item to collection
                $branch.$add = function(newChild, insertBefore, addChild) {
                    var parent = this,
                        oldChild = this;

                       // Get correct parent if adding child node
                       if (!addChild) {
                           parent = this.$parent();
                       }
                       // Add node to parent
                       enTree.add(nodeConfig, parent, oldChild, newChild, insertBefore);
                       // Open new node
                       parent.$open && parent.$open();
                };
                // Delete an item from the collection
                $branch.$delete = function() {
                       var child = this,
                           parent = this.$parent();
                       enTree.delete(nodeConfig, parent, child);
                };
                // Ability to access childScope (used internally)
                $branch.$scope = function() {
                    return childScope;
                }

                // Insert branch template
                branchNode = $scope.branchTpl.replace('{{branchNode}}', $scope.branchNodeTpl);
                // Wrap branch to compile on single root node.
                branchNode = '<div class="en-tree-branch" ng-class="{\'has-children\': $branch[nodeChildren] && $branch[nodeChildren].length}">' + branchNode + '</div>';
                // Append branchNode
                branchElem = $element.parent().append( $compile(branchNode)(childScope) );
                // set branch level attribute
                branchElem.parent().attr('branch-level', branchLevel);

                // Get reference to branch name
                branchName = angular.element( branchElem[0].querySelector('.branch-name') );

                // Find if is root node
                $branch.$isRoot = function() {
                    // Notify if it's root element
                    console.log('branchElem.parent()', branchElem.parent());
                    var branchLevel = branchElem.parent()[0].getAttribute('branch-level');
                    return (branchLevel === 1) ? true: false;
                }

                // Not necessary but would like to replace custom element
                // with just class on div
                $element.remove();

                // Ensure new child scope gets destroyed
                $scope.$on('$destroy', function(){
                      childScope.$destroy();
                      childScope = undefined;
                });


                // Everything below is enabling built-in click events
                // rather than wrap in long if just returning early
                if ($scope.disableClickEvents && !$scope.partialClick) {
                    return;
                }

                // Toggle branch open & close
                branchName.on('click', function(e) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    $timeout(function(){
                        var prevSelectedBranch = $scope.rootTree.prevSelectedBranch;
                        $branch.$toggle();
                        // update selected item
                        if ( $scope.selectedItem ) {
                            $scope.rootTree.scope.$parent.$eval( $scope.selectedItem + '= context', {'context': $branch});
                        }
                        // Unselect previous item
                        if (prevSelectedBranch) {
                            prevSelectedBranch.branch.isSelected = false;
                        }
                        // Select current item
                        $branch.isSelected = true;
                        $scope.rootTree.prevSelectedBranch = {
                            'branch': $branch
                        };
                    });
                });

                // Show menu on right-click
                branchName.on('contextmenu', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    document.body.click();

                    childScope.node.contextMenu = $enPopover( branchName, {
                        scope: childScope,
                        animation: '',
                        inlineTemplate: true,
                        viewport: {selector:'en-win-body'},
                        customClass: 'popover-dark',
                        content: '<div class="context-menu">' + $scope.contextMenuTpl + '</div>',
                        autoClose: true,
                        html: true,
                        placement: 'auto'
                    });

                    $branch.$closeMenu = function() {
                        var contextMenu = childScope.node.contextMenu;
                        contextMenu.hide();
                        contextMenu.destroy();
                        contextMenu = undefined;
                    }

                    $timeout(function(){
                        childScope.node.contextMenu.show();
                    }, 100);

                    return false;
                });


            }
        }
    }
    ComponentDirective.$inject = ["$compile", "enTree", "$enPopover", "$parse", "$timeout"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.tree').controller('enTreeController', ComponentController);

    /**
     * Used interally by enTree directive.
     * Built-in scope actions.
     * The user of this directive can provide their own or fallback to built-in actions.
     */

    function ComponentController($scope, $element, $attrs) {
        // Built-in scope actions, user of directive can provide their
        // own or fallback to built-in actions.

        var self = this;

        /**
         * Deletes a branch from the tree. Example function
         * on the local scope.
         *
         * @param {object} branch - Passed in from ng-click
         */
        $scope.$$delete = function($branch) {
            // Accessing built-in $$delete function
            // the directive provides to each branch of tree.
            $branch.$delete();
            // Close context menu
            $branch.$closeMenu();
        };

        /**
         * Adds a branch to the tree. Example function
         * on the local scope.
         *
         * @param {object}  branch   - Passed in from ng-click
         * @param {boolean} addChild - Optional. Set in ng-click event.
         *                             Truthy value adds child to branch.
         */
        $scope.$$add = function($branch, addChild) {
            var branchName = prompt('Branch name?'),
                newBranch = {},
                isRoot = $branch.$isRoot(),
                $parent;

            newBranch[ $scope.nodeLabel ] = branchName;

            // Accessing built-in $$add function
            // the directive provides to each branch of tree.
            if (!isRoot) {
                $branch.$add(newBranch, false, addChild);
            }
            else {
                $parent = $branch.$parent();
                $parent.push(newBranch);
            }
            // Close context menu
            $branch.$closeMenu();
        };

        /**
         * Edits name of tree.
         *
         * @param {object}  branch   - Passed in from ng-click
         *
         */
        $scope.$$edit = function($branch) {
            var branchName = prompt('Enter new name?', $branch.$label());
            $branch[ $scope.nodeLabel ] = branchName;
            // Close context menu
            $branch.$closeMenu();
        }
    }
    ComponentController.$inject = ["$scope", "$element", "$attrs"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.tree').directive('enTree', ComponentDirective);

    /**
     * @ngdoc directive
     * @name enTree
     * @module enspire.ui.components.tree
     * @restrict E
     * @description
     * A flexible tree component. By default right-clicking displays context menu, this behavior can be disabled.
     *
     * @param {object} [ng-model= ] The model object that sets the value of the tree.
     * @param {boolean=} [disable-click-events=false] If set to true, disables built-in click events and bindings.
     * @param {boolean=} [partial-click=true] If set to true, handles the toggling of the branchNode.
     * @param {object=} [selected-item= ] Object or model to update when a branch is selected.
     * @param {string=} [node-children= ] Property name of the object that contains the child nodes.
     * @param {string=} [node-label= ] Property name of the object that contains the branch label/ name.
     * @param {boolen=} [start-expanded=false] If set to `true` loads the tree with all branches open.
     *
     *
     *
     * @usage
     * ### Use Default Template &amp; Actions
     * <hljs lang="html">
     *   <en-tree ng-model="someModel" theme="default"></en-tree>
     * </hljs>
     *
     *
     *
     * ### Use Custom Branch Template
     * <hljs lang="html">
     *   <en-tree ng-model="someModel">
     *       <!-- Set custom branch node template -->
     *       <branch-node>
     *           <div ng-bind="$branch.$label()"></div>
     *       </branch-node>
     *   </en-tree>
     * </hljs>
     *
     *
     *
     * ### Roll everything manually (template &amp; actions)
     * <hljs lang="html">
     *   <en-tree ng-model="someModel" disable-click-events="true">
     *       <branch-node>
     *           <div ng-bind="$branch.$label()"></div>
     *           <!-- Other custom HTML -->
     *       </branch-node>
     *   </en-tree>
     * </hljs>
     *
     *
     * ## Elements
     *
     * Name            | Type           | Description
     * :---------------|:---------------|:---------------------------------------------------
     * branch-node  | *HTML Element* | HTML tag that wraps the template to use for branch node.
     * context-menu    | *HTML Element* | HTML tag that wraps the template to use for context menu pop-up.
     *
     *
     * ### FAQ.
     *
     * #### Q. How do I style the context-menu differently without writing my own CRUD functions?
     *
     * **Answer**:
     * Just add a `<context-menu>` tag inside the `<en-tree>` directive. Be sure to keep the
     * `ng-click` attributes values the same. Feel free to alter the HTML to your liking.
     *
     * <hljs lang="html">
     *  <en-tree ng-model="someModel">
     *     <context-menu>
     *         <!-- Some Custom HTML etc. -->
     *         <input type="button" ng-click="$$add($branch)"       value="Add Category" />
     *         <input type="button" ng-click="$$add($branch, true)" value="Add Sub Category" />
     *         <input type="button" ng-click="$$edit($branch)"      value="Edit Category" />
     *         <input type="button" ng-click="$$delete($branch)"    value="Delete" />
     *     </context-menu>
     *  </en-tree>
     * </hljs>
     *
     *
     *
     *
     * #### Q. Can I alter the design of the tree?
     *
     * **Answer**:
     * Yes. First insert `<branch-node>` and `<context-menu>` tags inside the `<en-tree>` directive. Then
     * add your own custom HTML to those two tags.
     *
     * <hljs lang="html">
     *   <en-tree ng-model="someModel">
     *       <!-- Set custom branch node template -->
     *       <branch-node>
     *           <div ng-bind="$branch.$label()"></div>
     *       </branch-node>
     *
     *       <!-- Set custom context-menu -->
     *       <context-menu>
     *          <en-button ng-click="$branch.$delete()">Delete</en-button>
     *          <en-button ng-click="customFn($branch)">Action</en-button>
     *       </context-menu>
     *   </en-tree>
     * </hljs>
     *
     *
     *
     *
     * #### Q. What are the built-in properties and functions available to me?
     *
     * **Answer**:
     *
     * Name                | Type           | Description
     * :-------------------|:---------------|:---------------------------------------------------
     * $branch             | *Object*       | Branch object.
     * $branch.$add        | *Function*     | Adds a new branch to the tree. **See below.**
     * $branch.$delete     | *Function*     | Deletes a new branch from the tree.
     * $branch.$open       | *Function*     | Opens the branch to reveal any sub items / children.
     * $branch.$close      | *Function*     | Closes the branch hiding any sub items / children.
     * $branch.$toggle     | *Function*     | Toggles the branch open or close.
     * $branch.$isOpen     | *Function*     | Returns boolean. Indicates if branch is open or closed.
     * $branch.$hasChildren| *Function*     | Returns boolean. Indicates if branch has sub items / children.
     * $branch.$label      | *Function*     | If passed a string sets branch label, otherwise returns the display name / label of the branch.
     *
     *<br />
     *<br />
     * #### $branch.add( newChild, insertBefore, addChild )
     * - &commat;param {object}  **newChild**     - New object to add to tree.
     * - &commat;param {boolean} **insertBefore** - Whether to add the new object above or below relative $branch object. Defaults to false, which is after.
     * - &commat;param {boolean} **addChild**     - If set to `true` adds new branch as a child item. Otherwise adds as sibling relative to $branch object.
     *
     *<br />
     *<br />
     * #### $branch.$label( newLabel )
     * - &commat;param {string}  **newLabel** - If passed a string will updated the branch label. Otherwise returns value of current branch label.
     *
     *<br />
     *<br />
     * **Note**: None of the other functions take parameters, and operates on the current $branch object.
     */

    function ComponentDirective($compile, enTree, $parse, $templateCache) {
        return {
            scope: true,
            restrict: 'E',
            require: 'ngModel',
            controller: 'enTreeController',
            compile: function($element, $attrs) {
               var elem = $element[0],
                   branchNodeTpl = elem.querySelector('branch-node'),
                   contextMenuTpl = elem.querySelector('context-menu'),
                   branchNode;

                // Store branch node template if defined
                if ( branchNodeTpl ) {
                    branchNodeTpl = angular.element( branchNodeTpl ).remove();
                }

                // Store context menu if defined
                if ( contextMenuTpl ) {
                    contextMenuTpl = angular.element( contextMenuTpl ).remove();
                }

                return {
                    post: function($scope, $element, $attrs, ngModel) {
                        var bodyTpl, offWatchModel;

                        // Track branch levels
                        $scope.nodeLevel = 1;

                        // Internal templates used by directive
                        $scope.branchTpl = $templateCache.get('enTree/branch.html');
                        bodyTpl = $templateCache.get('enTree/tree.html');

                        // User defined templates to grab from directive
                        $scope.branchNodeTpl = branchNodeTpl ? branchNodeTpl.html(): $templateCache.get('enTree/branch-node.html');
                        $scope.contextMenuTpl = contextMenuTpl ? contextMenuTpl.html()  : $templateCache.get('enTree/context-menu.html');

                        // Should we enable built-in click events
                        // or will user roll their own?
                        $scope.disableClickEvents = ($attrs.disableClickEvents === undefined) ? false: $parse( $attrs.disableClickEvents )($scope);

                        // Allow partial click events
                        $scope.partialClick = ($attrs.partialClick === undefined) ? true: $parse( $attrs.partialClick)($scope);

                        // Set branch node name to use to iterate through child nodes
                        $scope.nodeChildren = $attrs.nodeChildren || 'items';
                        $scope.nodeLabel = $attrs.nodeLabel || 'name';

                        // Load fully expanded
                        $scope.startExpanded  = $parse( $attrs.startExpanded )($scope);

                        // Watching for changes to model
                        offWatchModel = $scope.$watchCollection($attrs.ngModel, function(newVal){
                            if (newVal) $scope.branches = newVal;
                        });

                        // Insert tree body into the DOM
                        $element.append( $compile(bodyTpl)($scope) );

                        // Clean up scope
                        $scope.$on('$destroy', function(){
                           offWatchModel();
                           enTree.scope = null;
                        });

                        // Store reference to $scope for internal use
                        $scope.rootTree = {
                            'scope': $scope,
                            'element': $element
                        };

                        // Store reference to update 'selectedItem' attribute on branch selection
                        $scope.selectedItem = $attrs.selectedItem;
                    }
                }
            }
        }
    }
    ComponentDirective.$inject = ["$compile", "enTree", "$parse", "$templateCache"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.tree').provider('enTree', ComponentService);

    /**
     * Used interally by enTree directive.
     */

    function ComponentService() {

        this.$get = function() {

            /**
             * Add item to the parent collection
             *
             * @param {object}  parent       - Parent collection
             * @param {object}  oldChild     - Old child object
             * @param {object}  newChild     - New child object to add
             * @param {boolean} insertBefore - Whether to position the object before or after.
             *                                 Defaults to false which is after.
             */
            function addItem(nodeConfig, parent, oldChild, newChild, insertBefore) {
                  var nodeChildren = nodeConfig.nodeChildren,
                      position,
                      collection,
                      index;

                if (insertBefore === undefined) {
                    position = 1;
                }
                position = (insertBefore) ? 0: 1;

                collection = parent[nodeChildren] || parent;

                if (!collection.indexOf) {
                    parent[nodeChildren] = [];
                    collection = parent[nodeChildren];
                }

                index = (~collection.indexOf(oldChild)) ? collection.indexOf(oldChild): 0;

                // Add item to collection
                collection.splice(index + position, 0, newChild);
            }

            /**
             * Remove item from the parent collection
             *
             * @param {object}  parent       - Parent collection
             * @param {object}  child        - Child object to add
             */
            function deleteItem(nodeConfig, parent, child) {
                var nodeChildren = nodeConfig.nodeChildren,
                    collection = parent[nodeChildren] || parent,
                    index = collection.indexOf(child);

                // Remove item from collection
                collection.splice(index, 1);
            }

            return {
                'add': addItem,
                'delete': deleteItem
            }
        }
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * @ngdoc module
 * @name material.components.virtualRepeat
 */
angular.module('enspire.ui.components.virtualRepeat', [
  'enspire.ui.core'
])
.directive('mdVirtualRepeatContainer', VirtualRepeatContainerDirective)
.directive('mdVirtualRepeat', VirtualRepeatDirective);


/**
 * @ngdoc directive
 * @name mdVirtualRepeatContainer
 * @module material.components.virtualRepeat
 * @restrict E
 * @description
 * `md-virtual-repeat-container` provides the scroll container for md-virtual-repeat.
 *
 * Virtual repeat is a limited substitute for ng-repeat that renders only
 * enough dom nodes to fill the container and recycling them as the user scrolls.
 *
 * @usage
 * <hljs lang="html">
 *
 * <md-virtual-repeat-container md-top-index="topIndex">
 *   <div md-virtual-repeat="i in items" md-item-size="20">Hello {{i}}!</div>
 * </md-virtual-repeat-container>
 * </hljs>
 *
 * @param {number=} md-top-index Binds the index of the item that is at the top of the scroll
 *     container to $scope. It can both read and set the scroll position.
 * @param {boolean=} md-orient-horizontal Whether the container should scroll horizontally
 *     (defaults to orientation and scrolling vertically).
 * @param {boolean=} md-auto-shrink When present, the container will shrink to fit
 *     the number of items when that number is less than its original size.
 * @param {number=} md-auto-shrink-min Minimum number of items that md-auto-shrink
 *     will shrink to (default: 0).
 */
function VirtualRepeatContainerDirective() {
  return {
    controller: VirtualRepeatContainerController,
    template: virtualRepeatContainerTemplate,
    compile: function virtualRepeatContainerCompile($element, $attrs) {
      $element
          .addClass('md-virtual-repeat-container')
          .addClass($attrs.hasOwnProperty('mdOrientHorizontal')
              ? 'md-orient-horizontal'
              : 'md-orient-vertical');
    }
  };
}


function virtualRepeatContainerTemplate($element) {
  return '<div class="md-virtual-repeat-scroller">' +
    '<div class="md-virtual-repeat-sizer"></div>' +
    '<div class="md-virtual-repeat-offsetter">' +
      $element[0].innerHTML +
    '</div></div>';
}

/**
 * Maximum size, in pixels, that can be explicitly set to an element. The actual value varies
 * between browsers, but IE11 has the very lowest size at a mere 1,533,917px. Ideally we could
 * *compute* this value, but Firefox always reports an element to have a size of zero if it
 * goes over the max, meaning that we'd have to binary search for the value.
 * @const {number}
 */
var MAX_ELEMENT_SIZE = 1533917;

/**
 * Number of additional elements to render above and below the visible area inside
 * of the virtual repeat container. A higher number results in less flicker when scrolling
 * very quickly in Safari, but comes with a higher rendering and dirty-checking cost.
 * @const {number}
 */
var NUM_EXTRA = 3;

/** @ngInject */
function VirtualRepeatContainerController(
    $$rAF, $mdUtil, $parse, $window, $scope, $element, $attrs) {
  this.$scope = $scope;
  this.$element = $element;
  this.$attrs = $attrs;

  /** @type {number} The width or height of the container */
  this.size = 0;
  /** @type {number} The scroll width or height of the scroller */
  this.scrollSize = 0;
  /** @type {number} The scrollLeft or scrollTop of the scroller */
  this.scrollOffset = 0;
  /** @type {boolean} Whether the scroller is oriented horizontally */
  this.horizontal = this.$attrs.hasOwnProperty('mdOrientHorizontal');
  /** @type {!VirtualRepeatController} The repeater inside of this container */
  this.repeater = null;
  /** @type {boolean} Whether auto-shrink is enabled */
  this.autoShrink = this.$attrs.hasOwnProperty('mdAutoShrink');
  /** @type {number} Minimum number of items to auto-shrink to */
  this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0;
  /** @type {?number} Original container size when shrank */
  this.originalSize = null;
  /** @type {number} Amount to offset the total scroll size by. */
  this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0;

  if (this.$attrs.mdTopIndex) {
    /** @type {function(angular.Scope): number} Binds to topIndex on Angular scope */
    this.bindTopIndex = $parse(this.$attrs.mdTopIndex);
    /** @type {number} The index of the item that is at the top of the scroll container */
    this.topIndex = this.bindTopIndex(this.$scope);

    if (!angular.isDefined(this.topIndex)) {
      this.topIndex = 0;
      this.bindTopIndex.assign(this.$scope, 0);
    }

    this.$scope.$watch(this.bindTopIndex, angular.bind(this, function(newIndex) {
      if (newIndex !== this.topIndex) {
        this.scrollToIndex(newIndex);
      }
    }));
  } else {
    this.topIndex = 0;
  }

  this.scroller = $element[0].getElementsByClassName('md-virtual-repeat-scroller')[0];
  this.sizer = this.scroller.getElementsByClassName('md-virtual-repeat-sizer')[0];
  this.offsetter = this.scroller.getElementsByClassName('md-virtual-repeat-offsetter')[0];

  // After the dom stablizes, measure the initial size of the container and
  // make a best effort at re-measuring as it changes.
  var boundUpdateSize = angular.bind(this, this.updateSize);

  $$rAF(function() {
    boundUpdateSize();

    var debouncedUpdateSize = $mdUtil.debounce(boundUpdateSize, 10, null, false);
    var jWindow = angular.element($window);

    jWindow.on('resize', debouncedUpdateSize);
    $scope.$on('$destroy', function() {
      jWindow.off('resize', debouncedUpdateSize);
    });

    $scope.$on('$md-resize', boundUpdateSize);
  });
}
VirtualRepeatContainerController.$inject = ["$$rAF", "$mdUtil", "$parse", "$window", "$scope", "$element", "$attrs"];


/** Called by the md-virtual-repeat inside of the container at startup. */
VirtualRepeatContainerController.prototype.register = function(repeaterCtrl) {
  this.repeater = repeaterCtrl;

  angular.element(this.scroller)
      .on('scroll wheel touchmove touchend', angular.bind(this, this.handleScroll_));
};


/** @return {boolean} Whether the container is configured for horizontal scrolling. */
VirtualRepeatContainerController.prototype.isHorizontal = function() {
  return this.horizontal;
};


/** @return {number} The size (width or height) of the container. */
VirtualRepeatContainerController.prototype.getSize = function() {
  return this.size;
};


/**
 * Resizes the container.
 * @private
 * @param {number} The new size to set.
 */
VirtualRepeatContainerController.prototype.setSize_ = function(size) {
  this.size = size;
  this.$element[0].style[this.isHorizontal() ? 'width' : 'height'] = size + 'px';
};


/** Instructs the container to re-measure its size. */
VirtualRepeatContainerController.prototype.updateSize = function() {
  if (this.originalSize) return;

  this.size = this.isHorizontal()
      ? this.$element[0].clientWidth
      : this.$element[0].clientHeight;
  this.repeater && this.repeater.containerUpdated();
};


/** @return {number} The container's scrollHeight or scrollWidth. */
VirtualRepeatContainerController.prototype.getScrollSize = function() {
  return this.scrollSize;
};


/**
 * Sets the scroller element to the specified size.
 * @private
 * @param {number} size The new size.
 */
VirtualRepeatContainerController.prototype.sizeScroller_ = function(size) {
  var dimension =  this.isHorizontal() ? 'width' : 'height';
  var crossDimension = this.isHorizontal() ? 'height' : 'width';

  // If the size falls within the browser's maximum explicit size for a single element, we can
  // set the size and be done. Otherwise, we have to create children that add up the the desired
  // size.
  if (size < MAX_ELEMENT_SIZE) {
    this.sizer.style[dimension] = size + 'px';
  } else {
    // Clear any existing dimensions.
    this.sizer.innerHTML = '';
    this.sizer.style[dimension] = 'auto';
    this.sizer.style[crossDimension] = 'auto';

    // Divide the total size we have to render into N max-size pieces.
    var numChildren = Math.floor(size / MAX_ELEMENT_SIZE);

    // Element template to clone for each max-size piece.
    var sizerChild = document.createElement('div');
    sizerChild.style[dimension] = MAX_ELEMENT_SIZE + 'px';
    sizerChild.style[crossDimension] = '1px';

    for (var i = 0; i < numChildren; i++) {
      this.sizer.appendChild(sizerChild.cloneNode(false));
    }

    // Re-use the element template for the remainder.
    sizerChild.style[dimension] = (size - (numChildren * MAX_ELEMENT_SIZE)) + 'px';
    this.sizer.appendChild(sizerChild);
  }
};


/**
 * If auto-shrinking is enabled, shrinks or unshrinks as appropriate.
 * @private
 * @param {number} size The new size.
 */
VirtualRepeatContainerController.prototype.autoShrink_ = function(size) {
  var shrinkSize = Math.max(size, this.autoShrinkMin * this.repeater.getItemSize());
  if (this.autoShrink && shrinkSize !== this.size) {
    if (shrinkSize < (this.originalSize || this.size)) {
      if (!this.originalSize) {
        this.originalSize = this.size;
      }

      this.setSize_(shrinkSize);
    } else if (this.originalSize) {
      this.setSize_(this.originalSize);
      this.originalSize = null;
    }

    this.repeater.containerUpdated();
  }
};


/**
 * Sets the scrollHeight or scrollWidth. Called by the repeater based on
 * its item count and item size.
 * @param {number} itemsSize The total size of the items.
 */
VirtualRepeatContainerController.prototype.setScrollSize = function(itemsSize) {
  var size = itemsSize + this.offsetSize;
  if (this.scrollSize === size) return;

  this.sizeScroller_(size);
  this.autoShrink_(size);
  this.scrollSize = size;
};


/** @return {number} The container's current scroll offset. */
VirtualRepeatContainerController.prototype.getScrollOffset = function() {
  return this.scrollOffset;
};

/**
 * Scrolls to a given scrollTop position.
 * @param {number} position
 */
VirtualRepeatContainerController.prototype.scrollTo = function(position) {
  this.scroller[this.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = position;
  this.handleScroll_();
};

/**
 * Scrolls the item with the given index to the top of the scroll container.
 * @param {number} index
 */
VirtualRepeatContainerController.prototype.scrollToIndex = function(index) {
  var itemSize = this.repeater.getItemSize();
  var itemsLength = this.repeater.itemsLength;
  if(index > itemsLength) {
    index = itemsLength - 1;
  }
  this.scrollTo(itemSize * index);
};

VirtualRepeatContainerController.prototype.resetScroll = function() {
  this.scrollTo(0);
};


VirtualRepeatContainerController.prototype.handleScroll_ = function() {
  var offset = this.isHorizontal() ? this.scroller.scrollLeft : this.scroller.scrollTop;
  if (offset === this.scrollOffset) return;

  var itemSize = this.repeater.getItemSize();
  if (!itemSize) return;

  var numItems = Math.max(0, Math.floor(offset / itemSize) - NUM_EXTRA);

  var transform = this.isHorizontal() ? 'translateX(' : 'translateY(';
      transform +=  (numItems * itemSize) + 'px)';

  this.scrollOffset = offset;
  this.offsetter.style.webkitTransform = transform;
  this.offsetter.style.transform = transform;

  if (this.bindTopIndex) {
    var topIndex = Math.floor(offset / itemSize);
    if (topIndex !== this.topIndex && topIndex < this.repeater.itemsLength) {
      this.topIndex = topIndex;
      this.bindTopIndex.assign(this.$scope, topIndex);
      if (!this.$scope.$root.$$phase) this.$scope.$digest();
    }
  }

  this.repeater.containerUpdated();
};


/**
 * @ngdoc directive
 * @name mdVirtualRepeat
 * @module material.components.virtualRepeat
 * @restrict A
 * @priority 1000
 * @description
 * `md-virtual-repeat` specifies an element to repeat using virtual scrolling.
 *
 * Virtual repeat is a limited substitute for ng-repeat that renders only
 * enough dom nodes to fill the container and recycling them as the user scrolls.
 * Arrays, but not objects are supported for iteration.
 * Track by, as alias, and (key, value) syntax are not supported.
 *
 * @usage
 * <hljs lang="html">
 * <md-virtual-repeat-container>
 *   <div md-virtual-repeat="i in items">Hello {{i}}!</div>
 * </md-virtual-repeat-container>
 *
 * <md-virtual-repeat-container md-orient-horizontal>
 *   <div md-virtual-repeat="i in items" md-item-size="20">Hello {{i}}!</div>
 * </md-virtual-repeat-container>
 * </hljs>
 *
 * @param {number=} md-item-size The height or width of the repeated elements (which must be
 *   identical for each element). Optional. Will attempt to read the size from the dom if missing,
 *   but still assumes that all repeated nodes have same height or width.
 * @param {string=} md-extra-name Evaluates to an additional name to which the current iterated item
 *   can be assigned on the repeated scope (needed for use in `en-autocomplete`).
 * @param {boolean=} md-on-demand When present, treats the md-virtual-repeat argument as an object
 *   that can fetch rows rather than an array.
 *
 *   **NOTE:** This object must implement the following interface with two (2) methods:
 *
 *   - `getItemAtIndex: function(index) [object]` The item at that index or null if it is not yet
 *     loaded (it should start downloading the item in that case).
 *   - `getLength: function() [number]` The data length to which the repeater container
 *     should be sized. Ideally, when the count is known, this method should return it.
 *     Otherwise, return a higher number than the currently loaded items to produce an
 *     infinite-scroll behavior.
 */
function VirtualRepeatDirective($parse) {
  return {
    controller: VirtualRepeatController,
    priority: 1000,
    require: ['mdVirtualRepeat', '^^mdVirtualRepeatContainer'],
    restrict: 'A',
    terminal: true,
    transclude: 'element',
    compile: function VirtualRepeatCompile($element, $attrs) {
      var expression = $attrs.mdVirtualRepeat;
      var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/);
      var repeatName = match[1];
      var repeatListExpression = $parse(match[2]);
      var extraName = $attrs.mdExtraName && $parse($attrs.mdExtraName);

      return function VirtualRepeatLink($scope, $element, $attrs, ctrl, $transclude) {
        ctrl[0].link_(ctrl[1], $transclude, repeatName, repeatListExpression, extraName);
      };
    }
  };
}
VirtualRepeatDirective.$inject = ["$parse"];


/** @ngInject */
function VirtualRepeatController($scope, $element, $attrs, $browser, $document, $$rAF) {
  this.$scope = $scope;
  this.$element = $element;
  this.$attrs = $attrs;
  this.$browser = $browser;
  this.$document = $document;
  this.$$rAF = $$rAF;

  /** @type {boolean} Whether we are in on-demand mode. */
  this.onDemand = $attrs.hasOwnProperty('mdOnDemand');
  /** @type {!Function} Backup reference to $browser.$$checkUrlChange */
  this.browserCheckUrlChange = $browser.$$checkUrlChange;
  /** @type {number} Most recent starting repeat index (based on scroll offset) */
  this.newStartIndex = 0;
  /** @type {number} Most recent ending repeat index (based on scroll offset) */
  this.newEndIndex = 0;
  /** @type {number} Most recent end visible index (based on scroll offset) */
  this.newVisibleEnd = 0;
  /** @type {number} Previous starting repeat index (based on scroll offset) */
  this.startIndex = 0;
  /** @type {number} Previous ending repeat index (based on scroll offset) */
  this.endIndex = 0;
  // TODO: measure width/height of first element from dom if not provided.
  // getComputedStyle?
  /** @type {?number} Height/width of repeated elements. */
  this.itemSize = $scope.$eval($attrs.mdItemSize) || null;

  /** @type {boolean} Whether this is the first time that items are rendered. */
  this.isFirstRender = true;

  /**
   * @private {boolean} Whether the items in the list are already being updated. Used to prevent
   *     nested calls to virtualRepeatUpdate_.
   */
  this.isVirtualRepeatUpdating_ = false;

  /** @type {number} Most recently seen length of items. */
  this.itemsLength = 0;

  /**
   * @type {!Function} Unwatch callback for item size (when md-items-size is
   *     not specified), or angular.noop otherwise.
   */
  this.unwatchItemSize_ = angular.noop;

  /**
   * Presently rendered blocks by repeat index.
   * @type {Object<number, !VirtualRepeatController.Block}
   */
  this.blocks = {};
  /** @type {Array<!VirtualRepeatController.Block>} A pool of presently unused blocks. */
  this.pooledBlocks = [];
}
VirtualRepeatController.$inject = ["$scope", "$element", "$attrs", "$browser", "$document", "$$rAF"];


/**
 * An object representing a repeated item.
 * @typedef {{element: !jqLite, new: boolean, scope: !angular.Scope}}
 */
VirtualRepeatController.Block;


/**
 * Called at startup by the md-virtual-repeat postLink function.
 * @param {!VirtualRepeatContainerController} container The container's controller.
 * @param {!Function} transclude The repeated element's bound transclude function.
 * @param {string} repeatName The left hand side of the repeat expression, indicating
 *     the name for each item in the array.
 * @param {!Function} repeatListExpression A compiled expression based on the right hand side
 *     of the repeat expression. Points to the array to repeat over.
 * @param {string|undefined} extraName The optional extra repeatName.
 */
VirtualRepeatController.prototype.link_ =
    function(container, transclude, repeatName, repeatListExpression, extraName) {
  this.container = container;
  this.transclude = transclude;
  this.repeatName = repeatName;
  this.rawRepeatListExpression = repeatListExpression;
  this.extraName = extraName;
  this.sized = false;

  this.repeatListExpression = angular.bind(this, this.repeatListExpression_);

  this.container.register(this);
};


/** @private Attempts to set itemSize by measuring a repeated element in the dom */
VirtualRepeatController.prototype.readItemSize_ = function() {
  if (this.itemSize) {
    // itemSize was successfully read in a different asynchronous call.
    return;
  }

  this.items = this.repeatListExpression(this.$scope);
  this.parentNode = this.$element[0].parentNode;
  var block = this.getBlock_(0);
  if (!block.element[0].parentNode) {
    this.parentNode.appendChild(block.element[0]);
  }

  this.itemSize = block.element[0][
      this.container.isHorizontal() ? 'offsetWidth' : 'offsetHeight'] || null;

  this.blocks[0] = block;
  this.poolBlock_(0);

  if (this.itemSize) {
    this.containerUpdated();
  }
};


/**
 * Returns the user-specified repeat list, transforming it into an array-like
 * object in the case of infinite scroll/dynamic load mode.
 * @param {!angular.Scope} The scope.
 * @return {!Array|!Object} An array or array-like object for iteration.
 */
VirtualRepeatController.prototype.repeatListExpression_ = function(scope) {
  var repeatList = this.rawRepeatListExpression(scope);

  if (this.onDemand && repeatList) {
    var virtualList = new VirtualRepeatModelArrayLike(repeatList);
    virtualList.$$includeIndexes(this.newStartIndex, this.newVisibleEnd);
    return virtualList;
  } else {
    return repeatList;
  }
};


/**
 * Called by the container. Informs us that the containers scroll or size has
 * changed.
 */
VirtualRepeatController.prototype.containerUpdated = function() {
  // If itemSize is unknown, attempt to measure it.
  if (!this.itemSize) {
    this.unwatchItemSize_ = this.$scope.$watchCollection(
        this.repeatListExpression,
        angular.bind(this, function(items) {
          if (items && items.length) {
            this.$$rAF(angular.bind(this, this.readItemSize_));
          }
        }));
    if (!this.$scope.$root.$$phase) this.$scope.$digest();

    return;
  } else if (!this.sized) {
    this.items = this.repeatListExpression(this.$scope);
  }

  if (!this.sized) {
    this.unwatchItemSize_();
    this.sized = true;
    this.$scope.$watchCollection(this.repeatListExpression,
        angular.bind(this, function(items, oldItems) {
          if (!this.isVirtualRepeatUpdating_) {
            this.virtualRepeatUpdate_(items, oldItems);
          }
        }));
  }

  this.updateIndexes_();

  if (this.newStartIndex !== this.startIndex ||
      this.newEndIndex !== this.endIndex ||
      this.container.getScrollOffset() > this.container.getScrollSize()) {
    if (this.items instanceof VirtualRepeatModelArrayLike) {
      this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex);
    }
    this.virtualRepeatUpdate_(this.items, this.items);
  }
};


/**
 * Called by the container. Returns the size of a single repeated item.
 * @return {?number} Size of a repeated item.
 */
VirtualRepeatController.prototype.getItemSize = function() {
  return this.itemSize;
};


/**
 * Updates the order and visible offset of repeated blocks in response to scrolling
 * or items updates.
 * @private
 */
VirtualRepeatController.prototype.virtualRepeatUpdate_ = function(items, oldItems) {
  this.isVirtualRepeatUpdating_ = true;

  var itemsLength = items && items.length || 0;
  var lengthChanged = false;

  // If the number of items shrank, scroll up to the top.
  if (this.items && itemsLength < this.items.length && this.container.getScrollOffset() !== 0) {
    this.items = items;
    this.container.resetScroll();
    return;
  }

  if (itemsLength !== this.itemsLength) {
    lengthChanged = true;
    this.itemsLength = itemsLength;
  }

  this.items = items;
  if (items !== oldItems || lengthChanged) {
    this.updateIndexes_();
  }

  this.parentNode = this.$element[0].parentNode;

  if (lengthChanged) {
    this.container.setScrollSize(itemsLength * this.itemSize);
  }

  if (this.isFirstRender) {
    this.isFirstRender = false;
    var startIndex = this.$attrs.mdStartIndex ?
      this.$scope.$eval(this.$attrs.mdStartIndex) :
      this.container.topIndex;
    this.container.scrollToIndex(startIndex);
  }

  // Detach and pool any blocks that are no longer in the viewport.
  Object.keys(this.blocks).forEach(function(blockIndex) {
    var index = parseInt(blockIndex, 10);
    if (index < this.newStartIndex || index >= this.newEndIndex) {
      this.poolBlock_(index);
    }
  }, this);

  // Add needed blocks.
  // For performance reasons, temporarily block browser url checks as we digest
  // the restored block scopes ($$checkUrlChange reads window.location to
  // check for changes and trigger route change, etc, which we don't need when
  // trying to scroll at 60fps).
  this.$browser.$$checkUrlChange = angular.noop;

  var i, block,
      newStartBlocks = [],
      newEndBlocks = [];

  // Collect blocks at the top.
  for (i = this.newStartIndex; i < this.newEndIndex && this.blocks[i] == null; i++) {
    block = this.getBlock_(i);
    this.updateBlock_(block, i);
    newStartBlocks.push(block);
  }

  // Update blocks that are already rendered.
  for (; this.blocks[i] != null; i++) {
    this.updateBlock_(this.blocks[i], i);
  }
  var maxIndex = i - 1;

  // Collect blocks at the end.
  for (; i < this.newEndIndex; i++) {
    block = this.getBlock_(i);
    this.updateBlock_(block, i);
    newEndBlocks.push(block);
  }

  // Attach collected blocks to the document.
  if (newStartBlocks.length) {
    this.parentNode.insertBefore(
        this.domFragmentFromBlocks_(newStartBlocks),
        this.$element[0].nextSibling);
  }
  if (newEndBlocks.length) {
    this.parentNode.insertBefore(
        this.domFragmentFromBlocks_(newEndBlocks),
        this.blocks[maxIndex] && this.blocks[maxIndex].element[0].nextSibling);
  }

  // Restore $$checkUrlChange.
  this.$browser.$$checkUrlChange = this.browserCheckUrlChange;

  this.startIndex = this.newStartIndex;
  this.endIndex = this.newEndIndex;

  this.isVirtualRepeatUpdating_ = false;
};


/**
 * @param {number} index Where the block is to be in the repeated list.
 * @return {!VirtualRepeatController.Block} A new or pooled block to place at the specified index.
 * @private
 */
VirtualRepeatController.prototype.getBlock_ = function(index) {
  if (this.pooledBlocks.length) {
    return this.pooledBlocks.pop();
  }

  var block;
  this.transclude(angular.bind(this, function(clone, scope) {
    block = {
      element: clone,
      new: true,
      scope: scope
    };

    this.updateScope_(scope, index);
    this.parentNode.appendChild(clone[0]);
  }));

  return block;
};


/**
 * Updates and if not in a digest cycle, digests the specified block's scope to the data
 * at the specified index.
 * @param {!VirtualRepeatController.Block} block The block whose scope should be updated.
 * @param {number} index The index to set.
 * @private
 */
VirtualRepeatController.prototype.updateBlock_ = function(block, index) {
  this.blocks[index] = block;

  if (!block.new &&
      (block.scope.$index === index && block.scope[this.repeatName] === this.items[index])) {
    return;
  }
  block.new = false;

  // Update and digest the block's scope.
  this.updateScope_(block.scope, index);

  // Perform digest before reattaching the block.
  // Any resulting synchronous dom mutations should be much faster as a result.
  // This might break some directives, but I'm going to try it for now.
  if (!this.$scope.$root.$$phase) {
    block.scope.$digest();
  }
};


/**
 * Updates scope to the data at the specified index.
 * @param {!angular.Scope} scope The scope which should be updated.
 * @param {number} index The index to set.
 * @private
 */
VirtualRepeatController.prototype.updateScope_ = function(scope, index) {
  scope.$index = index;
  scope[this.repeatName] = this.items && this.items[index];
  if (this.extraName) scope[this.extraName(this.$scope)] = this.items[index];
};


/**
 * Pools the block at the specified index (Pulls its element out of the dom and stores it).
 * @param {number} index The index at which the block to pool is stored.
 * @private
 */
VirtualRepeatController.prototype.poolBlock_ = function(index) {
  this.pooledBlocks.push(this.blocks[index]);
  this.parentNode.removeChild(this.blocks[index].element[0]);
  delete this.blocks[index];
};


/**
 * Produces a dom fragment containing the elements from the list of blocks.
 * @param {!Array<!VirtualRepeatController.Block>} blocks The blocks whose elements
 *     should be added to the document fragment.
 * @return {DocumentFragment}
 * @private
 */
VirtualRepeatController.prototype.domFragmentFromBlocks_ = function(blocks) {
  var fragment = this.$document[0].createDocumentFragment();
  blocks.forEach(function(block) {
    fragment.appendChild(block.element[0]);
  });
  return fragment;
};


/**
 * Updates start and end indexes based on length of repeated items and container size.
 * @private
 */
VirtualRepeatController.prototype.updateIndexes_ = function() {
  var itemsLength = this.items ? this.items.length : 0;
  var containerLength = Math.ceil(this.container.getSize() / this.itemSize);

  this.newStartIndex = Math.max(0, Math.min(
      itemsLength - containerLength,
      Math.floor(this.container.getScrollOffset() / this.itemSize)));
  this.newVisibleEnd = this.newStartIndex + containerLength + NUM_EXTRA;
  this.newEndIndex = Math.min(itemsLength, this.newVisibleEnd);
  this.newStartIndex = Math.max(0, this.newStartIndex - NUM_EXTRA);
};

/**
 * This VirtualRepeatModelArrayLike class enforces the interface requirements
 * for infinite scrolling within a mdVirtualRepeatContainer. An object with this
 * interface must implement the following interface with two (2) methods:
 *
 * getItemAtIndex: function(index) -> item at that index or null if it is not yet
 *     loaded (It should start downloading the item in that case).
 *
 * getLength: function() -> number The data legnth to which the repeater container
 *     should be sized. Ideally, when the count is known, this method should return it.
 *     Otherwise, return a higher number than the currently loaded items to produce an
 *     infinite-scroll behavior.
 *
 * @usage
 * <hljs lang="html">
 *  <md-virtual-repeat-container md-orient-horizontal>
 *    <div md-virtual-repeat="i in items" md-on-demand>
 *      Hello {{i}}!
 *    </div>
 *  </md-virtual-repeat-container>
 * </hljs>
 *
 */
function VirtualRepeatModelArrayLike(model) {
  if (!angular.isFunction(model.getItemAtIndex) ||
      !angular.isFunction(model.getLength)) {
    throw Error('When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement ' +
        'functions getItemAtIndex() and getLength() ');
  }

  this.model = model;
}


VirtualRepeatModelArrayLike.prototype.$$includeIndexes = function(start, end) {
  for (var i = start; i < end; i++) {
    if (!this.hasOwnProperty(i)) {
      this[i] = this.model.getItemAtIndex(i);
    }
  }
  this.length = this.model.getLength();
};


function abstractMethod() {
  throw Error('Non-overridden abstract method called.');
}

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.win')
        .controller('enWinController', WinController);

    function WinController($scope, $element, $attrs, $enModal, $timeout, $location) {
        var self = this;

        // Properties
        self.isMinimized = false;
        self.isMaximized = false;

        // Methods
        self.window = function(){};


        /*Native controls for desktop*/
        var win;
        var isNodeWebkit = (typeof require === 'function');
        var isChromeApp = (window.chrome && chrome.runtime && chrome.runtime.id);
        if(isNodeWebkit || isChromeApp){

            /*Node-Webkit Window Controls*/
            if(isNodeWebkit){
                var gui = require('nw.gui');
                win = gui.Window.get();

                win.show();

                win.on('minimize', function() { self.isMinimized = true; });
                win.on('restore', function() { self.isMinimized = false; });
                win.on('maximize', function() { self.isMaximized = true; });
                win.on('unmaximize', function() { self.isMaximized = false; });

                self.window = function(){
                    this.close = function(){ win.close(); };
                    this.minimize = function(){
                        win[(self.isMinimized) ? 'restore':'minimize']();
                    };
                    this.maximize = function(){
                        win[(self.isMaximized) ? 'restore':'maximize']();
                    };
                    return this;
                };
            }

            /*Chrome App Window controls*/
            if(isChromeApp){
                win = chrome.app.window.current();

                win.show();

                win.onMinimized.addListener(function() { self.isMinimized = true; });
                win.onRestored.addListener(function() {
                    self.isMinimized = false;
                    self.isMaximized = false;
                });
                win.onMaximized.addListener(function() { self.isMaximized = true; });

                self.window = function(){
                    this.close = function(){ win.close(); };
                    this.minimize = function(){
                        win[(self.isMinimized) ? 'restore':'minimize']();
                    };
                    this.maximize = function(){
                        win[(self.isMaximized) ? 'restore':'maximize']();
                    };
                    return this;
                };
            }
        }

        $scope.showModal = function(modal,params,func){
            $enModal.open(modal,params,func);
        };

        $scope.showScreen = function(screen){
            $timeout(function(){ $location.url(screen); });
        };
        //
        //$scope.refreshGrid = function(grid){
        //    $enGrid.refresh(grid)
        //};
        //
        //$scope.grid = $enGrid.grids;
    }
    WinController.$inject = ["$scope", "$element", "$attrs", "$enModal", "$timeout", "$location"];

})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.win')
        .directive('enWin', WinDirective);

    /**
     * @ngdoc directive
     * @name enWin
     * @module enspire.ui.components.win
     *
     * @restrict E
     *
     * @description
     * The `<en-win>` directive...
     *
     */
    function WinDirective($location,$timeout) {
        return {
            restrict    : 'E',
            controller: 'enWinController',
            compile:compile
        };

        function compile($element, $attrs) {
            var isNodeWebkit = (typeof require === 'function');
            var isChromeApp = (window.chrome && chrome.runtime && chrome.runtime.id);

            //var parAttrs = $enCommonAttrs.parse($attrs,['common']);
            //$element.css(parAttrs.styles).addClass(parAttrs.classes);

            if($attrs.type=='scroll'){
                $element.addClass('scroll');
                //$('html').addClass('scroll');
            }else{
                $element.addClass('fill');
                //$('html').addClass('fill');
            }

            return function postLink($scope, $element, $attrs) {
                var touch = false; //$touch.isTouch;

                /*Force tablet to reposition when changing orientation*/
                //$(window).on('orientationchange',function(){ window.scrollTo(0,0); });

                /*remove desktop window gui if a browser or tablet*/
                if(!isNodeWebkit && !isChromeApp){
                    //if (navigator.appVersion.indexOf("Mac")!=-1 || typeof require !== 'function'){
                    $element.addClass('chromeless');

                    /*fix for iOS7 not display 100% correctly*/
                    if(touch){
                        $element.height(window.innerHeight);
                        $(window).resize(function() {
                            $element.height(window.innerHeight);
                        });
                    }
                }

            };
        }
    }
    WinDirective.$inject = ["$location", "$timeout"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.adapter').factory('enAdapterRuleColon', ComponentService);

    function ComponentService(enAdapterActionKeys, enAdapterActionContains, enAdapterObj2Array, enAdapterSort) {

        function ComponentFactory(ruleEngine) {

            // RULE : - Perform some action against context
            ruleEngine.registerRule(':', function(rule, context, source){
                var output,
                    params = {
                        'isArray': angular.isArray(context),
                        'isObject': angular.isObject(context),
                        'isString': angular.isString(context),
                        'ruleName': this.getRuleName(rule).substr(1),
                        'ruleValue': rule.match(/\(([^\)]*)/)[1],
                        'rule': rule,
                        'context': context,
                        'source': source
                    },
                    ruleName = params.ruleName;

                if (ruleName.match(/^eq|gt|lt|not$/)){
                    ruleName = 'compare';
                }

                switch(ruleName) {
                    case 'contains':
                        output = enAdapterActionContains(params);
                        break;

                    case 'keys':
                        output = enAdapterActionKeys(params);
                        break;

                    case 'compare':
                        break;

                    case 'obj2array':
                        output = enAdapterObj2Array(params);
                        break;

                    case 'pluck':
                        params.isPluckMode = true;
                        output = enAdapterActionKeys(params);
                        break;

                    case 'sort':
                        output = enAdapterSort(params);
                        break;

                    default:
                        console.warn('enAdapter: Unknown action rule! Passed in type: "' + params.ruleName + '"');
                        break;
                }

                return output;
            });
        }

        return ComponentFactory;
    }
    ComponentService.$inject = ["enAdapterActionKeys", "enAdapterActionContains", "enAdapterObj2Array", "enAdapterSort"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.adapter').factory('enAdapterRuleDot', ComponentService);

    function ComponentService() {

        function ComponentFactory(ruleEngine) {

            // RULE . - Extract contents of array or object
            ruleEngine.registerRule('.', function(rule, context, source){
                var output,
                    prop = rule.substr(1);

                if (angular.isArray(context)) {
                    output = [];
                    context.map(function(item){
                        if (item[prop] !== undefined) output.push( item[prop] );
                    });
                }
                else if (angular.isObject(context)) {
                    output = context[prop];
                }
                // Error
                else {
                    console.warn('enAdapter: Applying the extraction rule against a non-object! Passed in type: ' + typeof(context));
                    output = context;
                }

                return output;
            });
        }

        return ComponentFactory;
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.adapter').factory('enAdapterRuleStar', ComponentService);

    function ComponentService() {

        function ComponentFactory(ruleEngine) {

            // RULE * - Extract contents of array or object
            ruleEngine.registerRule('*', function(rule, context, source){
                var output,
                    goOneLevelDeep = (rule === '.*');

                if (angular.isArray(context)) {
                    output = [];
                    context.forEach(function(item){
                        // Go down one level if array
                        if (goOneLevelDeep && angular.isArray(item)) {
                            // Only go one level deep which is expected behavior
                            item.forEach(function(subItem){
                                output.push(subItem);
                            })
                        }
                        // otherwise copy the object
                        else {
                            output.push(item);
                        }
                    });
                }
                else if (angular.isObject(context)) {
                    output = {};
                    for (var prop in context) {
                        if (context.hasOwnProperty(prop)){
                            output[prop] = context[prop];
                        }
                    }
                }
                // Error
                else {
                    console.warn('enAdapter: Rule \'*\' only applies to arrays and objects! Passed in type: ' + typeof(context));
                    output = context;
                }

                return output;
            });
        }

        return ComponentFactory;
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * @ngdoc directive
 * @name enApiSearchControls
 * @module enspire.ui.components.api
 * @restrict E
 * @element en-api-search-controls
 *
 * @description
 * Search data control bar with match (any, all) filtering and query labels
 *
 * @param {object=}     object         Reference name of the api object created by this directive.
 *
 */

angular.module('enspire.ui.components.api').directive('enApiSearchControls', ['$location','$enApiSearch',function($location,$enApiSearch) {
    function resolveTemplate($element, $attrs){
        var strTemplate = '';

        strTemplate += '<select name="filter" ng-model="object.search.matchAll" ng-change="setMatchAll()" ng-options="item.value as item.name for item in matchValues" class="adv-search-control-select"></select>';

        strTemplate += '<en-button class="filter-button" ng-repeat="criteria in object.search.criteria" en-tap="removeCriteria($index)">';
        strTemplate += '<span>{{criteria.filter.name}} </span> ';
        strTemplate += '<b><i>{{criteria.arg}} </i></b> ';
        strTemplate += '<span class="filter-value">{{criteria.value}}</span> <en-icon icon="x-circle"></en-icon>';
        strTemplate += '</en-button>';

        return strTemplate;
    }


    return {
        restrict:'E',
        scope:{
            object:'='
        },
        template: resolveTemplate,
        controller: ["$scope", "$attrs", function($scope,$attrs){
            $scope.matchValues = [{name:"Matching All",value:true},{name:"Matching Any",value:false}];

            $scope.match = $scope.object;

            $scope.removeCriteria = function(idx){
                //add criteria
                $enApiSearch.removeCriteria($scope.object,idx);

                //get updated API results
                $scope.object.refresh(true);
            };

            $scope.setMatchAll = function(){
                $enApiSearch.setMatchAll($scope.object,$scope.object.search.matchAll);

                //get updated API results
                $scope.object.refresh(true);
            };
        }],
        link: function($scope, $element, $attrs) {
            if(!angular.isDefined($attrs.object)){
                console.error('en-api-search-tags must define an object.');
                return false;
            }
        }
    };
}]);

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
/**
 * @ngdoc directive
 * @name enApiSearch
 * @module enspire.ui.components.api
 * @restrict E
 * @element en-api-search
 *
 * @description
 * Search data within API response
 *
 * @param {object=}     object         Reference name of the api object created by this directive.
 * @param {string=}     [type=basic|basic, advanced, simplified]           Type of search.
 * @param {array=}      [criteria]       Criteria used to filter results. Array of objects. Criteria args: is, contains, starts with, ends with
 * @param {string=}     fields         Fields to search for query. Comma-delimited, no spaces.
 *
 */

angular.module('enspire.ui.components.api').directive('enApiSearch', ['$location','$enApiSearch','$rootScope','$timeout',function($location,$enApiSearch,$rootScope,$timeout) {
    function resolveTemplate($element, $attrs){
        var strTemplate = '';
        strTemplate += '<form name="enApiSearch">';
        switch($attrs.type) {
            case 'advanced':
                strTemplate += '<en-field class="adv-search-field">';
                // strTemplate += '<button type="button" class="en-button" en-tap="onSubmit(true)">';
                // strTemplate += '<en-icon icon="search" class="ng-scope"></en-icon>';
                // strTemplate += '<en-icon icon="caret-down" class="ng-scope"></en-icon>';
                // strTemplate += '</button>';
                strTemplate += '<select name="filter-criteria" ng-model="apiSearchFilter.filter" ng-disabled="criteria.length===0" ng-options="item as item.name group by item.group for item in criteria | orderBy:\'name\'" class="adv-search-criteria">';
                strTemplate += '<option value="">Select Criteria</option>';
                strTemplate += '</select>';
                strTemplate += '<select name="filter-content" ng-model="apiSearchFilter.arg" ng-disabled="apiSearchFilter.disableFields" ng-options="item as item for item in argumentData" class="adv-search-args">';
                strTemplate += '</select>';
                strTemplate += '<en-input>';
                strTemplate += '<input name="filter-value" ng-model="apiSearchFilter.value" ng-disabled="apiSearchFilter.disableFields" en-enter="(apiSearchFilter.value!==\'\') ? onSubmit(true) : \'\'" class="adv-search-input">';
                strTemplate += '<en-icon icon="x-circle" en-tap="apiSearchFilter.value=\'\'" class="is-clickable" ng-show="apiSearchFilter.value!==\'\' && apiSearchFilter.value!=undefined"></en-icon>';
                strTemplate += '</en-input>';
                strTemplate += '<button type="button" class="en-button en-api-search-search-button" ng-disabled="apiSearchFilter.disableFields || apiSearchFilter.value===\'\'" en-tap="(apiSearchFilter.value!==\'\') ? onSubmit(true) : \'\'">';
                strTemplate += '<en-icon icon="search-plus" class="ng-scope"></en-icon>';
                strTemplate += '</button>';
                strTemplate += '</en-field>';
                break;
            case 'simplified':
                strTemplate += '<en-field class="adv-search-field adv-search-simplified">';
                strTemplate += '<button type="button" class="en-button"';
                strTemplate += ' en-popover';
                strTemplate += ' popover-html="true"';
                strTemplate += ' popover-auto-close="true"';
                strTemplate += ' popover-placement="bottom-left"';
                strTemplate += ' popover-container="en-win-body"';
                strTemplate += ' popover-title=""';
                strTemplate += " popover-viewport=\"{'selector': 'en-win-body', 'padding': 18 }\"";
                strTemplate += ' popover-template="test-dropdown"';
                strTemplate += ' popover-custom-class="popover-dark"';
                strTemplate += '>';
                strTemplate += 'Filters &nbsp;<en-icon icon="caret-down"></en-icon>';
                strTemplate += '</button>';
                strTemplate += '<en-input>';
                strTemplate += '<input name="filter-value" ng-model="apiSearchFilter.value" ng-disabled="apiSearchFilter.disableFields" en-enter="(apiSearchFilter.value!==\'\') ? onSubmit(true) : \'\'" class="adv-search-input">';
                strTemplate += '<en-icon icon="search" class="is-clickable"></en-icon>';
                strTemplate += '<en-icon icon="x-circle" en-tap="apiSearchFilter.value=\'\'" class="is-clickable" ng-show="apiSearchFilter.value!==\'\' && apiSearchFilter.value!=undefined"></en-icon>';
                strTemplate += '</en-input>';
                strTemplate += '<button type="button" class="en-button en-api-search-search-button" ng-if="apiSearchFilter.value!==\'\' || object.search.criteria.length>0" en-tap="(apiSearchFilter.value!==\'\') ? onSubmit(true) : \'\'">';
                strTemplate += 'Save';
                strTemplate += '</button>';
                strTemplate += '</en-field>';

                strTemplate += '<script type="text/ng-template" id="test-dropdown">';
                strTemplate += '<div class="popover" tabindex="-1" style="max-width:475px;">';
                strTemplate += '<div class="arrow"></div>';
                strTemplate += '<div class="popover-content">';
                strTemplate += '<div style="width:475px;">';
                strTemplate += '<div style="height:20px;">Add a filter to help narrow your search:</div>';
                strTemplate += '<en-field class="adv-search-field">';
                strTemplate += '<select name="filter-criteria" ng-model="apiSearchFilter.filter" ng-disabled="criteria.length===0" ng-options="item as item.name group by item.group for item in criteria | orderBy:\'name\'" class="adv-search-criteria">';
                strTemplate += '<option value="">Select Criteria</option>';
                strTemplate += '</select>';
                strTemplate += '<select name="filter-content" ng-model="apiSearchFilter.arg" ng-disabled="apiSearchFilter.disableFields" ng-options="item as item for item in argumentData" class="adv-search-args">';
                strTemplate += '</select>';
                strTemplate += '<en-input>';
                strTemplate += '<input name="filter-value" ng-model="apiSearchFilter.value" ng-disabled="apiSearchFilter.disableFields" en-enter="(apiSearchFilter.value!==\'\') ? onSubmit(true) : \'\';$hide();" class="adv-search-input">';
                strTemplate += '<en-icon icon="x-circle" en-tap="apiSearchFilter.value=\'\'" class="is-clickable" ng-show="apiSearchFilter.value!==\'\' && apiSearchFilter.value!=undefined"></en-icon>';
                strTemplate += '</en-input>';
                strTemplate += '<button type="button" class="en-button en-api-search-search-button" ng-disabled="apiSearchFilter.disableFields || apiSearchFilter.value===\'\'" en-tap="(apiSearchFilter.value!==\'\') ? onSubmit(true) : \'\';$hide();">';
                strTemplate += 'Add';
                strTemplate += '</button>';
                strTemplate += '</en-field>';
                strTemplate += '</div>';
                strTemplate += '</div>';
                strTemplate += '</div>';
                strTemplate += '</script>';
                break;
            default:
                strTemplate += '<en-field>';
                strTemplate += '<en-input '+(angular.isDefined($attrs.flex) ? ' flex':'')+'>';
                strTemplate += '<input type="text" ng-model="search" placeholder="{{ placeholder || \'Search\'}}" ng-blur="onSubmit(true)" en-enter="onSubmit(true)">';
                strTemplate += '<en-icon icon="x-circle" en-tap="reset;" class="is-clickable" ng-show="search!==\'\' && search!=undefined"></en-icon>';
                strTemplate += '</en-input>';
                strTemplate += '<button type="button" class="en-button en-api-search-search-button" ng-tap="onSubmit(true)">';
                strTemplate += '<en-icon icon="search" class="ng-scope"></en-icon>';
                strTemplate += '</button>';
                strTemplate += '</en-field>';
        }
        strTemplate += '</form>';

        return strTemplate;
    }


    return {
        restrict:'E',
        scope:{
            object:'=',
            criteria:'=',
            defaultFilter:'@',
            placeholder:'@',
            fields:'@',
            autoFocus:'='
        },
        template: resolveTemplate,
        controller: ["$scope", "$attrs", function($scope,$attrs){
            $scope.apiSearchFilter = {
                filter:null,
                arg:'is',
                value:'',
                disableFields:true
            };

            var $element = null;
            var $eleInput = null;
            var lastKeyPress = new Date().getTime();
            var strBarcodeText = '';
            var timeoutBarcodeCheck;

            $scope.initialize = function(ele){
                $element = ele;

                $eleInput = $element[0].querySelector('input[name="filter-value"]');

                angular.element($eleInput).on('keypress', function(e){
                    var curTime = new Date().getTime();
                    var difTime = curTime-lastKeyPress;
                    // console.log('keypress: ',difTime+'ms');
                    lastKeyPress = curTime;

                    if(difTime<=35){
                        clearTimeout(timeoutBarcodeCheck);

                        if(strBarcodeText.length===1){
                            var pos = $eleInput.selectionStart;
                            var posEnd = $eleInput.selectionEnd;

                            if(typeof $eleInput.value !== 'undefined' && typeof $eleInput.value.substr !== 'undefined'){
                                $eleInput.value = $eleInput.value.substr(0, pos-1)+$eleInput.value.substr(posEnd);
                                $eleInput.selectionStart = pos-1;
                                $eleInput.selectionEnd = pos-1;
                            }
                        }

                        strBarcodeText += String.fromCharCode(e.which||e.charCode||e.keyCode);
                        e.preventDefault();
                        timeoutBarcodeCheck = setTimeout(function(){
                            if(strBarcodeText.length>=5){
                                console.log('possible scan:',strBarcodeText)
                            }else{
                                console.log('quick typing');
                                var pos = $eleInput.selectionStart;
                                var posEnd = $eleInput.selectionEnd;

                                if(typeof $eleInput.value !== 'undefined' && typeof $eleInput.value.substr !== 'undefined' && strBarcodeText!==''){
                                    $eleInput.value = $eleInput.value.substr(0, pos)+strBarcodeText+$eleInput.value.substr(posEnd);
                                    $eleInput.selectionStart = pos+strBarcodeText.length;
                                    $eleInput.selectionEnd = pos+strBarcodeText.length;
                                }
                            }
                            strBarcodeText = '';
                        }, 35);
                    }else{
                        strBarcodeText = String.fromCharCode(e.which||e.charCode||e.keyCode);
                    }
                });

                if($scope.autoFocus){
                    $eleInput.focus();
                }
            };

            $scope.argumentData = ['is', 'contains', 'starts with', 'ends with'];

            $scope.updateFilter = function(newVal){
                if(newVal!==null){
                    $scope.apiSearchFilter.disableFields = false;
                    if(typeof newVal.define.args !== 'undefined' && typeof newVal.define.args.list !== 'undefined'){
                        $scope.argumentData = newVal.define.args.list;
                    }else{
                        $scope.argumentData = ['is', 'is not', 'contains', 'starts with', 'ends with'];
                    }
                    if(typeof newVal.define.args !== 'undefined' && typeof newVal.define.args.default !== 'undefined' && newVal.define.args.default !== ''){
                        $scope.apiSearchFilter.arg = newVal.define.args.default;
                    }else{
                        $scope.apiSearchFilter.arg = $scope.argumentData[0];
                    }
                    $eleInput.focus();
                }else{
                    $scope.apiSearchFilter.disableFields = true;
                    $scope.apiSearchFilter.value = '';
                }
            };

            var watchCriteria = $scope.$watch('apiSearchFilter.filter', function (newVal,oldVal) {
                if(newVal!=oldVal){
                    $scope.updateFilter(newVal)
                }

            });

            $scope.onSubmit = function(bolReset){
                //add criteria
                $enApiSearch.addCriteria($scope.object,$scope.apiSearchFilter);

                //reset value
                $rootScope.$safeApply(function(){
                    $scope.apiSearchFilter.value = '';
                });

                //get new API
                $scope.object.refresh(bolReset);
            };
        }],
        link: function($scope, $element, $attrs) {
            if(!angular.isDefined($attrs.object)){
                console.error('en-api-search must define an object.');
                return false;
            }

            if(!angular.isDefined($attrs.fields) && ($attrs.type!=='advanced' && $attrs.type!=='simplified')){
                console.error('en-api-search must have at least one field defined.');
                return false;
            }

            if(!angular.isDefined($attrs.criteria) && ($attrs.type==='advanced' || $attrs.type==='simplified')){
                console.error('en-api-search must have a criteria or criteria-path defined.');
                return false;
            }

            $scope.initialize($element);

            if(angular.isDefined($attrs.defaultFilter)) {
                if (angular.isArray($scope.criteria)) {
                    var lngCriteria = $scope.criteria.length;
                    for(var i=0;i<lngCriteria;i++){
                        var objCriteria = $scope.criteria[i];
                        if(objCriteria.field===$attrs.defaultFilter){
                            $scope.apiSearchFilter.filter = objCriteria;
                            $scope.updateFilter(objCriteria);
                            break;
                        }
                    }
                }
            }
        }
    };
}]);

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.api')
        .provider('$enApiSearch', apiSearchService);

    function apiSearchService() {
        var self = this;

        var apiSearchServiceData = {};

        var buildFilter = function(objSearch,strFilter){
            var lngObj = objSearch.criteria.length;
            var searchFilter = '';
            for(var i=0; i<lngObj; i++){
                var objCriteria = objSearch.criteria[i];
                var strTemp = objCriteria.filter.field+':';

                switch(objCriteria.arg){
                    case 'is':
                        strTemp += objCriteria.value;
                        break;
                    case 'is not':
                        strTemp += '!'+objCriteria.value;
                        break;
                    case 'contains':
                        strTemp += '%'+objCriteria.value+'%';
                        break;
                    case 'not contains':
                        strTemp += '!%'+objCriteria.value+'%';
                        break;
                    case 'starts with':
                        strTemp += objCriteria.value+'%';
                        break;
                    case 'ends with':
                        strTemp += '%'+objCriteria.value;
                        break;
                    case 'greater than':
                        strTemp += '>'+objCriteria.value;
                        break;
                }

                if(i>0){
                    (objSearch.matchAll) ? searchFilter += '&&' : searchFilter += '||'
                }
                searchFilter += strTemp;
            }

            if(searchFilter!==''){
                if(strFilter!=='' && strFilter!==undefined){
                    return '('+strFilter+')&&('+searchFilter+')';
                }else{
                    return '('+searchFilter+')';
                }
            }else{
                return strFilter;
            }
        };

        self.$get = ["$timeout", "$enLocalStorage", "$enBase64", "$location", function $enApiSearchFactory($timeout, $enLocalStorage, $enBase64,$location) {

            var getKeyName = function(objApi){
                var strKey = 'apiSearch:'+objApi.name;

                if(!objApi.search.shared){
                    if(objApi.insideModal){
                        if(objApi.modalPath===''){
                            console.error('en-api-object is set as "insideModal" but no "modalPath" is set.');
                            strKey += ':modal';
                        }else{
                            strKey += ':'+objApi.modalPath;
                        }
                    }else{
                        strKey += ':'+$location.path();
                    }
                }

                return strKey;
            };

            var updateRemembered = function(objApi){
                if(objApi.search.remembered || objApi.search.localStorage){

                    var rememberedKey = getKeyName(objApi);

                    if(objApi.search.localStorage){
                        if(objApi.search.criteria.length===0){
                            $enLocalStorage.remove($enBase64.encode(rememberedKey));
                        }else{
                            $enLocalStorage.set($enBase64.encode(rememberedKey), $enBase64.encode(JSON.stringify(objApi.search)));
                        }
                    }else if(objApi.search.remembered){
                        if(objApi.search.criteria.length===0) {
                            delete apiSearchServiceData[rememberedKey];
                        }else{
                            apiSearchServiceData[rememberedKey] = angular.merge({},objApi.search);
                        }
                    }
                }
            };

            return {
                buildFilter:buildFilter,

                loadSearch: function(objApi){
                    var objSearch = objApi.search;
                    var objSavedSearch = {};
                    if(objApi.search.remembered || objApi.search.localStorage) {
                        var rememberedKey = getKeyName(objApi);

                        if (objApi.search.localStorage) {
                            try {
                                var strTemp = $enLocalStorage.get($enBase64.encode(rememberedKey));
                                var objTemp = JSON.parse($enBase64.decode(strTemp));
                                objSavedSearch = objTemp;
                            } catch (e) {
                                objSavedSearch = {};
                            }

                        } else if (objApi.search.remembered) {
                            objSavedSearch = apiSearchServiceData[rememberedKey] || {};
                        }
                    }

                    if(typeof objSavedSearch.matchAll !== 'undefined') objSearch.matchAll = objSavedSearch.matchAll;
                    if(typeof objSavedSearch.criteria !== 'undefined') objSearch.criteria = objSavedSearch.criteria;

                    return objSearch;
                },

                addCriteria: function(objApi,objCriteria){
                    var objNewCriteria = angular.merge({},objCriteria);
                    objApi.search.criteria.push(objNewCriteria);
                    updateRemembered(objApi);
                },

                removeCriteria: function(objApi,idx){
                    objApi.search.criteria.splice(idx, 1);
                    updateRemembered(objApi);
                },

                clearCriteria: function(objApi){
                    objApi.search.criteria = [];
                    updateRemembered(objApi);
                },

                setMatchAll: function(objApi,bol){
                    objApi.search.matchAll = !!bol;
                    updateRemembered(objApi);
                }
            };
        }];
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
angular.module('enspire.ui.components.collection').directive('enCollectionCount', [function() {
    return {
        restrict:'E',
        replace:true,
        scope:{
            object:'='
        },
        template:   '<div class="en-grid-result-count">'+
                    '<div><b ng-if="object.pages>0">{{object.page}}</b> <span ng-if="object.pages>0">of</span> <b>{{object.pages}}</b> pages</div>'+
                    '<i>{{object.total}} results</i>'+
                    '</div>',
        link: function($scope, $element, $attrs) {
            if(!angular.isDefined($attrs.object)){
                console.warn('en-collection-count must define an object.');
                return false;
            }
        }
    };
}]);
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
angular.module('enspire.ui.components.collection').directive('enCollectionPaging', [function() {

    function resolveTemplate($element, $attrs){
        var layout = $attrs.layout;
        switch(layout){
            case 'basic':
                layout = 'basic';
                break;
            default:
                layout = 'advanced';
        }


        var template = '';

        if(layout==='advanced'){
            template += '<en-button class="trim" en-tap="object.begin()" ng-disabled="object.getting || object.page<=1"><en-icon icon="chevron-left-double"></en-icon></en-button> ';
        }
        template += '<en-button-group>';
        template += '<en-button class="trim" en-tap="object.previous()" ng-disabled="object.getting || object.page<=1"><en-icon icon="chevron-left"></en-icon></en-button>';
        //template +=  '<en-control><select ng-disabled="object.loading" data-ng-options="page.value as page.name for page in list" data-ng-model="currentPage"></select></en-control>';
        template +=  '<en-button class="trim" en-tap="object.next()" ng-disabled="object.getting || object.pages==object.page || object.pages===0"><en-icon icon="chevron-right"></en-icon></en-button>';
        template +=  '</en-button-group> ';
        if(layout==='advanced') {
            template += '<en-button class="trim" en-tap="object.last()" ng-disabled="object.getting || object.pages==object.page || object.pages===0"><en-icon icon="chevron-right-double"></en-icon></en-button> ';
        }
        return template;
    }

    return {
        restrict:'E',
        scope:{
            object:'='
        },
        template: resolveTemplate,
        link: function($scope, $element, $attrs) {
            if(!angular.isDefined($attrs.object)){
                console.warn('en-collection-paging must define an object.');
                return false;
            }
        }
    };
}]);

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
angular.module('enspire.ui.components.collection').directive('enCollectionPerPage', ['$location',function($location) {
    return {
        restrict:'E',
        scope:{
            object:'='
        },
        template:   '<en-control>'+
        '   <select ng-model="object.limit" ng-change="object.refresh()">'+
        '       <option value="5">5</option>'+
        '       <option value="10">10</option>'+
        '       <option value="25">25</option>'+
        '       <option value="50">50</option>'+
        '       <option value="50">75</option>'+
        '       <option value="100">100</option>'+
        '       <option value="200">200</option>'+
        '   </select>'+
        '</en-control>',
        link: function($scope, $element, $attrs) {
            if(!angular.isDefined($attrs.object)){
                console.warn('en-collection-per-page must define an object.');
                return false;
            }

        }
    };
}]);
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
angular.module('enspire.ui.components.collection').directive('enCollectionSearch', ['$location',function($location) {
    function resolveTemplate($element, $attrs){
        var strTemplate = '';
        strTemplate += '<form name="enCollectionSearch">';
        strTemplate += '<en-control class="padding-left-collapse">';
        strTemplate += '<en-field>';
        strTemplate += '<en-input '+(angular.isDefined($attrs.flex) ? ' flex':'')+'>';
        strTemplate += '<input type="text" ng-model="search" placeholder="{{ placeholder || \'Search\'}}" ng-blur="onSubmit(true)" en-enter="onSubmit(true)">';
        strTemplate += '<en-icon icon="x-circle" en-tap="reset;" class="is-clickable" ng-show="search!=\'\' && search!=undefined"></en-icon>';
        strTemplate += '</en-input>';
        strTemplate += '<button type="button" class="en-button en-collection-search-button" ng-tap="onSubmit(true)">';
        strTemplate += '<en-icon icon="search" class="ng-scope"></en-icon>';
        strTemplate += '</button>';
        strTemplate += '</en-field>';
        strTemplate += '</en-control>';
        strTemplate += '</form>';

        return strTemplate;
    }


    return {
        restrict:'E',
        scope:{
            object:'=',
            placeholder:'@',
            fields:'@'
        },
        template: resolveTemplate,
        controller: ["$scope", "$attrs", function($scope,$attrs){
            $scope.reset = function(){
                $scope.search = '';
                $scope.onSubmit();
            };

            $scope.onSubmit = function(bolReset){
                if(!bolReset){
                    bolReset = false; //flag for resetting page to 1 in object
                }

                if($scope.search!==$scope.previousSearch){
                    $scope.previousSearch = $scope.search+'';

                    if($scope.search!==''){
                        var aryFields = $attrs.fields.split(',');
                        var strFilter = '';
                        var lngFields = aryFields.length;
                        for(var i=0;i<lngFields;i++){
                            if(aryFields[i]!==''){
                                if(strFilter!=='') strFilter += '||';
                                strFilter += aryFields[i].replace(/^\s+|\s+$/g,'') + ':%' + $scope.search + '%';
                            }
                        }
                        $scope.object.q = $scope.search;
                        $scope.object.filter = strFilter;
                    }else{
                        $scope.object.q = '';
                        $scope.object.filter = '';
                    }

                    if($attrs.urlEnabled && !$scope.isModal){
                        if ($scope.search !== '') {
                            $location.search({'q':$scope.search});
                        } else {
                            $location.search({'q':null});
                        }
                    }

                    $scope.object.refresh(bolReset);
                }
            };
        }],
        link: function($scope, $element, $attrs) {
            if(!angular.isDefined($attrs.object)){
                console.warn('en-collection-search must define an object.');
                return false;
            }

            if(!angular.isDefined($attrs.fields)){
                console.warn('en-collection-search must have at least on field defined.');
                return false;
            }

            var watchSearch;
            if($attrs.urlEnabled && !$scope.isModal){
                var locationSearch = $location.search();
                if(angular.isDefined(locationSearch.q)){
                    if(locationSearch.q!==''){
                        $scope.search = locationSearch.q;
                        $scope.onSubmit();
                    }
                }

                var checkLocation = function(){
                    var locationSearch = $location.search();
                    if(angular.isDefined(locationSearch.q)){
                        if($scope.previousSearch !== locationSearch.q){
                            $scope.search = locationSearch.q;
                            $scope.onSubmit();
                        }
                    }
                };

                $scope.$on('$locationChangeSuccess', function(){
                    checkLocation();
                });

                /*Fix for page refresh*/
                var initWatch = $scope.$watch(function(){ return $location.search(); },function(newVal,oldVal){
                    checkLocation();
                    initWatch();
                });
            }
        }
    };
}]);

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';
    angular.module('enspire.ui.components.icon').directive('enIconAction', IconActionDirective);

    function IconActionDirective($enPopover) {

        return {
            restrict    : 'E',
            compile     : compile
        };

        function compile($element, $attrs) {
            //capture raw contents and remove from element before it is compiled
            var icon = $attrs.icon || 'gear';

            var actionContents = $element.html()+'';
            if($attrs.type==='button'){
                $element.html('<en-button><en-icon icon="'+icon+'"></en-icon></en-button>');
            }else{
                $element.html('<en-icon icon="'+icon+'"></en-icon>');
            }

            return function postLink($scope, $element, $attrs, $enCollectionCtrl) {
                var $el = angular.element( $element[0]).find('en-icon');

                if($attrs.type==='button'){
                    $el = angular.element( $element[0]).find('button');
                }

                $enPopover( $el, {
                    scope: $scope,
                    inlineTemplate: true,
                    content: actionContents,
                    viewport: {selector:'en-win-body'},
                    customClass: 'popover-dark',
                    autoClose: true,
                    html: true,
                    placement: 'auto'
                });
            };
        }
    }
    IconActionDirective.$inject = ["$enPopover"];
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function () {
    'use strict';

    angular.module('enspire.ui.components.menu')
        .controller('enMenuItemController', MenuItemController)

    /*
     * @private
     * @ngdoc controller
     * @name MenuController
     * @module enspire.ui.components.menu
     *
     */
    function MenuItemController($scope, $element, $attrs) {
        var self = this;
        //self.contentContainer = angular.element('<div class="md-tab-content ng-hide">');
        
        self.element = $element;
        self.hammertime = new Hammer($element);
        


    }
    MenuItemController.$inject = ["$scope", "$element", "$attrs"];

})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
'use strict';


    angular.module('enspire.ui.components.menu').directive('enMenuItem', MenuItemDirective);


    /**
     * @ngdoc directive
     * @name enMenuItem
     * @module enspire.ui.components.menu
     * @restrict E
     * @description
     * `en-menu-item` directive description.
     *
     * @element en-menu-item
     *
     * @param {string} [name="My Item Text"] Displays text within the `<en-menu-item>`.
     * @param {string} Displays icon within the `<en-menu-item>`.
     * @param {string} Displays label within the `<en-menu-item>`. Add classes (color, size, type) for styling: `label="label-primary round"`.
     * @param {string} Adds data within label `label-data="{{obj.field}}"`.
     *
     * @usage
     * <hljs lang="html">
 *       <en-menu>
 *           <en-menu-item name="My Item Text"></en-menu-item>
 *       </en-menu>
     * </hljs>
     */
    function MenuItemDirective($location, $enTouch, $timeout, $compile) {
        return {
            restrict    : 'E',
            require     : ['^enMenu'],
            transclude  : true,
            replace     : true,
            template    : '<li class="en-menu-item"></li>',
            compile     : compile
        };

        function compile($scope, $element, $attrs){
            return function ($scope, $element, $attrs, $menuCtrl, $transclude) {
                $transclude($scope, function(clone){
                    $element.append(clone);
                    return $timeout(function(){ postLink($scope, $element, $attrs, $menuCtrl); });
                });
            };
        }

        function postLink($scope, $element, $attrs, $menuItemsCtrl){
            $menuItemsCtrl = $menuItemsCtrl[0];
            var trigger = (angular.isDefined($attrs.ngHref)) ?
                    angular.element('<a ng-href="'+$attrs.ngHref+'" class="en-menu-trigger"></a>') :
                    angular.element('<div class="en-menu-trigger" en-></div>'),
                icon,
                label,
                name;

            if (angular.isDefined($attrs.icon) && $attrs.icon!==''){
                icon = angular.element('<en-icon icon="'+$attrs.icon+'" class="en-menu-icon"></en-icon>');
                trigger.append(icon);
            }
            if (angular.isDefined($attrs.name)){
                name = angular.element('<div class="en-menu-name">'+$attrs.name+'</div>');
                trigger.append(name);
            }
            if (angular.isDefined($attrs.label) && $attrs.label!==''){
                label = angular.element('<en-label class="' + $attrs.label + '">' + $attrs.labelData + '</en-label>');
                trigger.append(label);
            }

            $element.prepend(trigger);

            $compile(trigger)($scope);

            var touch = $enTouch.element(trigger);
            touch.on('tap', openMenuItem);

            function openMenuItem(){
                $menuItemsCtrl.activate($element);
                if(angular.isDefined($attrs.location)){
                    $timeout(function(){ $location.url($attrs.location); });
                }
            }

            var obvName = $attrs.$observe('name',function(){
                name.html($attrs.name);
            });

            var obvIcon = $attrs.$observe('icon',function(){
                icon.attr('icon',$attrs.icon);
            });

            var obvLabel = $attrs.$observe('label' ,function(){
                label.attr('label', $attrs.label);
            });

            $element.bind('$destroy', destroyScope);

            function destroyScope(){
                touch.destroy();
                obvName();
                obvIcon();
                obvLabel();
            }
        }
    }
    MenuItemDirective.$inject = ["$location", "$enTouch", "$timeout", "$compile"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.modal')
        .directive('enModalBody', ModalBodyDirective);

    /**
     * @ngdoc directive
     * @name enModalBody
     * @module enspire.ui.components.modal
     *
     *
     * @restrict E
     *
     * @description
     * The `<en-modal-body>` directive...
     *
     */
    function ModalBodyDirective() {
        return {
            restrict    : 'E',
            require     : "^enModal"
        };
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.modal')
        .directive('enModalFooter', ModalFooterDirective);

    /**
     * @ngdoc directive
     * @name enModalFooter
     * @module enspire.ui.components.modal
     *
     * @restrict E
     *
     * @description
     * The `<en-modal-footer>` directive...
     *
     */
    function ModalFooterDirective() {
        return {
            restrict    : 'E',
            require     : "^enModal"
        };
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.modal')
        .directive('enModalHeader', ModalHeaderDirective);

    /**
     * @ngdoc directive
     * @name enModalHeader
     * @module enspire.ui.components.modal
     *
     * @restrict E
     *
     * @description
     * The `<en-modal-header>` directive...
     *
     */
    function ModalHeaderDirective() {
        return {
            restrict    : 'E',
            require     : "^enModal"
        };
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.screen')
        .directive('enScreenHeader', ScreenHeaderDirective);

    /**
     * @ngdoc directive
     * @name enScreenHeader
     * @module enspire.ui.components.screen
     *
     * @restrict E
     *
     * @param {string=}    title       Produces the title text of the `<en-screen-header>`. **Default: [ emtpy ]**
     * @param {boolean=}   fixed       When the `fixed` attribute is added to `<en-screen-header>`, the output element will be visually fixed 
     *                                 below the en-win-header.  This will cause the scrollable `<en-win-body>` element to be pushed down by the 
     *                                 height of the screen-header. **Allowed: Only requires the attribute of `fixed` be present.**
     *
     * @description
     * The `<en-screen-header>` directive...
     *
     */
    function ScreenHeaderDirective() {
        return {
            restrict: 'E',
            link    : postLink
        };

        function postLink($scope, $element, $attrs) {

            if (angular.isDefined($attrs.fixed)) {
                angular.element(document.querySelector('en-win > en-header')).after($element.addClass('fixed'));
            }

            $scope.$on('$destroy', function () {
                $element.remove();
            });

            $attrs.$observe('title', function (value) {
                $element.find('.en-screen-header-title').text(value);
            });
        }
    }
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.tabs')
        .directive('enTab', TabDirective);


    /**
     * @ngdoc directive
     * @name enTab
     * @module enspire.ui.components.tabs
     * @restrict E
     *
     * @element en-tab
     *
     * @param {string=}      width          Sets width of tab.
     * @param {string=}      state          Sets state for loading tab content via routes.
     * @param {string=}      location       Sets state location for tab.
     * @param {string=}      pane           Pane content that should load into the tab if set.
     * @param {boolean=}     active         Determines active tab.
     *
     * @description
     * Produces a div which contains tab content; requires en-tabs directive.
     */

    function TabDirective($timeout,$rootScope,$enTabs,$enTouch,$stateParams) {
        return {
            restrict: 'E',
            require: '^enTabs',
            link: postLink
        };

        function postLink($scope, $element, $attrs, $enTabsCtrl) {
            $element.addClass('en-tab');

            angular.isDefined($attrs.width) ? $element.css('width', $attrs.width + 'px') : '';


            var touch = $enTouch.element($element);
            $scope.$on('$destroy', function () {
                touch.destroy();
            });

            if (angular.isDefined($attrs.state) || angular.isDefined($attrs.location)) {
                touch.on('tap', function () {
                    $enTabsCtrl.onState($attrs.state, $attrs.location);
                });
            }

            if (angular.isDefined($attrs.pane)) {
                touch.on('tap', function () {
                    $enTabsCtrl.onPane($attrs.pane);
                });
            }

            if ($attrs.active === 'true'){
                $enTabsCtrl.onPane($attrs.pane);
            }

            var panes = $enTabsCtrl.panes();
            var pane = $attrs.pane;
            var checkActive = function (obj) {
                if ($attrs.pane !== undefined) {
                    ($enTabs.selected(panes) === pane) ? $element.addClass('active') : $element.removeClass('active');
                }
                if ($attrs.state !== undefined) {
                    (obj[$enTabsCtrl.view()] === $attrs.state) ? $element.addClass('active') : $element.removeClass('active');
                }
            };

            $timeout(function () {
                checkActive($stateParams);
            });

            if ($attrs.state !== undefined) {
                $scope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
                    if (toParams[$enTabsCtrl.view()] !== undefined){
                        checkActive(toParams);
                    }
                });
            }

            if ($attrs.pane !== undefined) {
                $scope.$watch(function () {
                    return $enTabs.selected(panes);
                }, function (newVal, oldVal) {
                    if (newVal !== oldVal){
                        checkActive();
                    }
                });
            }
        }
    }
    TabDirective.$inject = ["$timeout", "$rootScope", "$enTabs", "$enTouch", "$stateParams"];
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';


    angular.module('enspire.ui.components.tabs')
        .directive('enTabPane', TabPaneDirective);


    /**
     * @ngdoc directive
     * @name enTabPane
     * @module enspire.ui.components.tabs
     * @restrict E
     * @description
     * `en-tab-pane`...
     *
     * @element en-tab-pane
     *
     * @param {string=}      name   Tab pane name to associate appropriate tab.
     *
     */

    function TabPaneDirective($timeout, $rootScope, $enTabs) {
        return {
            restrict: 'E',
            require: '^enTabPanes',
            link: postLink
        };

        function postLink($scope, $element, $attrs, $tabPanesCtrl) {
            $element.addClass('en-tab-pane');
            var panes = $tabPanesCtrl.name();
            var pane = $attrs.name;

            if ($attrs.active == 'true'){
                $tabPanesCtrl.select(pane);
            }

            var checkActive = function () {
                ($enTabs.selected(panes) === pane) ? $element.addClass('active') : $element.removeClass('active');
            };

            $timeout(function () {
                checkActive();
            });

            if (angular.isDefined($attrs.name)) {
                $scope.$watch(function () {
                    return $enTabs.selected(panes);
                }, function (newVal, oldVal) {
                    if (newVal !== oldVal){
                        checkActive();
                    }
                });
            }
        }
    }
    TabPaneDirective.$inject = ["$timeout", "$rootScope", "$enTabs"];
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';

    angular.module('enspire.ui.components.tabs')
        .controller('enTabPanesController', TabPanesController);
    
    /*
     * @private
     * @ngdoc controller
     * @name TabPanesController
     * @module enspire.ui.components.tabs
     *
     */
    function TabPanesController($scope, $element, $attrs, $enTabs, $timeout) {
        this.name = function(){
            return $attrs.name;
        };

        this.select = function(pane){
            console.log('$attrs.name: '+$attrs.name);
            $timeout(function() { $enTabs.select($attrs.name, pane); });
        };
    }
    TabPanesController.$inject = ["$scope", "$element", "$attrs", "$enTabs", "$timeout"];
    
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function(){
    'use strict';


    angular.module('enspire.ui.components.tabs')
        .directive('enTabPanes', TabPanesDirective);


    /**
     * @ngdoc directive
     * @name enTabPanes
     * @module enspire.ui.components.tabs
     * @restrict E
     * @description
     * `en-tab-panes` is a wrapper that's used to group `<en-tab-pane>` elements together.
     *
     * @element en-tab-panes
     *
     * @param {string=}      name                 Name of the en-tab-pane element that will be referenced by `<en-tabs panes="nameOfEnTabPane"></en-tabs>`.
     *
     */

    function TabPanesDirective($timeout,$location,$rootScope,$enTabs) {
        return {
            restrict: 'E',
            controller: 'enTabPanesController',
            link: postLink
        };

        function postLink($scope, $element, $attrs) {
            if($attrs.name){
                $enTabs.addContainer($attrs.name);
            }
        }
    }
    TabPanesDirective.$inject = ["$timeout", "$location", "$rootScope", "$enTabs"];
})();
/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.win')
        .directive('enWinBody', WinBodyDirective);

    /**
     * @ngdoc directive
     * @name enWinBody
     * @module enspire.ui.components.win
     *
     * @restrict E
     *
     * @description
     * The `<en-win-body>` directive...
     *
     */
    function WinBodyDirective($rootScope) {
        return {
            restrict    : 'E',
            require     : '^enWin',
            //transclude  : true,
            link        : postLink
        };

        function postLink($scope, $element, $attrs, $controller, $transclude) {
            //$transclude($scope, function (clone) {
            //    //var winBodyContent = angular.element('<en-win-body-content></en-win-body-content>').append(clone)
            //    //$element.append(winBodyContent);
            //    $element.append(clone);
            //});
            
            $rootScope.$on('$locationChangeSuccess', onLocationChange);
            
            function onLocationChange(){
                //Resets the scrollable body's scrollTop back to its top.
                $element[0].scrollTop = 0;
            }
        }
    }
    WinBodyDirective.$inject = ["$rootScope"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.win')
        .directive('enWinFooter', WinFooterDirective);

    /**
     * @ ngdoc directive
     * @ name enWinFooter
     * @ module enspire.ui.components.win
     *
     * @ restrict E
     *
     * @ description
     * The `<en-win-footer>` directive...
     *
     */
    function WinFooterDirective() {
        return {
            restrict    : 'E',
            require     : '^enWin'
        };
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.win')
        .directive('enWinHeader', WinHeaderDirective);

    /**
     * @ngdoc directive
     * @name enWinHeader
     * @module enspire.ui.components.win
     *
     * @restrict E
     *
     * @description
     * The `<en-win-header>` directive...
     *
     */
    function WinHeaderDirective() {
        return {
            restrict    : 'E',
            require     : '^enWin'
        };
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.adapter').factory('enAdapterActionContains', ComponentService);

    function ComponentService() {

        // Action :contains()
        function ComponentFactory(params) {
            var output = [],
                context = params.context,
                source = params.source,
                // Note using boolean searchKeysAndValues to distinguish
                // between *:contains() or :contains()
                searchKeysAndValues = (~source.prevRule.indexOf('*')),
                ruleValue = params.ruleValue.replace(/^['"]|['"]$/g, ''),
                propName;

            /**
             * Searches an object for partial match on either
             * keys or values.
             * @param {object}  obj            - Object to search
             * @param {string}  needle         - String to search for.
             * @param {boolean} searchKeys     - Optional. Defaults to false.
             * @param {string}  keyRestriction - Optional. Search only specified key name.
             *                                   Default undefined.
             */
            function searchObject(obj, needle, searchKeys, keyRestriction) {
                var match, value;
                searchKeys = (searchKeys === undefined) ? false: searchKeys;

                // Loop thru
                for (var prop in obj) {
                    if (obj.hasOwnProperty(prop)) {
                        // partial match has been found
                        if (searchKeys && ~String(prop).indexOf(needle)) {
                            match = obj;
                            break;
                        }
                        value = obj[prop];

                        // Restrict search to specific key name
                        if (keyRestriction && prop !== keyRestriction) continue;

                        // search only strings or arrays
                        if ( angular.isObject(value) || angular.isFunction(value) || !angular.isDefined(value) ) continue;

                        // Found partial match
                        if (~String(value).indexOf(needle)) {
                            match = obj;
                            break;
                        }
                    }
                }
                return match;
            }

            // If not *:contains() grab obj context two steps back
            // but only search object values
            // Ex: *.foo.*.bar:contains('e')
            //           ^____________________ Get this context
            if (!searchKeysAndValues) {
                context = source.results[ source.ruleIndex - 2 ];
                // Perform :contains only on specified prop name.
                propName = source.prevRule.substr(1);
            }

            // Search within an array
            if (params.isArray) {
                context.forEach(function(item){
                    if (searchObject(item, ruleValue, searchKeysAndValues, propName)) {
                        output.push(item);
                    }
                })
            // Search within an object
            } else if (params.isObject) {
                (searchObject(context, ruleValue, searchKeysAndValues, propName)) && output.push(context);
            }
            // Error
            else {
                console.warn('enAdapter: Applying :contains rule action against a non-object! Passed in type: ' + typeof(context));
                output = context;
            }

            return output;
        }

        return ComponentFactory;
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.adapter').factory('enAdapterActionKeys', ComponentService);

    function ComponentService($parse) {

        // Action :keys()
        function ComponentFactory(params) {
            var output = [],
                context = params.context,
                keys = params.ruleValue,
                // Operate in :pluck mode and not :keys mode
                isPluckMode = (params.isPluckMode === undefined) ? false: params.isPluckMode;

            // Get array of keys to search for
            try {
                keys = $parse('[' + keys + ']')(params.scope);
            } catch(e) {
                console.warn('enAdapter: Invalid :keys() parameters! Passed in: ' + params.ruleValue);
                return output;
            }

            // If context is array
            if (params.isArray) {
                context.map(function(item){
                    // Loop thru keys for match against current object
                    keys.forEach(function(key){
                        if (item[key] !== undefined) {
                            output.push( isPluckMode ? item: item[key] );
                        }
                    });
                });
            }
            // context is an object
            else if (params.isObject) {
                // Loop thru keys for match against current object
                keys.forEach(function(key){
                    if (context[key] !== undefined) {
                        output.push( isPluckMode ? context: context[key]);
                    }
                });
            }
            // Error
            else {
                console.warn('enAdapter: Applying ' + params.ruleName + ' rule action against a non-object! Passed in type: ' + typeof(context));
                output = context;
            }

            return output;
        }

        return ComponentFactory;
    }
    ComponentService.$inject = ["$parse"];
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.adapter').factory('enAdapterObj2Array', ComponentService);

    function ComponentService() {

        // Action :obj2array()
        function ComponentFactory(params) {
            var output = [],
                context = params.context,
                ruleValue = params.ruleValue.replace(/^['"]|['"]$/g, '');

            function convertObj2Array(context, ruleValue) {
                var newArray = [],
                    includeKey = ( ruleValue && angular.isString(ruleValue) ) ? true: false,
                    obj;

                for (var prop in context) {
                    if (context.hasOwnProperty(prop)) {
                        obj = context[prop];
                    }
                    if (includeKey) {
                       obj[ruleValue] = prop;
                    }
                    newArray.push( obj );
                }
                return newArray;
            }

            // Take object within, coming from * rule
            if (params.isArray && context.length === 1) {
                context = context[0];
            }

            // Convert the object to an array
            if (params.isObject) {
                output = convertObj2Array(context, ruleValue);
            }
            // Error
            else {
                console.warn('enAdapter: Applying :obj2array rule action against a non-object! Passed in type: ' + typeof(context));
                output = context;
            }

            return output;
        }

        return ComponentFactory;
    }
})();

/*!
 * Enspire.UI
 * https://github.com/envistainteractive/enspire.ui
 * @license MIT
 * v0.9.4
 */
(function() {
    'use strict';

    angular.module('enspire.ui.components.adapter').factory('enAdapterSort', ComponentService);

    function ComponentService($parse) {

        // Action :sort()
        function ComponentFactory(params) {
            var output = [],
                context = params.context,
                scope = params.source.scope,
                sortFn = $parse( params.ruleValue.replace(/^['"]|['"]$/g, '') )(scope);

            if (params.isArray && !sortFn) {
                output = context.sort();
            } else if (params.isArray && angular.isFunction(sortFn)) {
                output = context.sort(sortFn);
            // Error
            } else {
                console.warn('enAdapter: Applying :sort rule action against a non-array! Passed in type: ' + typeof(context));
                console.log(context, typeof sortFn);
                output = context;
            }

            return output;
        }

        return ComponentFactory;
    }
    ComponentService.$inject = ["$parse"];
})();

angular.module("enspire.ui.core").constant("$MD_THEME_CSS", "");
/**
 * State-based routing for AngularJS
 * @version v0.2.13
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
"undefined"!=typeof module&&"undefined"!=typeof exports&&module.exports===exports&&(module.exports="ui.router"),function(a,b,c){"use strict";function d(a,b){return M(new(M(function(){},{prototype:a})),b)}function e(a){return L(arguments,function(b){b!==a&&L(b,function(b,c){a.hasOwnProperty(c)||(a[c]=b)})}),a}function f(a,b){var c=[];for(var d in a.path){if(a.path[d]!==b.path[d])break;c.push(a.path[d])}return c}function g(a){if(Object.keys)return Object.keys(a);var c=[];return b.forEach(a,function(a,b){c.push(b)}),c}function h(a,b){if(Array.prototype.indexOf)return a.indexOf(b,Number(arguments[2])||0);var c=a.length>>>0,d=Number(arguments[2])||0;for(d=0>d?Math.ceil(d):Math.floor(d),0>d&&(d+=c);c>d;d++)if(d in a&&a[d]===b)return d;return-1}function i(a,b,c,d){var e,i=f(c,d),j={},k=[];for(var l in i)if(i[l].params&&(e=g(i[l].params),e.length))for(var m in e)h(k,e[m])>=0||(k.push(e[m]),j[e[m]]=a[e[m]]);return M({},j,b)}function j(a,b,c){if(!c){c=[];for(var d in a)c.push(d)}for(var e=0;e<c.length;e++){var f=c[e];if(a[f]!=b[f])return!1}return!0}function k(a,b){var c={};return L(a,function(a){c[a]=b[a]}),c}function l(a){var b={},c=Array.prototype.concat.apply(Array.prototype,Array.prototype.slice.call(arguments,1));for(var d in a)-1==h(c,d)&&(b[d]=a[d]);return b}function m(a,b){var c=K(a),d=c?[]:{};return L(a,function(a,e){b(a,e)&&(d[c?d.length:e]=a)}),d}function n(a,b){var c=K(a)?[]:{};return L(a,function(a,d){c[d]=b(a,d)}),c}function o(a,b){var d=1,f=2,i={},j=[],k=i,m=M(a.when(i),{$$promises:i,$$values:i});this.study=function(i){function n(a,c){if(s[c]!==f){if(r.push(c),s[c]===d)throw r.splice(0,h(r,c)),new Error("Cyclic dependency: "+r.join(" -> "));if(s[c]=d,I(a))q.push(c,[function(){return b.get(a)}],j);else{var e=b.annotate(a);L(e,function(a){a!==c&&i.hasOwnProperty(a)&&n(i[a],a)}),q.push(c,a,e)}r.pop(),s[c]=f}}function o(a){return J(a)&&a.then&&a.$$promises}if(!J(i))throw new Error("'invocables' must be an object");var p=g(i||{}),q=[],r=[],s={};return L(i,n),i=r=s=null,function(d,f,g){function h(){--u||(v||e(t,f.$$values),r.$$values=t,r.$$promises=r.$$promises||!0,delete r.$$inheritedValues,n.resolve(t))}function i(a){r.$$failure=a,n.reject(a)}function j(c,e,f){function j(a){l.reject(a),i(a)}function k(){if(!G(r.$$failure))try{l.resolve(b.invoke(e,g,t)),l.promise.then(function(a){t[c]=a,h()},j)}catch(a){j(a)}}var l=a.defer(),m=0;L(f,function(a){s.hasOwnProperty(a)&&!d.hasOwnProperty(a)&&(m++,s[a].then(function(b){t[a]=b,--m||k()},j))}),m||k(),s[c]=l.promise}if(o(d)&&g===c&&(g=f,f=d,d=null),d){if(!J(d))throw new Error("'locals' must be an object")}else d=k;if(f){if(!o(f))throw new Error("'parent' must be a promise returned by $resolve.resolve()")}else f=m;var n=a.defer(),r=n.promise,s=r.$$promises={},t=M({},d),u=1+q.length/3,v=!1;if(G(f.$$failure))return i(f.$$failure),r;f.$$inheritedValues&&e(t,l(f.$$inheritedValues,p)),M(s,f.$$promises),f.$$values?(v=e(t,l(f.$$values,p)),r.$$inheritedValues=l(f.$$values,p),h()):(f.$$inheritedValues&&(r.$$inheritedValues=l(f.$$inheritedValues,p)),f.then(h,i));for(var w=0,x=q.length;x>w;w+=3)d.hasOwnProperty(q[w])?h():j(q[w],q[w+1],q[w+2]);return r}},this.resolve=function(a,b,c,d){return this.study(a)(b,c,d)}}function p(a,b,c){this.fromConfig=function(a,b,c){return G(a.template)?this.fromString(a.template,b):G(a.templateUrl)?this.fromUrl(a.templateUrl,b):G(a.templateProvider)?this.fromProvider(a.templateProvider,b,c):null},this.fromString=function(a,b){return H(a)?a(b):a},this.fromUrl=function(c,d){return H(c)&&(c=c(d)),null==c?null:a.get(c,{cache:b,headers:{Accept:"text/html"}}).then(function(a){return a.data})},this.fromProvider=function(a,b,d){return c.invoke(a,null,d||{params:b})}}function q(a,b,e){function f(b,c,d,e){if(q.push(b),o[b])return o[b];if(!/^\w+(-+\w+)*(?:\[\])?$/.test(b))throw new Error("Invalid parameter name '"+b+"' in pattern '"+a+"'");if(p[b])throw new Error("Duplicate parameter name '"+b+"' in pattern '"+a+"'");return p[b]=new O.Param(b,c,d,e),p[b]}function g(a,b,c){var d=["",""],e=a.replace(/[\\\[\]\^$*+?.()|{}]/g,"\\$&");if(!b)return e;switch(c){case!1:d=["(",")"];break;case!0:d=["?(",")?"];break;default:d=["("+c+"|",")?"]}return e+d[0]+b+d[1]}function h(c,e){var f,g,h,i,j;return f=c[2]||c[3],j=b.params[f],h=a.substring(m,c.index),g=e?c[4]:c[4]||("*"==c[1]?".*":null),i=O.type(g||"string")||d(O.type("string"),{pattern:new RegExp(g)}),{id:f,regexp:g,segment:h,type:i,cfg:j}}b=M({params:{}},J(b)?b:{});var i,j=/([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,k=/([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,l="^",m=0,n=this.segments=[],o=e?e.params:{},p=this.params=e?e.params.$$new():new O.ParamSet,q=[];this.source=a;for(var r,s,t;(i=j.exec(a))&&(r=h(i,!1),!(r.segment.indexOf("?")>=0));)s=f(r.id,r.type,r.cfg,"path"),l+=g(r.segment,s.type.pattern.source,s.squash),n.push(r.segment),m=j.lastIndex;t=a.substring(m);var u=t.indexOf("?");if(u>=0){var v=this.sourceSearch=t.substring(u);if(t=t.substring(0,u),this.sourcePath=a.substring(0,m+u),v.length>0)for(m=0;i=k.exec(v);)r=h(i,!0),s=f(r.id,r.type,r.cfg,"search"),m=j.lastIndex}else this.sourcePath=a,this.sourceSearch="";l+=g(t)+(b.strict===!1?"/?":"")+"$",n.push(t),this.regexp=new RegExp(l,b.caseInsensitive?"i":c),this.prefix=n[0],this.$$paramNames=q}function r(a){M(this,a)}function s(){function a(a){return null!=a?a.toString().replace(/\//g,"%2F"):a}function e(a){return null!=a?a.toString().replace(/%2F/g,"/"):a}function f(a){return this.pattern.test(a)}function i(){return{strict:t,caseInsensitive:p}}function j(a){return H(a)||K(a)&&H(a[a.length-1])}function k(){for(;x.length;){var a=x.shift();if(a.pattern)throw new Error("You cannot override a type's .pattern at runtime.");b.extend(v[a.name],o.invoke(a.def))}}function l(a){M(this,a||{})}O=this;var o,p=!1,t=!0,u=!1,v={},w=!0,x=[],y={string:{encode:a,decode:e,is:f,pattern:/[^/]*/},"int":{encode:a,decode:function(a){return parseInt(a,10)},is:function(a){return G(a)&&this.decode(a.toString())===a},pattern:/\d+/},bool:{encode:function(a){return a?1:0},decode:function(a){return 0!==parseInt(a,10)},is:function(a){return a===!0||a===!1},pattern:/0|1/},date:{encode:function(a){return this.is(a)?[a.getFullYear(),("0"+(a.getMonth()+1)).slice(-2),("0"+a.getDate()).slice(-2)].join("-"):c},decode:function(a){if(this.is(a))return a;var b=this.capture.exec(a);return b?new Date(b[1],b[2]-1,b[3]):c},is:function(a){return a instanceof Date&&!isNaN(a.valueOf())},equals:function(a,b){return this.is(a)&&this.is(b)&&a.toISOString()===b.toISOString()},pattern:/[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,capture:/([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/},json:{encode:b.toJson,decode:b.fromJson,is:b.isObject,equals:b.equals,pattern:/[^/]*/},any:{encode:b.identity,decode:b.identity,is:b.identity,equals:b.equals,pattern:/.*/}};s.$$getDefaultValue=function(a){if(!j(a.value))return a.value;if(!o)throw new Error("Injectable functions cannot be called at configuration time");return o.invoke(a.value)},this.caseInsensitive=function(a){return G(a)&&(p=a),p},this.strictMode=function(a){return G(a)&&(t=a),t},this.defaultSquashPolicy=function(a){if(!G(a))return u;if(a!==!0&&a!==!1&&!I(a))throw new Error("Invalid squash policy: "+a+". Valid policies: false, true, arbitrary-string");return u=a,a},this.compile=function(a,b){return new q(a,M(i(),b))},this.isMatcher=function(a){if(!J(a))return!1;var b=!0;return L(q.prototype,function(c,d){H(c)&&(b=b&&G(a[d])&&H(a[d]))}),b},this.type=function(a,b,c){if(!G(b))return v[a];if(v.hasOwnProperty(a))throw new Error("A type named '"+a+"' has already been defined.");return v[a]=new r(M({name:a},b)),c&&(x.push({name:a,def:c}),w||k()),this},L(y,function(a,b){v[b]=new r(M({name:b},a))}),v=d(v,{}),this.$get=["$injector",function(a){return o=a,w=!1,k(),L(y,function(a,b){v[b]||(v[b]=new r(a))}),this}],this.Param=function(a,b,d,e){function f(a){var b=J(a)?g(a):[],c=-1===h(b,"value")&&-1===h(b,"type")&&-1===h(b,"squash")&&-1===h(b,"array");return c&&(a={value:a}),a.$$fn=j(a.value)?a.value:function(){return a.value},a}function i(b,c,d){if(b.type&&c)throw new Error("Param '"+a+"' has two type configurations.");return c?c:b.type?b.type instanceof r?b.type:new r(b.type):"config"===d?v.any:v.string}function k(){var b={array:"search"===e?"auto":!1},c=a.match(/\[\]$/)?{array:!0}:{};return M(b,c,d).array}function l(a,b){var c=a.squash;if(!b||c===!1)return!1;if(!G(c)||null==c)return u;if(c===!0||I(c))return c;throw new Error("Invalid squash policy: '"+c+"'. Valid policies: false, true, or arbitrary string")}function p(a,b,d,e){var f,g,i=[{from:"",to:d||b?c:""},{from:null,to:d||b?c:""}];return f=K(a.replace)?a.replace:[],I(e)&&f.push({from:e,to:c}),g=n(f,function(a){return a.from}),m(i,function(a){return-1===h(g,a.from)}).concat(f)}function q(){if(!o)throw new Error("Injectable functions cannot be called at configuration time");return o.invoke(d.$$fn)}function s(a){function b(a){return function(b){return b.from===a}}function c(a){var c=n(m(w.replace,b(a)),function(a){return a.to});return c.length?c[0]:a}return a=c(a),G(a)?w.type.decode(a):q()}function t(){return"{Param:"+a+" "+b+" squash: '"+z+"' optional: "+y+"}"}var w=this;d=f(d),b=i(d,b,e);var x=k();b=x?b.$asArray(x,"search"===e):b,"string"!==b.name||x||"path"!==e||d.value!==c||(d.value="");var y=d.value!==c,z=l(d,y),A=p(d,x,y,z);M(this,{id:a,type:b,location:e,array:x,squash:z,replace:A,isOptional:y,value:s,dynamic:c,config:d,toString:t})},l.prototype={$$new:function(){return d(this,M(new l,{$$parent:this}))},$$keys:function(){for(var a=[],b=[],c=this,d=g(l.prototype);c;)b.push(c),c=c.$$parent;return b.reverse(),L(b,function(b){L(g(b),function(b){-1===h(a,b)&&-1===h(d,b)&&a.push(b)})}),a},$$values:function(a){var b={},c=this;return L(c.$$keys(),function(d){b[d]=c[d].value(a&&a[d])}),b},$$equals:function(a,b){var c=!0,d=this;return L(d.$$keys(),function(e){var f=a&&a[e],g=b&&b[e];d[e].type.equals(f,g)||(c=!1)}),c},$$validates:function(a){var b,c,d,e=!0,f=this;return L(this.$$keys(),function(g){d=f[g],c=a[g],b=!c&&d.isOptional,e=e&&(b||!!d.type.is(c))}),e},$$parent:c},this.ParamSet=l}function t(a,d){function e(a){var b=/^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(a.source);return null!=b?b[1].replace(/\\(.)/g,"$1"):""}function f(a,b){return a.replace(/\$(\$|\d{1,2})/,function(a,c){return b["$"===c?0:Number(c)]})}function g(a,b,c){if(!c)return!1;var d=a.invoke(b,b,{$match:c});return G(d)?d:!0}function h(d,e,f,g){function h(a,b,c){return"/"===p?a:b?p.slice(0,-1)+a:c?p.slice(1)+a:a}function m(a){function b(a){var b=a(f,d);return b?(I(b)&&d.replace().url(b),!0):!1}if(!a||!a.defaultPrevented){var e=o&&d.url()===o;if(o=c,e)return!0;var g,h=j.length;for(g=0;h>g;g++)if(b(j[g]))return;k&&b(k)}}function n(){return i=i||e.$on("$locationChangeSuccess",m)}var o,p=g.baseHref(),q=d.url();return l||n(),{sync:function(){m()},listen:function(){return n()},update:function(a){return a?void(q=d.url()):void(d.url()!==q&&(d.url(q),d.replace()))},push:function(a,b,e){d.url(a.format(b||{})),o=e&&e.$$avoidResync?d.url():c,e&&e.replace&&d.replace()},href:function(c,e,f){if(!c.validates(e))return null;var g=a.html5Mode();b.isObject(g)&&(g=g.enabled);var i=c.format(e);if(f=f||{},g||null===i||(i="#"+a.hashPrefix()+i),i=h(i,g,f.absolute),!f.absolute||!i)return i;var j=!g&&i?"/":"",k=d.port();return k=80===k||443===k?"":":"+k,[d.protocol(),"://",d.host(),k,j,i].join("")}}}var i,j=[],k=null,l=!1;this.rule=function(a){if(!H(a))throw new Error("'rule' must be a function");return j.push(a),this},this.otherwise=function(a){if(I(a)){var b=a;a=function(){return b}}else if(!H(a))throw new Error("'rule' must be a function");return k=a,this},this.when=function(a,b){var c,h=I(b);if(I(a)&&(a=d.compile(a)),!h&&!H(b)&&!K(b))throw new Error("invalid 'handler' in when()");var i={matcher:function(a,b){return h&&(c=d.compile(b),b=["$match",function(a){return c.format(a)}]),M(function(c,d){return g(c,b,a.exec(d.path(),d.search()))},{prefix:I(a.prefix)?a.prefix:""})},regex:function(a,b){if(a.global||a.sticky)throw new Error("when() RegExp must not be global or sticky");return h&&(c=b,b=["$match",function(a){return f(c,a)}]),M(function(c,d){return g(c,b,a.exec(d.path()))},{prefix:e(a)})}},j={matcher:d.isMatcher(a),regex:a instanceof RegExp};for(var k in j)if(j[k])return this.rule(i[k](a,b));throw new Error("invalid 'what' in when()")},this.deferIntercept=function(a){a===c&&(a=!0),l=a},this.$get=h,h.$inject=["$location","$rootScope","$injector","$browser"]}function u(a,e){function f(a){return 0===a.indexOf(".")||0===a.indexOf("^")}function l(a,b){if(!a)return c;var d=I(a),e=d?a:a.name,g=f(e);if(g){if(!b)throw new Error("No reference point given for path '"+e+"'");b=l(b);for(var h=e.split("."),i=0,j=h.length,k=b;j>i;i++)if(""!==h[i]||0!==i){if("^"!==h[i])break;if(!k.parent)throw new Error("Path '"+e+"' not valid for state '"+b.name+"'");k=k.parent}else k=b;h=h.slice(i).join("."),e=k.name+(k.name&&h?".":"")+h}var m=y[e];return!m||!d&&(d||m!==a&&m.self!==a)?c:m}function m(a,b){z[a]||(z[a]=[]),z[a].push(b)}function o(a){for(var b=z[a]||[];b.length;)p(b.shift())}function p(b){b=d(b,{self:b,resolve:b.resolve||{},toString:function(){return this.name}});var c=b.name;if(!I(c)||c.indexOf("@")>=0)throw new Error("State must have a valid name");if(y.hasOwnProperty(c))throw new Error("State '"+c+"'' is already defined");var e=-1!==c.indexOf(".")?c.substring(0,c.lastIndexOf(".")):I(b.parent)?b.parent:J(b.parent)&&I(b.parent.name)?b.parent.name:"";if(e&&!y[e])return m(e,b.self);for(var f in B)H(B[f])&&(b[f]=B[f](b,B.$delegates[f]));return y[c]=b,!b[A]&&b.url&&a.when(b.url,["$match","$stateParams",function(a,c){x.$current.navigable==b&&j(a,c)||x.transitionTo(b,a,{inherit:!0,location:!1})}]),o(c),b}function q(a){return a.indexOf("*")>-1}function r(a){var b=a.split("."),c=x.$current.name.split(".");if("**"===b[0]&&(c=c.slice(h(c,b[1])),c.unshift("**")),"**"===b[b.length-1]&&(c.splice(h(c,b[b.length-2])+1,Number.MAX_VALUE),c.push("**")),b.length!=c.length)return!1;for(var d=0,e=b.length;e>d;d++)"*"===b[d]&&(c[d]="*");return c.join("")===b.join("")}function s(a,b){return I(a)&&!G(b)?B[a]:H(b)&&I(a)?(B[a]&&!B.$delegates[a]&&(B.$delegates[a]=B[a]),B[a]=b,this):this}function t(a,b){return J(a)?b=a:b.name=a,p(b),this}function u(a,e,f,h,m,o,p){function s(b,c,d,f){var g=a.$broadcast("$stateNotFound",b,c,d);if(g.defaultPrevented)return p.update(),B;if(!g.retry)return null;if(f.$retry)return p.update(),C;var h=x.transition=e.when(g.retry);return h.then(function(){return h!==x.transition?u:(b.options.$retry=!0,x.transitionTo(b.to,b.toParams,b.options))},function(){return B}),p.update(),h}function t(a,c,d,g,i,j){var l=d?c:k(a.params.$$keys(),c),n={$stateParams:l};i.resolve=m.resolve(a.resolve,n,i.resolve,a);var o=[i.resolve.then(function(a){i.globals=a})];return g&&o.push(g),L(a.views,function(c,d){var e=c.resolve&&c.resolve!==a.resolve?c.resolve:{};e.$template=[function(){return f.load(d,{view:c,locals:n,params:l,notify:j.notify})||""}],o.push(m.resolve(e,n,i.resolve,a).then(function(f){if(H(c.controllerProvider)||K(c.controllerProvider)){var g=b.extend({},e,n);f.$$controller=h.invoke(c.controllerProvider,null,g)}else f.$$controller=c.controller;f.$$state=a,f.$$controllerAs=c.controllerAs,i[d]=f}))}),e.all(o).then(function(){return i})}var u=e.reject(new Error("transition superseded")),z=e.reject(new Error("transition prevented")),B=e.reject(new Error("transition aborted")),C=e.reject(new Error("transition failed"));return w.locals={resolve:null,globals:{$stateParams:{}}},x={params:{},current:w.self,$current:w,transition:null},x.reload=function(){return x.transitionTo(x.current,o,{reload:!0,inherit:!1,notify:!0})},x.go=function(a,b,c){return x.transitionTo(a,b,M({inherit:!0,relative:x.$current},c))},x.transitionTo=function(b,c,f){c=c||{},f=M({location:!0,inherit:!1,relative:null,notify:!0,reload:!1,$retry:!1},f||{});var g,j=x.$current,m=x.params,n=j.path,q=l(b,f.relative);if(!G(q)){var r={to:b,toParams:c,options:f},y=s(r,j.self,m,f);if(y)return y;if(b=r.to,c=r.toParams,f=r.options,q=l(b,f.relative),!G(q)){if(!f.relative)throw new Error("No such state '"+b+"'");throw new Error("Could not resolve '"+b+"' from state '"+f.relative+"'")}}if(q[A])throw new Error("Cannot transition to abstract state '"+b+"'");if(f.inherit&&(c=i(o,c||{},x.$current,q)),!q.params.$$validates(c))return C;c=q.params.$$values(c),b=q;var B=b.path,D=0,E=B[D],F=w.locals,H=[];if(!f.reload)for(;E&&E===n[D]&&E.ownParams.$$equals(c,m);)F=H[D]=E.locals,D++,E=B[D];if(v(b,j,F,f))return b.self.reloadOnSearch!==!1&&p.update(),x.transition=null,e.when(x.current);if(c=k(b.params.$$keys(),c||{}),f.notify&&a.$broadcast("$stateChangeStart",b.self,c,j.self,m).defaultPrevented)return p.update(),z;for(var I=e.when(F),J=D;J<B.length;J++,E=B[J])F=H[J]=d(F),I=t(E,c,E===b,I,F,f);var K=x.transition=I.then(function(){var d,e,g;if(x.transition!==K)return u;for(d=n.length-1;d>=D;d--)g=n[d],g.self.onExit&&h.invoke(g.self.onExit,g.self,g.locals.globals),g.locals=null;for(d=D;d<B.length;d++)e=B[d],e.locals=H[d],e.self.onEnter&&h.invoke(e.self.onEnter,e.self,e.locals.globals);return x.transition!==K?u:(x.$current=b,x.current=b.self,x.params=c,N(x.params,o),x.transition=null,f.location&&b.navigable&&p.push(b.navigable.url,b.navigable.locals.globals.$stateParams,{$$avoidResync:!0,replace:"replace"===f.location}),f.notify&&a.$broadcast("$stateChangeSuccess",b.self,c,j.self,m),p.update(!0),x.current)},function(d){return x.transition!==K?u:(x.transition=null,g=a.$broadcast("$stateChangeError",b.self,c,j.self,m,d),g.defaultPrevented||p.update(),e.reject(d))});return K},x.is=function(a,b,d){d=M({relative:x.$current},d||{});var e=l(a,d.relative);return G(e)?x.$current!==e?!1:b?j(e.params.$$values(b),o):!0:c},x.includes=function(a,b,d){if(d=M({relative:x.$current},d||{}),I(a)&&q(a)){if(!r(a))return!1;a=x.$current.name}var e=l(a,d.relative);return G(e)?G(x.$current.includes[e.name])?b?j(e.params.$$values(b),o,g(b)):!0:!1:c},x.href=function(a,b,d){d=M({lossy:!0,inherit:!0,absolute:!1,relative:x.$current},d||{});var e=l(a,d.relative);if(!G(e))return null;d.inherit&&(b=i(o,b||{},x.$current,e));var f=e&&d.lossy?e.navigable:e;return f&&f.url!==c&&null!==f.url?p.href(f.url,k(e.params.$$keys(),b||{}),{absolute:d.absolute}):null},x.get=function(a,b){if(0===arguments.length)return n(g(y),function(a){return y[a].self});var c=l(a,b||x.$current);return c&&c.self?c.self:null},x}function v(a,b,c,d){return a!==b||(c!==b.locals||d.reload)&&a.self.reloadOnSearch!==!1?void 0:!0}var w,x,y={},z={},A="abstract",B={parent:function(a){if(G(a.parent)&&a.parent)return l(a.parent);var b=/^(.+)\.[^.]+$/.exec(a.name);return b?l(b[1]):w},data:function(a){return a.parent&&a.parent.data&&(a.data=a.self.data=M({},a.parent.data,a.data)),a.data},url:function(a){var b=a.url,c={params:a.params||{}};if(I(b))return"^"==b.charAt(0)?e.compile(b.substring(1),c):(a.parent.navigable||w).url.concat(b,c);if(!b||e.isMatcher(b))return b;throw new Error("Invalid url '"+b+"' in state '"+a+"'")},navigable:function(a){return a.url?a:a.parent?a.parent.navigable:null},ownParams:function(a){var b=a.url&&a.url.params||new O.ParamSet;return L(a.params||{},function(a,c){b[c]||(b[c]=new O.Param(c,null,a,"config"))}),b},params:function(a){return a.parent&&a.parent.params?M(a.parent.params.$$new(),a.ownParams):new O.ParamSet},views:function(a){var b={};return L(G(a.views)?a.views:{"":a},function(c,d){d.indexOf("@")<0&&(d+="@"+a.parent.name),b[d]=c}),b},path:function(a){return a.parent?a.parent.path.concat(a):[]},includes:function(a){var b=a.parent?M({},a.parent.includes):{};return b[a.name]=!0,b},$delegates:{}};w=p({name:"",url:"^",views:null,"abstract":!0}),w.navigable=null,this.decorator=s,this.state=t,this.$get=u,u.$inject=["$rootScope","$q","$view","$injector","$resolve","$stateParams","$urlRouter","$location","$urlMatcherFactory"]}function v(){function a(a,b){return{load:function(c,d){var e,f={template:null,controller:null,view:null,locals:null,notify:!0,async:!0,params:{}};return d=M(f,d),d.view&&(e=b.fromConfig(d.view,d.params,d.locals)),e&&d.notify&&a.$broadcast("$viewContentLoading",d),e}}}this.$get=a,a.$inject=["$rootScope","$templateFactory"]}function w(){var a=!1;this.useAnchorScroll=function(){a=!0},this.$get=["$anchorScroll","$timeout",function(b,c){return a?b:function(a){c(function(){a[0].scrollIntoView()},0,!1)}}]}function x(a,c,d,e){function f(){return c.has?function(a){return c.has(a)?c.get(a):null}:function(a){try{return c.get(a)}catch(b){return null}}}function g(a,b){var c=function(){return{enter:function(a,b,c){b.after(a),c()},leave:function(a,b){a.remove(),b()}}};if(j)return{enter:function(a,b,c){var d=j.enter(a,null,b,c);d&&d.then&&d.then(c)},leave:function(a,b){var c=j.leave(a,b);c&&c.then&&c.then(b)}};if(i){var d=i&&i(b,a);return{enter:function(a,b,c){d.enter(a,null,b),c()},leave:function(a,b){d.leave(a),b()}}}return c()}var h=f(),i=h("$animator"),j=h("$animate"),k={restrict:"ECA",terminal:!0,priority:400,transclude:"element",compile:function(c,f,h){return function(c,f,i){function j(){l&&(l.remove(),l=null),n&&(n.$destroy(),n=null),m&&(r.leave(m,function(){l=null}),l=m,m=null)}function k(g){var k,l=z(c,i,f,e),s=l&&a.$current&&a.$current.locals[l];if(g||s!==o){k=c.$new(),o=a.$current.locals[l];var t=h(k,function(a){r.enter(a,f,function(){n&&n.$emit("$viewContentAnimationEnded"),(b.isDefined(q)&&!q||c.$eval(q))&&d(a)}),j()});m=t,n=k,n.$emit("$viewContentLoaded"),n.$eval(p)}}var l,m,n,o,p=i.onload||"",q=i.autoscroll,r=g(i,c);c.$on("$stateChangeSuccess",function(){k(!1)}),c.$on("$viewContentLoading",function(){k(!1)}),k(!0)}}};return k}function y(a,b,c,d){return{restrict:"ECA",priority:-400,compile:function(e){var f=e.html();return function(e,g,h){var i=c.$current,j=z(e,h,g,d),k=i&&i.locals[j];if(k){g.data("$uiView",{name:j,state:k.$$state}),g.html(k.$template?k.$template:f);var l=a(g.contents());if(k.$$controller){k.$scope=e;var m=b(k.$$controller,k);k.$$controllerAs&&(e[k.$$controllerAs]=m),g.data("$ngControllerController",m),g.children().data("$ngControllerController",m)}l(e)}}}}}function z(a,b,c,d){var e=d(b.uiView||b.name||"")(a),f=c.inheritedData("$uiView");return e.indexOf("@")>=0?e:e+"@"+(f?f.state.name:"")}function A(a,b){var c,d=a.match(/^\s*({[^}]*})\s*$/);if(d&&(a=b+"("+d[1]+")"),c=a.replace(/\n/g," ").match(/^([^(]+?)\s*(\((.*)\))?$/),!c||4!==c.length)throw new Error("Invalid state ref '"+a+"'");return{state:c[1],paramExpr:c[3]||null}}function B(a){var b=a.parent().inheritedData("$uiView");return b&&b.state&&b.state.name?b.state:void 0}function C(a,c){var d=["location","inherit","reload"];return{restrict:"A",require:["?^uiSrefActive","?^uiSrefActiveEq"],link:function(e,f,g,h){var i=A(g.uiSref,a.current.name),j=null,k=B(f)||a.$current,l=null,m="A"===f.prop("tagName"),n="FORM"===f[0].nodeName,o=n?"action":"href",p=!0,q={relative:k,inherit:!0},r=e.$eval(g.uiSrefOpts)||{};b.forEach(d,function(a){a in r&&(q[a]=r[a])});var s=function(c){if(c&&(j=b.copy(c)),p){l=a.href(i.state,j,q);var d=h[1]||h[0];return d&&d.$$setStateInfo(i.state,j),null===l?(p=!1,!1):void g.$set(o,l)}};i.paramExpr&&(e.$watch(i.paramExpr,function(a){a!==j&&s(a)},!0),j=b.copy(e.$eval(i.paramExpr))),s(),n||f.bind("click",function(b){var d=b.which||b.button;if(!(d>1||b.ctrlKey||b.metaKey||b.shiftKey||f.attr("target"))){var e=c(function(){a.go(i.state,j,q)});b.preventDefault();var g=m&&!l?1:0;b.preventDefault=function(){g--<=0&&c.cancel(e)}}})}}}function D(a,b,c){return{restrict:"A",controller:["$scope","$element","$attrs",function(b,d,e){function f(){g()?d.addClass(j):d.removeClass(j)}function g(){return"undefined"!=typeof e.uiSrefActiveEq?h&&a.is(h.name,i):h&&a.includes(h.name,i)}var h,i,j;j=c(e.uiSrefActiveEq||e.uiSrefActive||"",!1)(b),this.$$setStateInfo=function(b,c){h=a.get(b,B(d)),i=c,f()},b.$on("$stateChangeSuccess",f)}]}}function E(a){var b=function(b){return a.is(b)};return b.$stateful=!0,b}function F(a){var b=function(b){return a.includes(b)};return b.$stateful=!0,b}var G=b.isDefined,H=b.isFunction,I=b.isString,J=b.isObject,K=b.isArray,L=b.forEach,M=b.extend,N=b.copy;b.module("ui.router.util",["ng"]),b.module("ui.router.router",["ui.router.util"]),b.module("ui.router.state",["ui.router.router","ui.router.util"]),b.module("ui.router",["ui.router.state"]),b.module("ui.router.compat",["ui.router"]),o.$inject=["$q","$injector"],b.module("ui.router.util").service("$resolve",o),p.$inject=["$http","$templateCache","$injector"],b.module("ui.router.util").service("$templateFactory",p);var O;q.prototype.concat=function(a,b){var c={caseInsensitive:O.caseInsensitive(),strict:O.strictMode(),squash:O.defaultSquashPolicy()};return new q(this.sourcePath+a+this.sourceSearch,M(c,b),this)},q.prototype.toString=function(){return this.source},q.prototype.exec=function(a,b){function c(a){function b(a){return a.split("").reverse().join("")}function c(a){return a.replace(/\\-/,"-")}var d=b(a).split(/-(?!\\)/),e=n(d,b);return n(e,c).reverse()}var d=this.regexp.exec(a);if(!d)return null;b=b||{};var e,f,g,h=this.parameters(),i=h.length,j=this.segments.length-1,k={};if(j!==d.length-1)throw new Error("Unbalanced capture group in route '"+this.source+"'");for(e=0;j>e;e++){g=h[e];var l=this.params[g],m=d[e+1];for(f=0;f<l.replace;f++)l.replace[f].from===m&&(m=l.replace[f].to);m&&l.array===!0&&(m=c(m)),k[g]=l.value(m)}for(;i>e;e++)g=h[e],k[g]=this.params[g].value(b[g]);return k},q.prototype.parameters=function(a){return G(a)?this.params[a]||null:this.$$paramNames},q.prototype.validates=function(a){return this.params.$$validates(a)},q.prototype.format=function(a){function b(a){return encodeURIComponent(a).replace(/-/g,function(a){return"%5C%"+a.charCodeAt(0).toString(16).toUpperCase()})}a=a||{};var c=this.segments,d=this.parameters(),e=this.params;if(!this.validates(a))return null;var f,g=!1,h=c.length-1,i=d.length,j=c[0];for(f=0;i>f;f++){var k=h>f,l=d[f],m=e[l],o=m.value(a[l]),p=m.isOptional&&m.type.equals(m.value(),o),q=p?m.squash:!1,r=m.type.encode(o);if(k){var s=c[f+1];if(q===!1)null!=r&&(j+=K(r)?n(r,b).join("-"):encodeURIComponent(r)),j+=s;else if(q===!0){var t=j.match(/\/$/)?/\/?(.*)/:/(.*)/;j+=s.match(t)[1]}else I(q)&&(j+=q+s)}else{if(null==r||p&&q!==!1)continue;K(r)||(r=[r]),r=n(r,encodeURIComponent).join("&"+l+"="),j+=(g?"&":"?")+(l+"="+r),g=!0}}return j},r.prototype.is=function(){return!0},r.prototype.encode=function(a){return a},r.prototype.decode=function(a){return a},r.prototype.equals=function(a,b){return a==b},r.prototype.$subPattern=function(){var a=this.pattern.toString();return a.substr(1,a.length-2)},r.prototype.pattern=/.*/,r.prototype.toString=function(){return"{Type:"+this.name+"}"},r.prototype.$asArray=function(a,b){function d(a,b){function d(a,b){return function(){return a[b].apply(a,arguments)}}function e(a){return K(a)?a:G(a)?[a]:[]}function f(a){switch(a.length){case 0:return c;case 1:return"auto"===b?a[0]:a;default:return a}}function g(a){return!a}function h(a,b){return function(c){c=e(c);var d=n(c,a);return b===!0?0===m(d,g).length:f(d)}}function i(a){return function(b,c){var d=e(b),f=e(c);if(d.length!==f.length)return!1;for(var g=0;g<d.length;g++)if(!a(d[g],f[g]))return!1;return!0}}this.encode=h(d(a,"encode")),this.decode=h(d(a,"decode")),this.is=h(d(a,"is"),!0),this.equals=i(d(a,"equals")),this.pattern=a.pattern,this.$arrayMode=b}if(!a)return this;if("auto"===a&&!b)throw new Error("'auto' array mode is for query parameters only");return new d(this,a)},b.module("ui.router.util").provider("$urlMatcherFactory",s),b.module("ui.router.util").run(["$urlMatcherFactory",function(){}]),t.$inject=["$locationProvider","$urlMatcherFactoryProvider"],b.module("ui.router.router").provider("$urlRouter",t),u.$inject=["$urlRouterProvider","$urlMatcherFactoryProvider"],b.module("ui.router.state").value("$stateParams",{}).provider("$state",u),v.$inject=[],b.module("ui.router.state").provider("$view",v),b.module("ui.router.state").provider("$uiViewScroll",w),x.$inject=["$state","$injector","$uiViewScroll","$interpolate"],y.$inject=["$compile","$controller","$state","$interpolate"],b.module("ui.router.state").directive("uiView",x),b.module("ui.router.state").directive("uiView",y),C.$inject=["$state","$timeout"],D.$inject=["$state","$stateParams","$interpolate"],b.module("ui.router.state").directive("uiSref",C).directive("uiSrefActive",D).directive("uiSrefActiveEq",D),E.$inject=["$state"],F.$inject=["$state"],b.module("ui.router.state").filter("isState",E).filter("includedByState",F)}(window,window.angular);
var DocsApp = angular.module('docsApp', ['enspire.ui', 'ngRoute', 'ui.router'])

.config([
  'COMPONENTS',
  'DEMOS',
  'PAGES',
  '$routeProvider',
function(COMPONENTS, DEMOS, PAGES, $routeProvider) {
  $routeProvider
    .when('/', {
      templateUrl: 'partials/home.tmpl.html'
    })
    .when('/layout/:tmpl', {
      templateUrl: function(params){
        return 'partials/layout-' + params.tmpl + '.tmpl.html';
      }
    });

  angular.forEach(PAGES, function(pages, area) {
    angular.forEach(pages, function(page) {
      $routeProvider
        .when(page.url, {
          templateUrl: page.outputPath,
          controller: 'GuideCtrl'
        });
    });
  });

  angular.forEach(COMPONENTS, function(component) {
    angular.forEach(component.docs, function(doc) {
      doc.url = '/' + doc.url;
      $routeProvider.when(doc.url, {
        templateUrl: doc.outputPath,
        resolve: {
          component: function() { return component; },
          doc: function() { return doc; }
        },
        controller: 'ComponentDocCtrl'
      });
    });
  });

  angular.forEach(DEMOS, function(componentDemos) {
    var demoComponent;
    angular.forEach(COMPONENTS, function(component) {
      if (componentDemos.name === component.name) {
        demoComponent = component;
      }
    });
    demoComponent = demoComponent || angular.extend({}, componentDemos);
    $routeProvider.when(componentDemos.url, {
      templateUrl: 'partials/demo.tmpl.html',
      controller: 'DemoCtrl',
      resolve: {
        component: function() { return demoComponent; },
        demos: function() { return componentDemos.demos; }
      }
    });
  });

  $routeProvider.otherwise('/');
}])

.factory('menu', [
  'COMPONENTS',
  'DEMOS',
  'PAGES',
  '$location',
  '$rootScope',
function(COMPONENTS, DEMOS, PAGES, $location, $rootScope) {

    var sections = [];

    var apiDocs = {};
    COMPONENTS.forEach(function(component){

        if(component.docs.length > 1){
            var docIndex = 0;
            var tempDoc = null;
            component.docs.forEach(function(doc){
                if(angular.isDefined(doc.private)){
                    return;
                }
                if(doc.type === 'directive'){
                    if(docIndex===0){
                        tempDoc = doc;
                    }else{
                        tempDoc['pages'] = tempDoc['pages'] || [];
                        tempDoc['pages'].push(doc);
                    }
                    docIndex+=1;
                }else{
                    apiDocs[doc.type] = apiDocs[doc.type] || [];
                    apiDocs[doc.type].push(doc);
                }
            });
            if(tempDoc){
                apiDocs['directive'] = apiDocs['directive'] || [];
                if(angular.isArray(tempDoc.pages)){
                    tempDoc.pages.sort(sortByName);
                }
                apiDocs['directive'].push(tempDoc);
            }
        }else{
            component.docs.forEach(function(doc){
                if(angular.isDefined(doc.private)) return;
                apiDocs[doc.type] = apiDocs[doc.type] || [];
                apiDocs[doc.type].push(doc);
            });
        }
    });

  var demoDocs = [];
  angular.forEach(DEMOS, function(componentDemos) {
    demoDocs.push({
      name: componentDemos.label,
      url: componentDemos.url
    });
  });

    sections.unshift({
        name: 'Demos',
        icon: 'eye-visible',
        pages: demoDocs.sort(sortByName)
    });

    sections.unshift({
        name: 'Services',
        icon: 'matrix',
        pages: (apiDocs.service===undefined) ? [] : apiDocs.service.sort(sortByName)
    });

    sections.unshift({
        name: 'Components',
        icon: 'gears',
        pages: (apiDocs.directive===undefined) ? [] : apiDocs.directive.sort(sortByName)
    });

  angular.forEach(PAGES, function(pages, area) {
    sections.push({
      name: area,
      icon: 'folder',
      pages: pages
    });
  });


  function sortByName(a,b) {
    return a.name < b.name ? -1 : 1;
  }

  var self;

  $rootScope.$on('$locationChangeSuccess', onLocationChange);

  return self = {
    sections: sections,

    selectSection: function(section) {
      self.openedSection = section;
    },
    toggleSelectSection: function(section) {
      self.openedSection = (self.openedSection === section ? null : section);
    },
    isSectionSelected: function(section) {
      return self.openedSection === section;
    },
    selectPage: function(section, page, subpage) {
        page && page.url && (angular.isDefined(subpage) ? $location.path(subpage.url) : $location.path(page.url) );
        self.currentSection = section;
        self.currentPage = page;
        self.currentSubPage = subpage;
    },
    isPageSelected: function(section, page) {
      return self.currentPage === page;
    },
    isSubPageSelected: function(section, subpage) {
      return self.currentSubPage === subpage;
    }
  };

  function sortByHumanName(a,b) {
    return (a.humanName < b.humanName) ? -1 :
      (a.humanName > b.humanName) ? 1 : 0;
  }

    function onLocationChange(){
        var activated = false;
        var path = $location.path();

        sections.forEach(function(section){
            section.pages.forEach(function(page){
                if(path === page.url){
                    self.selectSection(section);
                    self.selectPage(section, page);
                    activated = true;
                }else if(page.pages && page.pages.length > 0){
                    page.pages.forEach(function(subpage){
                        if(path === subpage.url){
                            self.selectSection(section);
                            self.selectPage(section, page, subpage);
                            activated = true;
                        }
                    });
                }
            });
        });
        if(!activated){
            self.selectSection(sections[3]);
        }
    }
}])

.controller('DocsCtrl', [
  '$scope',
  'COMPONENTS',
  'SERVICES',
  'BUILDCONFIG',
  '$timeout',
  'menu',
  '$location',
  '$rootScope',
function($scope, COMPONENTS, SERVICES, BUILDCONFIG, $timeout, menu, $location, $rootScope) {
  $scope.COMPONENTS = COMPONENTS;
  $scope.BUILDCONFIG = BUILDCONFIG;
  $scope.SERVICES = SERVICES;

  $scope.menu = menu;

  $scope.path = function() {
    return $location.path();
  };
}])

.controller('HomeCtrl', [
  '$scope',
  '$rootScope',
  '$http',
function($scope, $rootScope, $http) {
  $rootScope.currentComponent = $rootScope.currentDoc = null;

  $scope.version = "";
  $scope.versionURL = "";

  // Load build version information; to be
  // used in the header bar area
  var now = Math.round(new Date().getTime()/1000);
  var versionFile = "version.json" + "?ts=" + now;

  $http.get("version.json")
    .then(function(response){
      var sha = response.data.sha || "";
      var url = response.data.url;

      if (sha) {
        $scope.versionURL = url + sha;
        $scope.version = sha.substr(0,6);
      }
    });


}])


.controller('GuideCtrl', [
  '$rootScope',
function($rootScope) {
  $rootScope.currentComponent = $rootScope.currentDoc = null;
}])



.controller('ComponentDocCtrl', [
  '$scope',
  'doc',
  'component',
  '$rootScope',
  '$templateCache',
  '$http',
  '$q',
function($scope, doc, component, $rootScope, $templateCache, $http, $q) {
  $rootScope.currentComponent = component;
  $rootScope.currentDoc = doc;
}])

.controller('DemoCtrl', [
  '$rootScope',
  '$scope',
  'component',
  'demos',
  '$http',
  '$templateCache',
  '$q',
function($rootScope, $scope, component, demos, $http, $templateCache, $q) {
  $rootScope.currentComponent = component;
  $rootScope.currentDoc = null;

  $scope.demos = [];

  angular.forEach(demos, function(demo) {
    // Get displayed contents (un-minified)
    var files = [demo.index]
      .concat(demo.js || [])
      .concat(demo.css || [])
      .concat(demo.html || []);
    files.forEach(function(file) {
      file.httpPromise =$http.get(file.outputPath, {cache: $templateCache})
        .then(function(response) {
          file.contents = response.data
            .replace('<head/>', '');
          return file.contents;
        });
    });
    demo.$files = files;
    $scope.demos.push(demo);
  });

  $scope.demos = $scope.demos.sort(function(a,b) {
    return a.name > b.name ? 1 : -1;
  });

}])

.filter('humanizeDoc', function() {
  return function(doc) {
    if (!doc) return;
    if (doc.type === 'directive') {
      return doc.name.replace(/([A-Z])/g, function($1) {
        return '-'+$1.toLowerCase();
      });
    }
    return doc.label || doc.name;
  };
})

.filter('directiveBrackets', function() {
  return function(str) {
    if (str.indexOf('-') > -1) {
      return '<' + str + '>';
    }
    return str;
  };
})


.directive('fixLink', function(){
    return {
        restrict    : 'A',
        link      : function($scope,$element,$attrs){
           var link = $element.find('a');

               if(link.attr('href') && link.attr('href').charAt(0)!=='#'){
                   link.attr('href', '#/'+link.attr('href'));
               }
        }
    };

});


;

DocsApp.constant('BUILDCONFIG', {
  "name": "enspire.ui",
  "ngVersion": "1.4.3",
  "version": "0.9.4",
  "repository": "https://github.com/envistaInteractive/enspire.ui",
  "commit": "1e5c2454b43a9fc1f9a884520a1fc9d33d5035a5",
  "date": "2016-08-17 15:18:23 -0400"
});

DocsApp
.constant('COMPONENTS', [
  {
    "name": "enspire.ui.core",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.core/index.html",
    "url": "api/enspire.ui.core",
    "label": "enspire.ui.core",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "$enConfig",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.core/service/$enConfig.html",
        "url": "api/enspire.ui.core/service/$enConfig",
        "label": "$enConfig",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core/enspire.ui.coreService.js",
        "hasDemo": false
      },
      {
        "name": "$uuid",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.core/service/$uuid.html",
        "url": "api/enspire.ui.core/service/$uuid",
        "label": "$uuid",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core/enspire.ui.coreService.js"
      },
      {
        "name": "$uom",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.core/service/$uom.html",
        "url": "api/enspire.ui.core/service/$uom",
        "label": "$uom",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core/enspire.ui.coreService.js"
      },
      {
        "name": "blank",
        "type": "filter",
        "outputPath": "partials/api/enspire.ui.core/filter/blank.html",
        "url": "api/enspire.ui.core/filter/blank",
        "label": "blank",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core"
      },
      {
        "name": "blank",
        "type": "filter",
        "outputPath": "partials/api/enspire.ui.core/filter/blank.html",
        "url": "api/enspire.ui.core/filter/blank",
        "label": "blank",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core"
      },
      {
        "name": "$enDimensions",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.core/service/$enDimensions.html",
        "url": "api/enspire.ui.core/service/$enDimensions",
        "label": "$enDimensions",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core/enspire.ui.coreService.js"
      },
      {
        "name": "pixel",
        "type": "filter",
        "outputPath": "partials/api/enspire.ui.core/filter/pixel.html",
        "url": "api/enspire.ui.core/filter/pixel",
        "label": "pixel",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core"
      },
      {
        "name": "$enPosition",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.core/service/$enPosition.html",
        "url": "api/enspire.ui.core/service/$enPosition",
        "label": "$enPosition",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core/enspire.ui.coreService.js"
      },
      {
        "name": "prettyDate",
        "type": "filter",
        "outputPath": "partials/api/enspire.ui.core/filter/prettyDate.html",
        "url": "api/enspire.ui.core/filter/prettyDate",
        "label": "prettyDate",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core"
      },
      {
        "name": "reverse",
        "type": "filter",
        "outputPath": "partials/api/enspire.ui.core/filter/reverse.html",
        "url": "api/enspire.ui.core/filter/reverse",
        "label": "reverse",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core"
      },
      {
        "name": "$enBase64",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.core/service/$enBase64.html",
        "url": "api/enspire.ui.core/service/$enBase64",
        "label": "$enBase64",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core/enspire.ui.coreService.js"
      },
      {
        "name": "$enLocalStorageProvider",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.core/service/$enLocalStorageProvider.html",
        "url": "api/enspire.ui.core/service/$enLocalStorageProvider",
        "label": "$enLocalStorageProvider",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core/enspire.ui.coreService.js"
      },
      {
        "name": "$enLocalStorage",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.core/service/$enLocalStorage.html",
        "url": "api/enspire.ui.core/service/$enLocalStorage",
        "label": "$enLocalStorage",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core/enspire.ui.coreService.js"
      },
      {
        "name": "$enTouch",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.core/service/$enTouch.html",
        "url": "api/enspire.ui.core/service/$enTouch",
        "label": "$enTouch",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/enspire.ui.core/enspire.ui.coreService.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "material.core.util",
    "type": "module",
    "outputPath": "partials/api/material.core.util/index.html",
    "url": "api/material.core.util",
    "label": "material.core.util",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "mdAutofocus",
        "type": "directive",
        "outputPath": "partials/api/material.core.util/directive/mdAutofocus.html",
        "url": "api/material.core.util/directive/mdAutofocus",
        "label": "mdAutofocus",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/material.core.util/material.core.utilDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.auth",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.auth/index.html",
    "url": "api/enspire.ui.components.auth",
    "label": "enspire.ui.components.auth",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enAuth",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.auth/directive/enAuth.html",
        "url": "api/enspire.ui.components.auth/directive/enAuth",
        "label": "enAuth",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/auth/authDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.body",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.body/index.html",
    "url": "api/enspire.ui.components.body",
    "label": "enspire.ui.components.body",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enBody",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.body/directive/enBody.html",
        "url": "api/enspire.ui.components.body/directive/enBody",
        "label": "enBody",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/body/bodyDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.field",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.field/index.html",
    "url": "api/enspire.ui.components.field",
    "label": "enspire.ui.components.field",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enField",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.field/directive/enField.html",
        "url": "api/enspire.ui.components.field/directive/enField",
        "label": "enField",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/field/fieldDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.footer",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.footer/index.html",
    "url": "api/enspire.ui.components.footer",
    "label": "enspire.ui.components.footer",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enFooter",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.footer/directive/enFooter.html",
        "url": "api/enspire.ui.components.footer/directive/enFooter",
        "label": "enFooter",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/footer/footerDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.header",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.header/index.html",
    "url": "api/enspire.ui.components.header",
    "label": "enspire.ui.components.header",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enHeader",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.header/directive/enHeader.html",
        "url": "api/enspire.ui.components.header/directive/enHeader",
        "label": "enHeader",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/header/headerDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.subheader",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.subheader/index.html",
    "url": "api/enspire.ui.components.subheader",
    "label": "enspire.ui.components.subheader",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enSubheader",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.subheader/directive/enSubheader.html",
        "url": "api/enspire.ui.components.subheader/directive/enSubheader",
        "label": "enSubheader",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/subheader/subheaderDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.action",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.action/index.html",
    "url": "api/enspire.ui.components.action",
    "label": "enspire.ui.components.action",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enActions",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.action/directive/enActions.html",
        "url": "api/enspire.ui.components.action/directive/enActions",
        "label": "enActions",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/action/actionDirective.js",
        "hasDemo": true
      },
      {
        "name": "enAction",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.action/directive/enAction.html",
        "url": "api/enspire.ui.components.action/directive/enAction",
        "label": "enAction",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/action/actionDirective.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.adapter",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.adapter/index.html",
    "url": "api/enspire.ui.components.adapter",
    "label": "enspire.ui.components.adapter",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enAdapter",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.adapter/directive/enAdapter.html",
        "url": "api/enspire.ui.components.adapter/directive/enAdapter",
        "label": "enAdapter",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/adapter/adapterDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.alert",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.alert/index.html",
    "url": "api/enspire.ui.components.alert",
    "label": "enspire.ui.components.alert",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enAlert",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.alert/directive/enAlert.html",
        "url": "api/enspire.ui.components.alert/directive/enAlert",
        "label": "enAlert",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/alert/alertDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.anchorScroll",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.anchorScroll/index.html",
    "url": "api/enspire.ui.components.anchorScroll",
    "label": "enspire.ui.components.anchorScroll",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "$enAnchorScroll",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.components.anchorScroll/service/$enAnchorScroll.html",
        "url": "api/enspire.ui.components.anchorScroll/service/$enAnchorScroll",
        "label": "$enAnchorScroll",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/anchorScroll/anchorScrollService.js",
        "hasDemo": false
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.api",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.api/index.html",
    "url": "api/enspire.ui.components.api",
    "label": "enspire.ui.components.api",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enApiObject",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.api/directive/enApiObject.html",
        "url": "api/enspire.ui.components.api/directive/enApiObject",
        "label": "enApiObject",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/api/apiDirective.js",
        "hasDemo": true
      },
      {
        "name": "$enApi",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.components.api/service/$enApi.html",
        "url": "api/enspire.ui.components.api/service/$enApi",
        "label": "$enApi",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/api/apiService.js"
      },
      {
        "name": "enApiSearchControls",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.api/directive/enApiSearchControls.html",
        "url": "api/enspire.ui.components.api/directive/enApiSearchControls",
        "label": "enApiSearchControls",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/api/apiDirective.js"
      },
      {
        "name": "enApiSearch",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.api/directive/enApiSearch.html",
        "url": "api/enspire.ui.components.api/directive/enApiSearch",
        "label": "enApiSearch",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/api/apiDirective.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.autocomplete",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.autocomplete/index.html",
    "url": "api/enspire.ui.components.autocomplete",
    "label": "enspire.ui.components.autocomplete",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enAutocomplete",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.autocomplete/directive/enAutocomplete.html",
        "url": "api/enspire.ui.components.autocomplete/directive/enAutocomplete",
        "label": "enAutocomplete",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/autocomplete/autocompleteDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.autofocus",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.autofocus/index.html",
    "url": "api/enspire.ui.components.autofocus",
    "label": "enspire.ui.components.autofocus",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enAutofocus",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.autofocus/directive/enAutofocus.html",
        "url": "api/enspire.ui.components.autofocus/directive/enAutofocus",
        "label": "enAutofocus",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/autofocus/autofocusDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.button",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.button/index.html",
    "url": "api/enspire.ui.components.button",
    "label": "enspire.ui.components.button",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enButton",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.button/directive/enButton.html",
        "url": "api/enspire.ui.components.button/directive/enButton",
        "label": "enButton",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/button/buttonDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.buttonGroup",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.buttonGroup/index.html",
    "url": "api/enspire.ui.components.buttonGroup",
    "label": "enspire.ui.components.buttonGroup",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enButtonGroup",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.buttonGroup/directive/enButtonGroup.html",
        "url": "api/enspire.ui.components.buttonGroup/directive/enButtonGroup",
        "label": "enButtonGroup",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/buttonGroup/buttonGroupDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.clipboard",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.clipboard/index.html",
    "url": "api/enspire.ui.components.clipboard",
    "label": "enspire.ui.components.clipboard",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enClipboard",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.clipboard/directive/enClipboard.html",
        "url": "api/enspire.ui.components.clipboard/directive/enClipboard",
        "label": "enClipboard",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/clipboard/clipboardDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.collapse",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.collapse/index.html",
    "url": "api/enspire.ui.components.collapse",
    "label": "enspire.ui.components.collapse",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enCollapse",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.collapse/directive/enCollapse.html",
        "url": "api/enspire.ui.components.collapse/directive/enCollapse",
        "label": "enCollapse",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/collapse/collapseDirective.js",
        "hasDemo": true
      },
      {
        "name": "$enCollapse",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.components.collapse/service/$enCollapse.html",
        "url": "api/enspire.ui.components.collapse/service/$enCollapse",
        "label": "$enCollapse",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/collapse/collapseService.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.collection",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.collection/index.html",
    "url": "api/enspire.ui.components.collection",
    "label": "enspire.ui.components.collection",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enCollection",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.collection/directive/enCollection.html",
        "url": "api/enspire.ui.components.collection/directive/enCollection",
        "label": "enCollection",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/collection/collectionDirective.js",
        "hasDemo": true
      },
      {
        "name": "enCollectionColumn",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.collection/directive/enCollectionColumn.html",
        "url": "api/enspire.ui.components.collection/directive/enCollectionColumn",
        "label": "enCollectionColumn",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/collection/collectionDirective.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.collectionRepeat",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.collectionRepeat/index.html",
    "url": "api/enspire.ui.components.collectionRepeat",
    "label": "enspire.ui.components.collectionRepeat",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enCollectionRepeat",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.collectionRepeat/directive/enCollectionRepeat.html",
        "url": "api/enspire.ui.components.collectionRepeat/directive/enCollectionRepeat",
        "label": "enCollectionRepeat",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/collectionRepeat/collectionRepeatDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.colorwheel",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.colorwheel/index.html",
    "url": "api/enspire.ui.components.colorwheel",
    "label": "enspire.ui.components.colorwheel",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enColorwheel",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.colorwheel/directive/enColorwheel.html",
        "url": "api/enspire.ui.components.colorwheel/directive/enColorwheel",
        "label": "enColorwheel",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/colorwheel/colorwheelDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.content",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.content/index.html",
    "url": "api/enspire.ui.components.content",
    "label": "enspire.ui.components.content",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enContent",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.content/directive/enContent.html",
        "url": "api/enspire.ui.components.content/directive/enContent",
        "label": "enContent",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/content/contentDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.control",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.control/index.html",
    "url": "api/enspire.ui.components.control",
    "label": "enspire.ui.components.control",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enControl",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.control/directive/enControl.html",
        "url": "api/enspire.ui.components.control/directive/enControl",
        "label": "enControl",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/control/controlDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.correlation",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.correlation/index.html",
    "url": "api/enspire.ui.components.correlation",
    "label": "enspire.ui.components.correlation",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enCorrelation",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.correlation/directive/enCorrelation.html",
        "url": "api/enspire.ui.components.correlation/directive/enCorrelation",
        "label": "enCorrelation",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/correlation/correlationDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.datepicker",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.datepicker/index.html",
    "url": "api/enspire.ui.components.datepicker",
    "label": "enspire.ui.components.datepicker",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enDatePicker",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.datepicker/directive/enDatePicker.html",
        "url": "api/enspire.ui.components.datepicker/directive/enDatePicker",
        "label": "enDatePicker",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/datepicker/datepickerDirective.js",
        "hasDemo": true
      },
      {
        "name": "$enDatePicker",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.components.datepicker/service/$enDatePicker.html",
        "url": "api/enspire.ui.components.datepicker/service/$enDatePicker",
        "label": "$enDatePicker",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/datepicker/datepickerService.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.dnd",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.dnd/index.html",
    "url": "api/enspire.ui.components.dnd",
    "label": "enspire.ui.components.dnd",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "dndDraggable",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.dnd/directive/dndDraggable.html",
        "url": "api/enspire.ui.components.dnd/directive/dndDraggable",
        "label": "dndDraggable",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/dnd/dndDirective.js",
        "hasDemo": true
      },
      {
        "name": "dndDraggable",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.dnd/directive/dndDraggable.html",
        "url": "api/enspire.ui.components.dnd/directive/dndDraggable",
        "label": "dndDraggable",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/dnd/dndDirective.js"
      },
      {
        "name": "dndList",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.dnd/directive/dndList.html",
        "url": "api/enspire.ui.components.dnd/directive/dndList",
        "label": "dndList",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/dnd/dndDirective.js"
      },
      {
        "name": "dndNodrag",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.dnd/directive/dndNodrag.html",
        "url": "api/enspire.ui.components.dnd/directive/dndNodrag",
        "label": "dndNodrag",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/dnd/dndDirective.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.draggable",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.draggable/index.html",
    "url": "api/enspire.ui.components.draggable",
    "label": "enspire.ui.components.draggable",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "DraggableController",
        "type": "function",
        "outputPath": "partials/api/enspire.ui.components.draggable/function/DraggableController.html",
        "url": "api/enspire.ui.components.draggable/function/DraggableController",
        "label": "DraggableController",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/draggable",
        "hasDemo": false
      },
      {
        "name": "enDraggable",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.draggable/directive/enDraggable.html",
        "url": "api/enspire.ui.components.draggable/directive/enDraggable",
        "label": "enDraggable",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/draggable/draggableDirective.js"
      },
      {
        "name": "$enDraggable",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.components.draggable/service/$enDraggable.html",
        "url": "api/enspire.ui.components.draggable/service/$enDraggable",
        "label": "$enDraggable",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/draggable/draggableService.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.error",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.error/index.html",
    "url": "api/enspire.ui.components.error",
    "label": "enspire.ui.components.error",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enError",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.error/directive/enError.html",
        "url": "api/enspire.ui.components.error/directive/enError",
        "label": "enError",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/error/errorDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.fileUpload",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.fileUpload/index.html",
    "url": "api/enspire.ui.components.fileUpload",
    "label": "enspire.ui.components.fileUpload",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "ngFileUpload",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.fileUpload/directive/ngFileUpload.html",
        "url": "api/enspire.ui.components.fileUpload/directive/ngFileUpload",
        "label": "ngFileUpload",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/fileUpload/fileUploadDirective.js",
        "hasDemo": true
      },
      {
        "name": "ngFileUpload",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.components.fileUpload/service/ngFileUpload.html",
        "url": "api/enspire.ui.components.fileUpload/service/ngFileUpload",
        "label": "ngFileUpload",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/fileUpload/fileUploadService.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.form",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.form/index.html",
    "url": "api/enspire.ui.components.form",
    "label": "enspire.ui.components.form",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "showErrors",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.form/directive/showErrors.html",
        "url": "api/enspire.ui.components.form/directive/showErrors",
        "label": "showErrors",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/form/formDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.icon",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.icon/index.html",
    "url": "api/enspire.ui.components.icon",
    "label": "enspire.ui.components.icon",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enIcon",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.icon/directive/enIcon.html",
        "url": "api/enspire.ui.components.icon/directive/enIcon",
        "label": "enIcon",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/icon/iconDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.include",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.include/index.html",
    "url": "api/enspire.ui.components.include",
    "label": "enspire.ui.components.include",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enInclude",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.include/directive/enInclude.html",
        "url": "api/enspire.ui.components.include/directive/enInclude",
        "label": "enInclude",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/include/includeDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.input",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.input/index.html",
    "url": "api/enspire.ui.components.input",
    "label": "enspire.ui.components.input",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enInput",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.input/directive/enInput.html",
        "url": "api/enspire.ui.components.input/directive/enInput",
        "label": "enInput",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/input/inputDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.inputTags",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.inputTags/index.html",
    "url": "api/enspire.ui.components.inputTags",
    "label": "enspire.ui.components.inputTags",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enInputTagsAutoComplete",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.inputTags/directive/enInputTagsAutoComplete.html",
        "url": "api/enspire.ui.components.inputTags/directive/enInputTagsAutoComplete",
        "label": "enInputTagsAutoComplete",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/inputTags/inputTagsDirective.js",
        "hasDemo": true
      },
      {
        "name": "enInputTags",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.inputTags/directive/enInputTags.html",
        "url": "api/enspire.ui.components.inputTags/directive/enInputTags",
        "label": "enInputTags",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/inputTags/inputTagsDirective.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.keyEvent",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.keyEvent/index.html",
    "url": "api/enspire.ui.components.keyEvent",
    "label": "enspire.ui.components.keyEvent",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enKeyEvent",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.keyEvent/directive/enKeyEvent.html",
        "url": "api/enspire.ui.components.keyEvent/directive/enKeyEvent",
        "label": "enKeyEvent",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/keyEvent/keyEventDirective.js",
        "hasDemo": true
      },
      {
        "name": "$keyEvent",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.components.keyEvent/service/$keyEvent.html",
        "url": "api/enspire.ui.components.keyEvent/service/$keyEvent",
        "label": "$keyEvent",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/keyEvent/keyEventService.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.label",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.label/index.html",
    "url": "api/enspire.ui.components.label",
    "label": "enspire.ui.components.label",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enLabel",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.label/directive/enLabel.html",
        "url": "api/enspire.ui.components.label/directive/enLabel",
        "label": "enLabel",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/label/labelDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.listObject",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.listObject/index.html",
    "url": "api/enspire.ui.components.listObject",
    "label": "enspire.ui.components.listObject",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enListObject",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.listObject/directive/enListObject.html",
        "url": "api/enspire.ui.components.listObject/directive/enListObject",
        "label": "enListObject",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/listObject/listObjectDirective.js",
        "hasDemo": true
      },
      {
        "name": "$enList",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.components.listObject/service/$enList.html",
        "url": "api/enspire.ui.components.listObject/service/$enList",
        "label": "$enList",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/listObject/listObjectService.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.loader",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.loader/index.html",
    "url": "api/enspire.ui.components.loader",
    "label": "enspire.ui.components.loader",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enLoader",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.loader/directive/enLoader.html",
        "url": "api/enspire.ui.components.loader/directive/enLoader",
        "label": "enLoader",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/loader/loaderDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.menu",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.menu/index.html",
    "url": "api/enspire.ui.components.menu",
    "label": "enspire.ui.components.menu",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enMenu",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.menu/directive/enMenu.html",
        "url": "api/enspire.ui.components.menu/directive/enMenu",
        "label": "enMenu",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/menu/menuDirective.js",
        "hasDemo": true
      },
      {
        "name": "enMenuItem",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.menu/directive/enMenuItem.html",
        "url": "api/enspire.ui.components.menu/directive/enMenuItem",
        "label": "enMenuItem",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/menu/menuDirective.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.modal",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.modal/index.html",
    "url": "api/enspire.ui.components.modal",
    "label": "enspire.ui.components.modal",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enModal",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.modal/directive/enModal.html",
        "url": "api/enspire.ui.components.modal/directive/enModal",
        "label": "enModal",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/modal/modalDirective.js",
        "hasDemo": true
      },
      {
        "name": "enModalBody",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.modal/directive/enModalBody.html",
        "url": "api/enspire.ui.components.modal/directive/enModalBody",
        "label": "enModalBody",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/modal/modalDirective.js"
      },
      {
        "name": "enModalFooter",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.modal/directive/enModalFooter.html",
        "url": "api/enspire.ui.components.modal/directive/enModalFooter",
        "label": "enModalFooter",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/modal/modalDirective.js"
      },
      {
        "name": "enModalHeader",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.modal/directive/enModalHeader.html",
        "url": "api/enspire.ui.components.modal/directive/enModalHeader",
        "label": "enModalHeader",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/modal/modalDirective.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.msg",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.msg/index.html",
    "url": "api/enspire.ui.components.msg",
    "label": "enspire.ui.components.msg",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enMsgs",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.msg/directive/enMsgs.html",
        "url": "api/enspire.ui.components.msg/directive/enMsgs",
        "label": "enMsgs",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/msg/msgDirective.js",
        "hasDemo": true
      },
      {
        "name": "enMsg",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.msg/directive/enMsg.html",
        "url": "api/enspire.ui.components.msg/directive/enMsg",
        "label": "enMsg",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/msg/msgDirective.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.multiSelect",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.multiSelect/index.html",
    "url": "api/enspire.ui.components.multiSelect",
    "label": "enspire.ui.components.multiSelect",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enMultiSelect",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.multiSelect/directive/enMultiSelect.html",
        "url": "api/enspire.ui.components.multiSelect/directive/enMultiSelect",
        "label": "enMultiSelect",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/multiSelect/multiSelectDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.nav",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.nav/index.html",
    "url": "api/enspire.ui.components.nav",
    "label": "enspire.ui.components.nav",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enNav",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.nav/directive/enNav.html",
        "url": "api/enspire.ui.components.nav/directive/enNav",
        "label": "enNav",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/nav/navDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.objectTree",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.objectTree/index.html",
    "url": "api/enspire.ui.components.objectTree",
    "label": "enspire.ui.components.objectTree",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enObjectTree",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.objectTree/directive/enObjectTree.html",
        "url": "api/enspire.ui.components.objectTree/directive/enObjectTree",
        "label": "enObjectTree",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/objectTree/objectTreeDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.objectDiff",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.objectDiff/index.html",
    "url": "api/enspire.ui.components.objectDiff",
    "label": "enspire.ui.components.objectDiff",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enObjectDiff",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.components.objectDiff/service/enObjectDiff.html",
        "url": "api/enspire.ui.components.objectDiff/service/enObjectDiff",
        "label": "enObjectDiff",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/objectDiff/objectDiffService.js",
        "hasDemo": false
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.panel",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.panel/index.html",
    "url": "api/enspire.ui.components.panel",
    "label": "enspire.ui.components.panel",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enPanel",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.panel/directive/enPanel.html",
        "url": "api/enspire.ui.components.panel/directive/enPanel",
        "label": "enPanel",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/panel/panelDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.passwordCheck",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.passwordCheck/index.html",
    "url": "api/enspire.ui.components.passwordCheck",
    "label": "enspire.ui.components.passwordCheck",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enPasswordCheck",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.passwordCheck/directive/enPasswordCheck.html",
        "url": "api/enspire.ui.components.passwordCheck/directive/enPasswordCheck",
        "label": "enPasswordCheck",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/passwordCheck/passwordCheckDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.popover",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.popover/index.html",
    "url": "api/enspire.ui.components.popover",
    "label": "enspire.ui.components.popover",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enPopover",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.popover/directive/enPopover.html",
        "url": "api/enspire.ui.components.popover/directive/enPopover",
        "label": "enPopover",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/popover/popoverDirective.js",
        "hasDemo": true
      },
      {
        "name": "$enPopover",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.components.popover/service/$enPopover.html",
        "url": "api/enspire.ui.components.popover/service/$enPopover",
        "label": "$enPopover",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/popover/popoverService.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.progress",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.progress/index.html",
    "url": "api/enspire.ui.components.progress",
    "label": "enspire.ui.components.progress",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enProgress",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.progress/directive/enProgress.html",
        "url": "api/enspire.ui.components.progress/directive/enProgress",
        "label": "enProgress",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/progress/progressDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.quote",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.quote/index.html",
    "url": "api/enspire.ui.components.quote",
    "label": "enspire.ui.components.quote",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enQuote",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.quote/directive/enQuote.html",
        "url": "api/enspire.ui.components.quote/directive/enQuote",
        "label": "enQuote",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/quote/quoteDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.screen",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.screen/index.html",
    "url": "api/enspire.ui.components.screen",
    "label": "enspire.ui.components.screen",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enScreen",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.screen/directive/enScreen.html",
        "url": "api/enspire.ui.components.screen/directive/enScreen",
        "label": "enScreen",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/screen/screenDirective.js",
        "hasDemo": true
      },
      {
        "name": "enScreenHeader",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.screen/directive/enScreenHeader.html",
        "url": "api/enspire.ui.components.screen/directive/enScreenHeader",
        "label": "enScreenHeader",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/screen/screenDirective.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.scrollbar",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.scrollbar/index.html",
    "url": "api/enspire.ui.components.scrollbar",
    "label": "enspire.ui.components.scrollbar",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enScrollbar",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.scrollbar/directive/enScrollbar.html",
        "url": "api/enspire.ui.components.scrollbar/directive/enScrollbar",
        "label": "enScrollbar",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/scrollbar/scrollbarDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.section",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.section/index.html",
    "url": "api/enspire.ui.components.section",
    "label": "enspire.ui.components.section",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enSection",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.section/directive/enSection.html",
        "url": "api/enspire.ui.components.section/directive/enSection",
        "label": "enSection",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/section/sectionDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.sortable",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.sortable/index.html",
    "url": "api/enspire.ui.components.sortable",
    "label": "enspire.ui.components.sortable",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enSortable",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.sortable/directive/enSortable.html",
        "url": "api/enspire.ui.components.sortable/directive/enSortable",
        "label": "enSortable",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/sortable/sortableDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.src",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.src/index.html",
    "url": "api/enspire.ui.components.src",
    "label": "enspire.ui.components.src",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enSrc",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.src/directive/enSrc.html",
        "url": "api/enspire.ui.components.src/directive/enSrc",
        "label": "enSrc",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/src/srcDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.tabs",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.tabs/index.html",
    "url": "api/enspire.ui.components.tabs",
    "label": "enspire.ui.components.tabs",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "TabsController",
        "type": "function",
        "outputPath": "partials/api/enspire.ui.components.tabs/function/TabsController.html",
        "url": "api/enspire.ui.components.tabs/function/TabsController",
        "label": "TabsController",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/tabs",
        "hasDemo": false
      },
      {
        "name": "enTabs",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.tabs/directive/enTabs.html",
        "url": "api/enspire.ui.components.tabs/directive/enTabs",
        "label": "enTabs",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/tabs/tabsDirective.js"
      },
      {
        "name": "$enTabs",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.components.tabs/service/$enTabs.html",
        "url": "api/enspire.ui.components.tabs/service/$enTabs",
        "label": "$enTabs",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/tabs/tabsService.js"
      },
      {
        "name": "enTab",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.tabs/directive/enTab.html",
        "url": "api/enspire.ui.components.tabs/directive/enTab",
        "label": "enTab",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/tabs/tabsDirective.js"
      },
      {
        "name": "enTabPane",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.tabs/directive/enTabPane.html",
        "url": "api/enspire.ui.components.tabs/directive/enTabPane",
        "label": "enTabPane",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/tabs/tabsDirective.js"
      },
      {
        "name": "enTabPanes",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.tabs/directive/enTabPanes.html",
        "url": "api/enspire.ui.components.tabs/directive/enTabPanes",
        "label": "enTabPanes",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/tabs/tabsDirective.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.time",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.time/index.html",
    "url": "api/enspire.ui.components.time",
    "label": "enspire.ui.components.time",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enTime",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.time/directive/enTime.html",
        "url": "api/enspire.ui.components.time/directive/enTime",
        "label": "enTime",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/time/timeDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.timeDuration",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.timeDuration/index.html",
    "url": "api/enspire.ui.components.timeDuration",
    "label": "enspire.ui.components.timeDuration",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enTimeDuration",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.timeDuration/directive/enTimeDuration.html",
        "url": "api/enspire.ui.components.timeDuration/directive/enTimeDuration",
        "label": "enTimeDuration",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/timeDuration/timeDurationDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.title",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.title/index.html",
    "url": "api/enspire.ui.components.title",
    "label": "enspire.ui.components.title",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enTitle",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.title/directive/enTitle.html",
        "url": "api/enspire.ui.components.title/directive/enTitle",
        "label": "enTitle",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/title/titleDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.tooltip",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.tooltip/index.html",
    "url": "api/enspire.ui.components.tooltip",
    "label": "enspire.ui.components.tooltip",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "TooltipController",
        "type": "function",
        "outputPath": "partials/api/enspire.ui.components.tooltip/function/TooltipController.html",
        "url": "api/enspire.ui.components.tooltip/function/TooltipController",
        "label": "TooltipController",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/tooltip",
        "hasDemo": false
      },
      {
        "name": "enTooltip",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.tooltip/directive/enTooltip.html",
        "url": "api/enspire.ui.components.tooltip/directive/enTooltip",
        "label": "enTooltip",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/tooltip/tooltipDirective.js"
      },
      {
        "name": "$enTooltip",
        "type": "service",
        "outputPath": "partials/api/enspire.ui.components.tooltip/service/$enTooltip.html",
        "url": "api/enspire.ui.components.tooltip/service/$enTooltip",
        "label": "$enTooltip",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/tooltip/tooltipService.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.tree",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.tree/index.html",
    "url": "api/enspire.ui.components.tree",
    "label": "enspire.ui.components.tree",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enTree",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.tree/directive/enTree.html",
        "url": "api/enspire.ui.components.tree/directive/enTree",
        "label": "enTree",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/tree/treeDirective.js",
        "hasDemo": true
      }
    ],
    "hasDemo": false
  },
  {
    "name": "material.components.virtualRepeat",
    "type": "module",
    "outputPath": "partials/api/material.components.virtualRepeat/index.html",
    "url": "api/material.components.virtualRepeat",
    "label": "material.components.virtualRepeat",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "mdVirtualRepeatContainer",
        "type": "directive",
        "outputPath": "partials/api/material.components.virtualRepeat/directive/mdVirtualRepeatContainer.html",
        "url": "api/material.components.virtualRepeat/directive/mdVirtualRepeatContainer",
        "label": "mdVirtualRepeatContainer",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/material.components.virtualRepeat/material.components.virtualRepeatDirective.js",
        "hasDemo": true
      },
      {
        "name": "mdVirtualRepeat",
        "type": "directive",
        "outputPath": "partials/api/material.components.virtualRepeat/directive/mdVirtualRepeat.html",
        "url": "api/material.components.virtualRepeat/directive/mdVirtualRepeat",
        "label": "mdVirtualRepeat",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/material.components.virtualRepeat/material.components.virtualRepeatDirective.js"
      }
    ],
    "hasDemo": false
  },
  {
    "name": "enspire.ui.components.win",
    "type": "module",
    "outputPath": "partials/api/enspire.ui.components.win/index.html",
    "url": "api/enspire.ui.components.win",
    "label": "enspire.ui.components.win",
    "module": "enspire.ui.components",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/.",
    "docs": [
      {
        "name": "enWin",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.win/directive/enWin.html",
        "url": "api/enspire.ui.components.win/directive/enWin",
        "label": "enWin",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/win/winDirective.js",
        "hasDemo": true
      },
      {
        "name": "enWinBody",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.win/directive/enWinBody.html",
        "url": "api/enspire.ui.components.win/directive/enWinBody",
        "label": "enWinBody",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/win/winDirective.js"
      },
      {
        "name": "enWinHeader",
        "type": "directive",
        "outputPath": "partials/api/enspire.ui.components.win/directive/enWinHeader.html",
        "url": "api/enspire.ui.components.win/directive/enWinHeader",
        "label": "enWinHeader",
        "module": "enspire.ui.components",
        "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/components/win/winDirective.js"
      }
    ],
    "hasDemo": false
  }
]);

DocsApp
.constant('PAGES', {
  "CSS": [
    {
      "name": "Generic Mixins",
      "outputPath": "partials/CSS/01_Mixins.html",
      "url": "/CSS/01_Mixins",
      "label": "Generic Mixins"
    },
    {
      "name": "Helpers",
      "outputPath": "partials/CSS/02_Helpers.html",
      "url": "/CSS/02_Helpers",
      "label": "Helpers"
    },
    {
      "name": "Buttons",
      "outputPath": "partials/CSS/03_Buttons.html",
      "url": "/CSS/03_Buttons",
      "label": "Buttons"
    },
    {
      "name": "Collapse",
      "outputPath": "partials/CSS/03_Collapse.html",
      "url": "/CSS/03_Collapse",
      "label": "Collapse"
    },
    {
      "name": "Content",
      "outputPath": "partials/CSS/03_Content.html",
      "url": "/CSS/03_Content",
      "label": "Content"
    },
    {
      "name": "Control",
      "outputPath": "partials/CSS/03_Control.html",
      "url": "/CSS/03_Control",
      "label": "Control"
    },
    {
      "name": "Labels",
      "outputPath": "partials/CSS/03_Labels.html",
      "url": "/CSS/03_Labels",
      "label": "Labels"
    },
    {
      "name": "Panels",
      "outputPath": "partials/CSS/03_Panels.html",
      "url": "/CSS/03_Panels",
      "label": "Panels"
    }
  ],
  "Forms": [
    {
      "name": "Form Components",
      "outputPath": "partials/Forms/01_Form_Components.html",
      "url": "/Forms/01_Form_Components",
      "label": "Form Components"
    },
    {
      "name": "Adding Controls",
      "outputPath": "partials/Forms/02_Adding_Form_Controls.html",
      "url": "/Forms/02_Adding_Form_Controls",
      "label": "Adding Controls"
    }
  ]
});

angular.module('docsApp').constant('DEMOS', [
  {
    "name": "enspire.ui.components.action",
    "label": "Action",
    "demos": [
      {
        "id": "action_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/action/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/action/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.action",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/action/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "actionsDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.action"
  },
  {
    "name": "enspire.ui.components.adapter",
    "label": "Adapter",
    "demos": [
      {
        "id": "adapter_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/adapter/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/adapter/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.adapter",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/adapter/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "adapterDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.adapter"
  },
  {
    "name": "enspire.ui.components.alert",
    "label": "Alert",
    "demos": [
      {
        "id": "alert_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/alert/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/alert/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.alert",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/alert/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "alertDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.alert"
  },
  {
    "name": "enspire.ui.components.api",
    "label": "Api",
    "demos": [
      {
        "id": "api_demoGetUsage",
        "css": [],
        "html": [],
        "js": [],
        "moduleName": "enspire.ui.components.api",
        "name": "_demoGetUsage",
        "label": "Get Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/api/_demoGetUsage/index.html"
        }
      },
      {
        "id": "api_demoListUsage",
        "css": [],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/api/_demoListUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.api",
        "name": "_demoListUsage",
        "label": "List Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/api/_demoListUsage/index.html"
        },
        "ngModule": {
          "module": "apiListDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      },
      {
        "id": "api_demoPostUsage",
        "css": [],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/api/_demoPostUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.api",
        "name": "_demoPostUsage",
        "label": "Post Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/api/_demoPostUsage/index.html"
        },
        "ngModule": {
          "module": "apiPostDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      },
      {
        "id": "api_demoSearchUsage",
        "css": [],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/api/_demoSearchUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.api",
        "name": "_demoSearchUsage",
        "label": "Search Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/api/_demoSearchUsage/index.html"
        },
        "ngModule": {
          "module": "apiSearchDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.api"
  },
  {
    "name": "enspire.ui.components.autocomplete",
    "label": "Autocomplete",
    "demos": [
      {
        "id": "autocomplete_demoBasicUsage",
        "css": [],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/autocomplete/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.autocomplete",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/autocomplete/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "autocompleteDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.autocomplete"
  },
  {
    "name": "enspire.ui.components.autofocus",
    "label": "Autofocus",
    "demos": [
      {
        "id": "autofocus_demoBasicUsage",
        "css": [],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/autofocus/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.autofocus",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/autofocus/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "autofocusDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.autofocus"
  },
  {
    "name": "enspire.ui.components.button",
    "label": "Button",
    "demos": [
      {
        "id": "button_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/button/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/button/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.button",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/button/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "buttonDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.button"
  },
  {
    "name": "enspire.ui.components.buttonGroup",
    "label": "Button Group",
    "demos": [
      {
        "id": "buttonGroup_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/buttonGroup/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/buttonGroup/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.buttonGroup",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/buttonGroup/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "buttonGroupDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.buttonGroup"
  },
  {
    "name": "enspire.ui.components.collapse",
    "label": "Collapse",
    "demos": [
      {
        "id": "collapse_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/collapse/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/collapse/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.collapse",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/collapse/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "panelDemo2",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.collapse"
  },
  {
    "name": "enspire.ui.components.collection",
    "label": "Collection",
    "demos": [
      {
        "id": "collection_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/collection/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/collection/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.collection",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/collection/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "collectionDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.collection"
  },
  {
    "name": "enspire.ui.components.collectionRepeat",
    "label": "Collection Repeat",
    "demos": [
      {
        "id": "collectionRepeat_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/collectionRepeat/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/collectionRepeat/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.collectionRepeat",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/collectionRepeat/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "demoCollectionRepeat",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.collectionRepeat"
  },
  {
    "name": "enspire.ui.components.colorwheel",
    "label": "Colorwheel",
    "demos": [
      {
        "id": "colorwheel_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/colorwheel/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/colorwheel/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.colorwheel",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/colorwheel/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "buttonDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.colorwheel"
  },
  {
    "name": "enspire.ui.components.control",
    "label": "Control",
    "demos": [
      {
        "id": "control_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/control/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/control/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.control",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/control/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "controlDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.control"
  },
  {
    "name": "enspire.ui.components.correlation",
    "label": "Correlation",
    "demos": [
      {
        "id": "correlation_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/correlation/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/correlation/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.correlation",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/correlation/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "demoCorrelationDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.correlation"
  },
  {
    "name": "enspire.ui.components.datepicker",
    "label": "Datepicker",
    "demos": [
      {
        "id": "datepicker_demoBasicUsage",
        "css": [],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/datepicker/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.datepicker",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/datepicker/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "datepickerDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.datepicker"
  },
  {
    "name": "enspire.ui.components.dnd",
    "label": "Dnd",
    "demos": [
      {
        "id": "dnd_demoAdvanced",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/dnd/_demoAdvanced/style.css"
          }
        ],
        "html": [
          {
            "name": "advanced.tmpl.html",
            "label": "advanced.tmpl.html",
            "fileType": "html",
            "outputPath": "demo-partials/dnd/_demoAdvanced/advanced.tmpl.html"
          }
        ],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/dnd/_demoAdvanced/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.dnd",
        "name": "_demoAdvanced",
        "label": "Advanced",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/dnd/_demoAdvanced/index.html"
        },
        "ngModule": {
          "module": "dndAdvancedDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      },
      {
        "id": "dnd_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/dnd/_demoBasicUsage/style.css"
          }
        ],
        "html": [
          {
            "name": "basic.tmpl.html",
            "label": "basic.tmpl.html",
            "fileType": "html",
            "outputPath": "demo-partials/dnd/_demoBasicUsage/basic.tmpl.html"
          }
        ],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/dnd/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.dnd",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/dnd/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "dndBasicDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.dnd"
  },
  {
    "name": "enspire.ui.components.draggable",
    "label": "Draggable",
    "demos": [
      {
        "id": "draggable_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/draggable/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/draggable/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.draggable",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/draggable/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "draggableDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.draggable"
  },
  {
    "name": "enspire.ui.components.error",
    "label": "Error",
    "demos": [
      {
        "id": "error_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/error/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/error/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.error",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/error/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "demoMultiErrorDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.error"
  },
  {
    "name": "enspire.ui.components.fileUpload",
    "label": "File Upload",
    "demos": [
      {
        "id": "fileUpload_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/fileUpload/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/fileUpload/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.fileUpload",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/fileUpload/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "demoFileUpload",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.fileUpload"
  },
  {
    "name": "enspire.ui.components.growl",
    "label": "Growl",
    "demos": [
      {
        "id": "growl_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/growl/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/growl/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.growl",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/growl/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "demoGrowl",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.growl"
  },
  {
    "name": "enspire.ui.components.icon",
    "label": "Icon",
    "demos": [
      {
        "id": "icon_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/icon/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/icon/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.icon",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/icon/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "iconDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.icon"
  },
  {
    "name": "enspire.ui.components.input",
    "label": "Input",
    "demos": [
      {
        "id": "input_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/input/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/input/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.input",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/input/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "inputDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.input"
  },
  {
    "name": "enspire.ui.components.inputTags",
    "label": "Input Tags",
    "demos": [
      {
        "id": "inputTags_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/inputTags/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/inputTags/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.inputTags",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/inputTags/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "inputTagsDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.inputTags"
  },
  {
    "name": "enspire.ui.components.label",
    "label": "Label",
    "demos": [
      {
        "id": "label_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/label/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/label/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.label",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/label/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "",
          "dependencies": []
        }
      }
    ],
    "url": "/demo/enspire.ui.components.label"
  },
  {
    "name": "enspire.ui.components.listObject",
    "label": "List Object",
    "demos": [
      {
        "id": "listObject_demoListObjectUsage",
        "css": [],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/listObject/_demoListObjectUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.listObject",
        "name": "_demoListObjectUsage",
        "label": "List Object Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/listObject/_demoListObjectUsage/index.html"
        },
        "ngModule": {
          "module": "listObjectDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.listObject"
  },
  {
    "name": "enspire.ui.components.loader",
    "label": "Loader",
    "demos": [
      {
        "id": "loader_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/loader/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/loader/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.loader",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/loader/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "loaderDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.loader"
  },
  {
    "name": "enspire.ui.components.menu",
    "label": "Menu",
    "demos": [
      {
        "id": "menu_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/menu/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/menu/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.menu",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/menu/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "menuDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.menu"
  },
  {
    "name": "enspire.ui.components.modal",
    "label": "Modal",
    "demos": [
      {
        "id": "modal_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/modal/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/modal/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.modal",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/modal/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "modalDemo1",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.modal"
  },
  {
    "name": "enspire.ui.components.msg",
    "label": "Msg",
    "demos": [
      {
        "id": "msg_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/msg/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/msg/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.msg",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/msg/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "msgDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.msg"
  },
  {
    "name": "enspire.ui.components.multiSelect",
    "label": "Multi Select",
    "demos": [
      {
        "id": "multiSelect_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/multiSelect/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/multiSelect/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.multiSelect",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/multiSelect/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "multiSelectDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.multiSelect"
  },
  {
    "name": "enspire.ui.components.nav",
    "label": "Nav",
    "demos": [
      {
        "id": "nav_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/nav/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/nav/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.nav",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/nav/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "navDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.nav"
  },
  {
    "name": "enspire.ui.components.objTree",
    "label": "Obj Tree",
    "demos": [
      {
        "id": "objTree_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/objTree/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/objTree/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.objTree",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/objTree/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "enObjTreeDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.objTree"
  },
  {
    "name": "enspire.ui.components.objectDiff",
    "label": "Object Diff",
    "demos": [
      {
        "id": "objectDiff_demoBasicUsage",
        "css": [],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/objectDiff/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.objectDiff",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/objectDiff/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "objectDiffDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.objectDiff"
  },
  {
    "name": "enspire.ui.components.panel",
    "label": "Panel",
    "demos": [
      {
        "id": "panel_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/panel/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/panel/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.panel",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/panel/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "panelDemo1",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.panel"
  },
  {
    "name": "enspire.ui.components.passwordCheck",
    "label": "Password Check",
    "demos": [
      {
        "id": "passwordCheck_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/passwordCheck/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/passwordCheck/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.passwordCheck",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/passwordCheck/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "passwordCheckDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.passwordCheck"
  },
  {
    "name": "enspire.ui.components.popover",
    "label": "Popover",
    "demos": [
      {
        "id": "popover_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/popover/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/popover/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.popover",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/popover/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "popoverDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.popover"
  },
  {
    "name": "enspire.ui.components.progress",
    "label": "Progress",
    "demos": [
      {
        "id": "progress_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/progress/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/progress/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.progress",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/progress/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "progressDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.progress"
  },
  {
    "name": "enspire.ui.components.quote",
    "label": "Quote",
    "demos": [
      {
        "id": "quote_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/quote/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/quote/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.quote",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/quote/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "quoteDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.quote"
  },
  {
    "name": "enspire.ui.components.scrollbar",
    "label": "Scrollbar",
    "demos": [
      {
        "id": "scrollbar_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/scrollbar/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/scrollbar/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.scrollbar",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/scrollbar/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "controlDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.scrollbar"
  },
  {
    "name": "enspire.ui.components.section",
    "label": "Section",
    "demos": [
      {
        "id": "section_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/section/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/section/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.section",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/section/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "panelDemo2",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.section"
  },
  {
    "name": "enspire.ui.components.sortable",
    "label": "Sortable",
    "demos": [
      {
        "id": "sortable_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/sortable/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/sortable/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.sortable",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/sortable/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "sortableDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.sortable"
  },
  {
    "name": "enspire.ui.components.tabs",
    "label": "Tabs",
    "demos": [
      {
        "id": "tabs_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/tabs/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/tabs/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.tabs",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/tabs/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "tabDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.tabs"
  },
  {
    "name": "enspire.ui.components.time",
    "label": "Time",
    "demos": [
      {
        "id": "time_demoBasicUsage",
        "css": [],
        "html": [],
        "js": [],
        "moduleName": "enspire.ui.components.time",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/time/_demoBasicUsage/index.html"
        }
      }
    ],
    "url": "/demo/enspire.ui.components.time"
  },
  {
    "name": "enspire.ui.components.timeDuration",
    "label": "Time Duration",
    "demos": [
      {
        "id": "timeDuration_demoBasicUsage",
        "css": [],
        "html": [],
        "js": [],
        "moduleName": "enspire.ui.components.timeDuration",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/timeDuration/_demoBasicUsage/index.html"
        }
      }
    ],
    "url": "/demo/enspire.ui.components.timeDuration"
  },
  {
    "name": "enspire.ui.components.title",
    "label": "Title",
    "demos": [
      {
        "id": "title_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/title/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/title/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.title",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/title/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "titleDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.title"
  },
  {
    "name": "enspire.ui.components.tooltip",
    "label": "Tooltip",
    "demos": [
      {
        "id": "tooltip_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/tooltip/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/tooltip/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.tooltip",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/tooltip/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "tooltipDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.tooltip"
  },
  {
    "name": "enspire.ui.components.tree",
    "label": "Tree",
    "demos": [
      {
        "id": "tree_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/tree/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/tree/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.tree",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/tree/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "treeDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.tree"
  },
  {
    "name": "enspire.ui.components.win",
    "label": "Win",
    "demos": [
      {
        "id": "win_demoBasicUsage",
        "css": [
          {
            "name": "style.css",
            "label": "style.css",
            "fileType": "css",
            "outputPath": "demo-partials/win/_demoBasicUsage/style.css"
          }
        ],
        "html": [],
        "js": [
          {
            "name": "script.js",
            "label": "script.js",
            "fileType": "js",
            "outputPath": "demo-partials/win/_demoBasicUsage/script.js"
          }
        ],
        "moduleName": "enspire.ui.components.win",
        "name": "_demoBasicUsage",
        "label": "Basic Usage",
        "index": {
          "name": "index.html",
          "label": "index.html",
          "fileType": "html",
          "outputPath": "demo-partials/win/_demoBasicUsage/index.html"
        },
        "ngModule": {
          "module": "winDemo",
          "dependencies": [
            "enspire.ui"
          ]
        }
      }
    ],
    "url": "/demo/enspire.ui.components.win"
  }
]);
DocsApp
.directive('docsDemo', [function() {
  return {
    restrict: 'E',
    scope: true,
    templateUrl: 'partials/docs-demo.tmpl.html',
    transclude: true,
    controller: ['$scope', '$element', '$attrs', '$interpolate', DocsDemoCtrl],
    controllerAs: 'demoCtrl',
    bindToController: true
  };

  function DocsDemoCtrl($scope, $element, $attrs, $interpolate) {
    var self = this;

    self.interpolateCode = angular.isDefined($attrs.interpolateCode);
    self.demoId = $interpolate($attrs.demoId || '')($scope.$parent);
    self.demoTitle = $interpolate($attrs.demoTitle || '')($scope.$parent);
    self.demoModule = $interpolate($attrs.demoModule || '')($scope.$parent);
    self.files = {
      css: [], js: [], html: []
    };

    self.addFile = function(name, contentsPromise) {
      var file = {
        name: convertName(name),
        contentsPromise: contentsPromise,
        fileType: name.split('.').pop()
      };
      contentsPromise.then(function(contents) {
        file.contents = contents;
      });

      if (name === 'index.html') {
        self.files.index = file;
      } else {
        self.files[file.fileType] = self.files[file.fileType] || [];
        self.files[file.fileType].push(file);
      }

      self.orderedFiles = []
        .concat(self.files.index || [])
        .concat(self.files.js || [])
        .concat(self.files.css || [])
        .concat(self.files.html || []);
    };

    function convertName(name) {
      switch(name) {
        case "index.html" : return "HTML";
        case "script.js" : return "JS";
        case "style.css" : return "CSS";
        default : return name;
      }
    }

  }
}])
    
.directive('demoFile', ['$q', '$interpolate', function($q, $interpolate) {
  return {
    restrict: 'E',
    require: '^docsDemo',
    compile: compile
  };

  function compile(element, attr) {
    var contentsAttr = attr.contents;
    var html = element.html();
    var name = attr.name;
    element.contents().remove();

    return function postLink(scope, element, attr, docsDemoCtrl) {
      docsDemoCtrl.addFile(
        $interpolate(name)(scope), 
        $q.when(scope.$eval(contentsAttr) || html)
      );
      element.remove();
    };
  }
}]);

DocsApp.directive('demoInclude', [
  '$q', 
  '$http', 
  '$compile', 
  '$templateCache',
  '$timeout',
function($q, $http, $compile, $templateCache, $timeout) {
  return {
    restrict: 'E',
    link: postLink
  };
  
  function postLink(scope, element, attr) {
    var demoContainer;

    // Interpret the expression given as `demo-include files="something"`
    var files = scope.$eval(attr.files) || {};
    var ngModule = scope.$eval(attr.module) || '';

    $timeout(handleDemoIndexFile);

    /**
     * Fetch the index file, and if it contains its own ngModule
     * then bootstrap a new angular app with that ngModule. Otherwise, compile
     * the demo into the current ng-app.
     */
    function handleDemoIndexFile() {
      files.index.contentsPromise.then(function(contents) {
        demoContainer = angular.element(
          '<div class="demo-content ' + ngModule + '">'
        );

        var isStandalone = !!ngModule;
        var demoScope;
        var demoCompileService;
        if (isStandalone) {
          angular.bootstrap(demoContainer[0], [ngModule]);
          demoScope = demoContainer.scope();
          demoCompileService = demoContainer.injector().get('$compile');
          scope.$on('$destroy', function() {
            demoScope.$destroy();
          });

        } else {
          demoScope = scope.$new();
          demoCompileService = $compile;
        }

        // Once everything is loaded, put the demo into the DOM
        $q.all([
          handleDemoStyles(),
          handleDemoTemplates()
        ]).finally(function() {
          demoScope.$evalAsync(function() {
            element.append(demoContainer);
            demoContainer.html(contents);
            demoCompileService(demoContainer.contents())(demoScope);
          });
        });
      });

    }


    /**
     * Fetch the demo styles, and append them to the DOM.
     */
    function handleDemoStyles() {
      return $q.all(files.css.map(function(file) {
        return file.contentsPromise;
      }))
      .then(function(styles) {
        styles = styles.join('\n'); //join styles as one string

        var styleElement = angular.element('<style>' + styles + '</style>');
        document.body.appendChild(styleElement[0]);

        scope.$on('$destroy', function() {
          styleElement.remove();
        });
      });

    }

    /**
     * Fetch the templates for this demo, and put the templates into
     * the demo app's templateCache, with a url that allows the demo apps
     * to reference their templates local to the demo index file.
     *
     * For example, make it so the dialog demo can reference templateUrl
     * 'my-dialog.tmpl.html' instead of having to reference the url
     * 'generated/enspire.ui.components.dialog/demo/demo1/my-dialog.tmpl.html'.
     */
    function handleDemoTemplates() {
      return $q.all(files.html.map(function(file) {

        return file.contentsPromise.then(function(contents) {
          // Get the $templateCache instance that goes with the demo's specific ng-app.
          var demoTemplateCache = demoContainer.injector().get('$templateCache');
          demoTemplateCache.put(file.name, contents);

          scope.$on('$destroy', function() {
            demoTemplateCache.remove(file.name);
          });

        });

      }));

    }

  }

}]);

angular.module('docsApp').run(['$templateCache', function($templateCache) {
  $templateCache.put('partials/demo.tmpl.html',
    '\n' +
    '\n' +
    '\n' +
    '<en-tabs panes="demoGroup" ng-show="demos.length > 1 " style="background: #fff;border-bottom: 1px solid #ddd;">\n' +
    '    <en-tab pane="{{demo.id}}" active="{{($index === 0)}}" ng-repeat="demo in demos">{{demo.label}}</en-tab>\n' +
    '</en-tabs>\n' +
    '\n' +
    '\n' +
    '<en-tab-panes name="demoGroup">\n' +
    '    <en-tab-pane name="{{demo.id}}" ng-repeat="demo in demos">\n' +
    '            <docs-demo demo-id="{{demo.id}}"\n' +
    '                       demo-title="{{demo.label}}"\n' +
    '                       demo-module="{{demo.ngModule.module}}">\n' +
    '              <demo-file ng-repeat="file in demo.$files"\n' +
    '                         name="{{file.name}}"\n' +
    '                         contents="file.httpPromise">\n' +
    '              </demo-file>\n' +
    '            </docs-demo>\n' +
    '    </en-tab-pane>\n' +
    '</en-tab-panes>\n' +
    '\n' +
    '\n' +
    '<script type="text/ng-template" id="source-code.html">\n' +
    '\n' +
    '<en-modal\n' +
    '    overlay="true"\n' +
    '    en-draggable\n' +
    '    drag-handle=".drag-handle"\n' +
    '    drag-containment="body"\n' +
    '    width="940"\n' +
    '    height="600"\n' +
    '    class="application"\n' +
    '    ng-init="demoCtrl = data;">\n' +
    '\n' +
    '    <en-modal-header class="drag-handle" style="padding:0 8px; height: auto;line-height: normal; border-bottom: none; text-indent:0;">\n' +
    '        <div layout="row" layout-align="start center">\n' +
    '            <en-icon icon="code" style="margin-right: 8px;"></en-icon>\n' +
    '            <en-title class="title-md">{{demoCtrl.demoTitle}}</en-title>\n' +
    '            <en-flex></en-flex>\n' +
    '\n' +
    '            <en-tabs panes="srcTabPanes" layout-align="end end">\n' +
    '                <en-tab ng-repeat="file in demoCtrl.orderedFiles" pane="srcTabPane{{$index}}" active="{{($index===0)}}">{{file.name}}</en-tab>\n' +
    '            </en-tabs>\n' +
    '\n' +
    '            <en-vr layout-align-self="stretch" style="opacity: 0.15;"></en-vr>\n' +
    '\n' +
    '            <en-icon icon="x" en-tap="closeModal();" class="close-modal" style="cursor:pointer;"></en-icon>\n' +
    '\n' +
    '        </div>\n' +
    '    </en-modal-header>\n' +
    '\n' +
    '\n' +
    '\n' +
    '        <en-modal-body style="overflow:hidden;" layout="column" layout-align="start stretch">\n' +
    '\n' +
    '            <en-tab-panes flex layout="row" layout-align="start stretch" name="srcTabPanes" class="demo-tab-panes">\n' +
    '              <en-tab-pane flex layout="column" layout-align="start stretch" ng-repeat="file in demoCtrl.orderedFiles" name="srcTabPane{{$index}}">\n' +
    '                  <hljs flex code="file.contentsPromise" lang="{{file.fileType}}"\n' +
    '                        should-interpolate="demoCtrl.interpolateCode">\n' +
    '                  </hljs>\n' +
    '              </en-tab-pane>\n' +
    '          </en-tab-panes>\n' +
    '\n' +
    '        </en-modal-body>\n' +
    '\n' +
    '</en-modal>\n' +
    '\n' +
    '</script>\n' +
    '');
}]);

angular.module('docsApp').run(['$templateCache', function($templateCache) {
  $templateCache.put('partials/docs-demo.tmpl.html',
    '<en-content>\n' +
    '    <div ng-transclude></div>\n' +
    '      <en-panel class="demo-panel">\n' +
    '          <en-header>\n' +
    '              <en-title class="title-md">{{demoCtrl.demoTitle}}</en-title>\n' +
    '              <en-flex></en-flex>\n' +
    '              <!--<en-button class="primary" ng-click="demoCtrl.$showSource = !demoCtrl.$showSource">Source</en-button>-->\n' +
    '              <en-button class="button-text" ng-click="showModal(\'source-code.html\', demoCtrl);">\n' +
    '                  <en-icon icon="code" style="color:#fff; font-size:20px;"></en-icon>\n' +
    '              </en-button>\n' +
    '          </en-header>\n' +
    '\n' +
    '          <!--<en-subheader ng-show="demoCtrl.$showSource">-->\n' +
    '              <!--<en-tabs panes="srcTabPanes">-->\n' +
    '                  <!--<en-tab ng-repeat="file in demoCtrl.orderedFiles" pane="srcTabPane{{$index}}" active="{{($index===0)}}">{{file.name}}</en-tab>-->\n' +
    '              <!--</en-tabs>-->\n' +
    '          <!--</en-subheader>-->\n' +
    '          <!--<en-tab-panes ng-show="demoCtrl.$showSource" name="srcTabPanes" class="demo-tab-panes">-->\n' +
    '              <!--<en-tab-pane ng-repeat="file in demoCtrl.orderedFiles" name="srcTabPane{{$index}}">-->\n' +
    '                  <!--<hljs code="file.contentsPromise" lang="{{file.fileType}}"-->\n' +
    '                        <!--should-interpolate="demoCtrl.interpolateCode">-->\n' +
    '                  <!--</hljs>-->\n' +
    '              <!--</en-tab-pane>-->\n' +
    '          <!--</en-tab-panes>-->\n' +
    '          <en-body>\n' +
    '              <demo-include files="demoCtrl.files" module="demoCtrl.demoModule" class="{{demoCtrl.demoId}}"></demo-include>\n' +
    '          </en-body>\n' +
    '\n' +
    '      </en-panel>\n' +
    '</en-content>\n' +
    '');
}]);

angular.module('docsApp').run(['$templateCache', function($templateCache) {
  $templateCache.put('partials/home.tmpl.html',
    '<div ng-controller="HomeCtrl" layout="column" class="doc-content">\n' +
    '    <md-content class="extraPad" >\n' +
    '        <h3>{{BUILDCONFIG.name}} v{{BUILDCONFIG.version}}</h3>\n' +
    '        \n' +
    '        <p>\n' +
    '            {{BUILDCONFIG.name}} start page template located at "/docs/app/partials/home.tmpl.html".\n' +
    '        </p>\n' +
    '\n' +
    '        <h3>Useful Links:</h3>\n' +
    '\n' +
    '        <ul>\n' +
    '            <li>These docs were generated from source in the `develop` branch:\n' +
    '                <ul style="padding-top:5px;">\n' +
    '                    <li>Git Repo: <a ng-href="{{BUILDCONFIG.repository}}/tree/develop" target="_blank">{{BUILDCONFIG.repository}}/tree/develop</a>\n' +
    '                    </li>\n' +
    '                    <li>\n' +
    '                        Latest commit: <a ng-href="{{BUILDCONFIG.repository}}/commit/{{BUILDCONFIG.commit}}" target="_blank">\n' +
    '                        v{{BUILDCONFIG.version}}  -  SHA {{BUILDCONFIG.commit.substring(0,7)}}\n' +
    '                    </a> on {{BUILDCONFIG.date}} ET.\n' +
    '                    </li>\n' +
    '                </ul>\n' +
    '            </li>\n' +
    '            <li>\n' +
    '                {{BUILDCONFIG.name}} uses AngularJS <a ng-href="https://code.angularjs.org/{{BUILDCONFIG.ngVersion}}/docs/api" target="_blank">v{{BUILDCONFIG.ngVersion}}</a>\n' +
    '            </li>\n' +
    '            \n' +
    '        </ul>\n' +
    '        <br/>\n' +
    '        <br/>\n' +
    '    </md-content>\n' +
    '</div>\n' +
    '\n' +
    '');
}]);

angular.module('docsApp').run(['$templateCache', function($templateCache) {
  $templateCache.put('partials/layout-alignment.tmpl.html',
    '<div>\n' +
    '\n' +
    '  <p>\n' +
    '    The <code>layout-align</code> attribute takes two words.\n' +
    '    The first word says how the children will be aligned in the layout\'s direction, and the second word says how the children will be aligned perpindicular to the layout\'s direction.\n' +
    '    <br/>\n' +
    '    Only one word is required for the attribute. For example, <code>layout="row" layout-align="center"</code> would make the elements center horizontally and use the default behavior vertically.\n' +
    '    <br/>\n' +
    '    <code>layout="column" layout-align="center end"</code> would make\n' +
    '    children align along the center vertically and along the end (right) horizontally.\n' +
    '  </p>\n' +
    '\n' +
    '</div>\n' +
    '');
}]);

angular.module('docsApp').run(['$templateCache', function($templateCache) {
  $templateCache.put('partials/layout-container.tmpl.html',
    '<div>\n' +
    '\n' +
    '  <h3 class="layout-title">Overview</h3>\n' +
    '  <p>\n' +
    '    Responsive CSS layout is built on\n' +
    '    <a href="http://www.w3.org/TR/css3-flexbox/">flexbox</a>.\n' +
    '  </p>\n' +
    '\n' +
    '  <p>\n' +
    '    The layout system is based upon element attributes rather than CSS classes.\n' +
    '    Attributes provide an easy way to set a value (eg `layout="row"`), and additionally\n' +
    '    helps us separate concerns: attributes define layout, and classes define styling.\n' +
    '  </p>\n' +
    '\n' +
    '  <h3 class="layout-title">Layout Attribute</h3>\n' +
    '  <p>\n' +
    '    Use the <code>layout</code> attribute on an element to arrange its children\n' +
    '    horizontally in a row (<code>layout="row"</code>), or vertically in\n' +
    '    a column (<code>layout="column"</code>). \n' +
    '  </p>\n' +
    '\n' +
    '  <hljs lang="html">\n' +
    '    <div layout="row">\n' +
    '      <div>I\'m left.</div>\n' +
    '      <div>I\'m right.</div>\n' +
    '    </div>\n' +
    '    <div layout="column">\n' +
    '      <div>I\'m above.</div>\n' +
    '      <div>I\'m below.</div>\n' +
    '    </div>\n' +
    '  </hljs>\n' +
    '\n' +
    '  <p>\n' +
    '    See <a href="#/layout/options">Layout Options</a> for information on responsive layouts and other options.\n' +
    '  </p>\n' +
    '\n' +
    '</div>\n' +
    '\n' +
    '</div>\n' +
    '');
}]);

angular.module('docsApp').run(['$templateCache', function($templateCache) {
  $templateCache.put('partials/layout-grid.tmpl.html',
    '<div ng-controller="LayoutCtrl" layout="column" layout-fill class="layout-content">\n' +
    '\n' +
    '  <p>\n' +
    '    To customize the size and position of elements in a layout, use the\n' +
    '    <code>flex</code>, <code>offset</code>, and <code>flex-order</code> attributes.\n' +
    '  </p>\n' +
    '\n' +
    '  <md-divider></md-divider>\n' +
    '\n' +
    '  <docs-demo demo-title="Flex Attribute" class="small-demo">\n' +
    '    <demo-file name="index.html">\n' +
    '      <div layout="row">\n' +
    '        <div flex>\n' +
    '          [flex]\n' +
    '        </div>\n' +
    '        <div flex>\n' +
    '          [flex]\n' +
    '        </div>\n' +
    '        <div flex hide-sm>\n' +
    '          [flex]\n' +
    '        </div>\n' +
    '      </div>\n' +
    '    </demo-file>\n' +
    '  </docs-demo>\n' +
    '  <p>\n' +
    '    Add the <code>flex</code> attribute to a layout\'s child element, and it\n' +
    '    will flex (stretch) to fill the available area.\n' +
    '  </p>\n' +
    '\n' +
    '\n' +
    '  <md-divider></md-divider>\n' +
    '\n' +
    '  <docs-demo demo-title="Flex Percent Values" class="small-demo">\n' +
    '    <demo-file name="index.html">\n' +
    '      <div layout="row" layout-wrap>\n' +
    '        <div flex="33">\n' +
    '          [flex="33"]\n' +
    '        </div>\n' +
    '        <div flex="55">\n' +
    '          [flex="55"]\n' +
    '        </div>\n' +
    '        <div flex>\n' +
    '          [flex]\n' +
    '        </div>\n' +
    '        <div flex="66">\n' +
    '          [flex]\n' +
    '        </div>\n' +
    '        <div flex="33">\n' +
    '          [flex]\n' +
    '        </div>\n' +
    '      </div>\n' +
    '    </demo-file>\n' +
    '  </docs-demo>\n' +
    '  <p>\n' +
    '    A layout child\'s <code>flex</code> attribute can be given an integer value from 0-100.\n' +
    '    The element will stretch to the percentage of available space matching the value.\n' +
    '    <br/><br/>\n' +
    '    The <code>flex</code> attribute value is restricted to 33, 66, and multiples\n' +
    '    of five.\n' +
    '    <br/>\n' +
    '    For example: <code>flex="5", flex="20", "flex="33", flex="50", flex="66", flex="75", ...</code>.\n' +
    '  </p>\n' +
    '  <p>\n' +
    '  See the <a href="#/layout/options">layout options page</a> for more information on responsive flex attributes.\n' +
    '  </p>\n' +
    '\n' +
    '  <md-divider></md-divider>\n' +
    '  <docs-demo demo-title="Flex Order Attribute" class="small-demo">\n' +
    '    <demo-file name="index.html">\n' +
    '      <div layout="row" layout-margin>\n' +
    '        <div flex flex-order="3">\n' +
    '          [flex-order="3"]\n' +
    '        </div>\n' +
    '        <div flex flex-order="2">\n' +
    '          [flex-order="2"]\n' +
    '        </div>\n' +
    '        <div flex flex-order="1">\n' +
    '          [flex-order="1"]\n' +
    '        </div>\n' +
    '      </div>\n' +
    '    </demo-file>\n' +
    '  </docs-demo>\n' +
    '  <p>\n' +
    '    Add the <code>flex-order</code> attribute to a layout child to set its\n' +
    '    position within the layout.\n' +
    '  </p>\n' +
    '</div>\n' +
    '\n' +
    '');
}]);

angular.module('docsApp').run(['$templateCache', function($templateCache) {
  $templateCache.put('partials/layout-options.tmpl.html',
    '<div layout="column" layout-fill class="layout-content">\n' +
    '\n' +
    '  <docs-demo demo-title="Responsive Layout" class="small-demo">\n' +
    '    <demo-file name="index.html">\n' +
    '      <div layout="row" layout-sm="column">\n' +
    '        <div flex>\n' +
    '          I\'m above on mobile, and to the left on larger devices.\n' +
    '        </div>\n' +
    '        <div flex>\n' +
    '          I\'m below on mobile, and to the right on larger devices.\n' +
    '        </div>\n' +
    '      </div>\n' +
    '    </demo-file>\n' +
    '  </docs-demo>\n' +
    '\n' +
    '  <p>\n' +
    '    See the <a href="#/layout/container">Layout Container</a> page for a basic explanation\n' +
    '    of layout attributes.\n' +
    '    <br/>\n' +
    '    To make your layout change depending upon the device size, there are\n' +
    '    other <code>layout</code> attributes available:\n' +
    '  </p>\n' +
    '\n' +
    '    \n' +
    '\n' +
    '  <docs-demo demo-title="Layout Margin, Padding and Fill" class="small-demo">\n' +
    '    <demo-file name="index.html">\n' +
    '      <div layout="row" layout-margin layout-fill layout-padding>\n' +
    '        <div flex>I\'m on the left, and there\'s an empty area around me.</div>\n' +
    '        <div flex>I\'m on the right, and there\'s an empty area around me.</div>\n' +
    '      </div>\n' +
    '    </demo-file>\n' +
    '  </docs-demo>\n' +
    '\n' +
    '  <p>\n' +
    '    <code>layout-margin</code> adds margin around each <code>flex</code> child. It also adds a margin to the layout container itself.\n' +
    '    <br/>\n' +
    '    <code>layout-padding</code> adds padding inside each <code>flex</code> child. It also adds padding to the layout container itself.\n' +
    '    <br/>\n' +
    '    <code>layout-fill</code> forces the layout element to fill its parent container.\n' +
    '  </p>\n' +
    '\n' +
    '  <br/>\n' +
    '\n' +
    '\n' +
    '</div>\n' +
    '');
}]);

angular.module('docsApp').run(['$templateCache', function($templateCache) {
  $templateCache.put('partials/view-source.tmpl.html',
    '<md-dialog class="view-source-dialog">\n' +
    '\n' +
    '  <md-tabs>\n' +
    '    <md-tab ng-repeat="file in files"\n' +
    '                  active="file === data.selectedFile"\n' +
    '                  ng-click="data.selectedFile = file" >\n' +
    '        <span class="window_label">{{file.viewType}}</span>\n' +
    '    </md-tab>\n' +
    '  </md-tabs>\n' +
    '\n' +
    '  <div class="md-content" md-scroll-y flex>\n' +
    '    <div ng-repeat="file in files">\n' +
    '      <hljs code="file.content"\n' +
    '        lang="{{file.fileType}}"\n' +
    '        ng-show="file === data.selectedFile" >\n' +
    '      </hljs>\n' +
    '    </div>\n' +
    '  </div>\n' +
    '\n' +
    '  <div class="md-actions" layout="horizontal">\n' +
    '    <md-button class="md-button-light" ng-click="$hideDialog()">\n' +
    '      Done\n' +
    '    </md-button>\n' +
    '  </div>\n' +
    '</md-dialog>\n' +
    '');
}]);

DocsApp

.directive('hljs', ['$timeout', '$q', '$interpolate', function($timeout, $q, $interpolate) {
  return {
    restrict: 'E',
    compile: function(element, attr) {
      var code;
      //No attribute? code is the content
        if (!attr.code) {
            code = element.find('code')[0];
            if(code){
                code = code.innerText;
            }else{
                code = element.html();
            }
            element.empty();
        }

      return function(scope, element, attr) {

        if (attr.code) {
          // Attribute? code is the evaluation
          code = scope.$eval(attr.code);
        }
        var shouldInterpolate = scope.$eval(attr.shouldInterpolate);

        $q.when(code).then(function(code) {
          if (code) {
            if (shouldInterpolate) {
                code = $interpolate(code)(scope);
            }
            var contentParent = angular.element(
              '<pre><code class="hljs" ng-non-bindable></code></pre>'
            );
            element.append(contentParent);
            // Defer highlighting 1-frame to prevent GA interference...
            $timeout(function() {
              render(code, contentParent);
            }, 34, false);
          }
        });

        function render(contents, parent) {

          var codeElement = parent.find('code');
          var lines = contents.split('\n');

          // Remove empty lines
          lines = lines.filter(function(line) {
            return line.trim().length;
          });

          // Make it so each line starts at 0 whitespace
          var firstLineWhitespace = lines[0].match(/^\s*/)[0];
          var startingWhitespaceRegex = new RegExp('^' + firstLineWhitespace);
          lines = lines.map(function(line) {
            return line
              .replace(startingWhitespaceRegex, '')
              .replace(/\s+$/, '');
          });

          //hljs.configure({useBR: true});

          var highlightedCode = hljs.highlight(attr.language || attr.lang, lines.join('\n'), true);
          highlightedCode.value = highlightedCode.value
            //.replace(/=<span class="hljs-value">""<\/span>/gi, '')
            .replace('<head>', '')
            .replace('<head/>', '');
          codeElement.append(highlightedCode.value).addClass('hljs');
        }
      };
    }
  };
}])
;

!function(e){"undefined"!=typeof exports?e(exports):(window.hljs=e({}),"function"==typeof define&&define.amd&&define("hljs",[],function(){return window.hljs}))}(function(e){function n(e){return e.replace(/&/gm,"&amp;").replace(/</gm,"&lt;").replace(/>/gm,"&gt;")}function t(e){return e.nodeName.toLowerCase()}function r(e,n){var t=e&&e.exec(n);return t&&0==t.index}function a(e){return/^(no-?highlight|plain|text)$/i.test(e)}function i(e){var n,t,r,i=e.className+" ";if(i+=e.parentNode?e.parentNode.className:"",t=/\blang(?:uage)?-([\w-]+)\b/i.exec(i))return w(t[1])?t[1]:"no-highlight";for(i=i.split(/\s+/),n=0,r=i.length;r>n;n++)if(w(i[n])||a(i[n]))return i[n]}function o(e,n){var t,r={};for(t in e)r[t]=e[t];if(n)for(t in n)r[t]=n[t];return r}function u(e){var n=[];return function r(e,a){for(var i=e.firstChild;i;i=i.nextSibling)3==i.nodeType?a+=i.nodeValue.length:1==i.nodeType&&(n.push({event:"start",offset:a,node:i}),a=r(i,a),t(i).match(/br|hr|img|input/)||n.push({event:"stop",offset:a,node:i}));return a}(e,0),n}function c(e,r,a){function i(){return e.length&&r.length?e[0].offset!=r[0].offset?e[0].offset<r[0].offset?e:r:"start"==r[0].event?e:r:e.length?e:r}function o(e){function r(e){return" "+e.nodeName+'="'+n(e.value)+'"'}l+="<"+t(e)+Array.prototype.map.call(e.attributes,r).join("")+">"}function u(e){l+="</"+t(e)+">"}function c(e){("start"==e.event?o:u)(e.node)}for(var s=0,l="",f=[];e.length||r.length;){var g=i();if(l+=n(a.substr(s,g[0].offset-s)),s=g[0].offset,g==e){f.reverse().forEach(u);do c(g.splice(0,1)[0]),g=i();while(g==e&&g.length&&g[0].offset==s);f.reverse().forEach(o)}else"start"==g[0].event?f.push(g[0].node):f.pop(),c(g.splice(0,1)[0])}return l+n(a.substr(s))}function s(e){function n(e){return e&&e.source||e}function t(t,r){return new RegExp(n(t),"m"+(e.cI?"i":"")+(r?"g":""))}function r(a,i){if(!a.compiled){if(a.compiled=!0,a.k=a.k||a.bK,a.k){var u={},c=function(n,t){e.cI&&(t=t.toLowerCase()),t.split(" ").forEach(function(e){var t=e.split("|");u[t[0]]=[n,t[1]?Number(t[1]):1]})};"string"==typeof a.k?c("keyword",a.k):Object.keys(a.k).forEach(function(e){c(e,a.k[e])}),a.k=u}a.lR=t(a.l||/\b\w+\b/,!0),i&&(a.bK&&(a.b="\\b("+a.bK.split(" ").join("|")+")\\b"),a.b||(a.b=/\B|\b/),a.bR=t(a.b),a.e||a.eW||(a.e=/\B|\b/),a.e&&(a.eR=t(a.e)),a.tE=n(a.e)||"",a.eW&&i.tE&&(a.tE+=(a.e?"|":"")+i.tE)),a.i&&(a.iR=t(a.i)),void 0===a.r&&(a.r=1),a.c||(a.c=[]);var s=[];a.c.forEach(function(e){e.v?e.v.forEach(function(n){s.push(o(e,n))}):s.push("self"==e?a:e)}),a.c=s,a.c.forEach(function(e){r(e,a)}),a.starts&&r(a.starts,i);var l=a.c.map(function(e){return e.bK?"\\.?("+e.b+")\\.?":e.b}).concat([a.tE,a.i]).map(n).filter(Boolean);a.t=l.length?t(l.join("|"),!0):{exec:function(){return null}}}}r(e)}function l(e,t,a,i){function o(e,n){for(var t=0;t<n.c.length;t++)if(r(n.c[t].bR,e))return n.c[t]}function u(e,n){if(r(e.eR,n)){for(;e.endsParent&&e.parent;)e=e.parent;return e}return e.eW?u(e.parent,n):void 0}function c(e,n){return!a&&r(n.iR,e)}function g(e,n){var t=N.cI?n[0].toLowerCase():n[0];return e.k.hasOwnProperty(t)&&e.k[t]}function h(e,n,t,r){var a=r?"":E.classPrefix,i='<span class="'+a,o=t?"":"</span>";return i+=e+'">',i+n+o}function p(){if(!L.k)return n(M);var e="",t=0;L.lR.lastIndex=0;for(var r=L.lR.exec(M);r;){e+=n(M.substr(t,r.index-t));var a=g(L,r);a?(B+=a[1],e+=h(a[0],n(r[0]))):e+=n(r[0]),t=L.lR.lastIndex,r=L.lR.exec(M)}return e+n(M.substr(t))}function d(){var e="string"==typeof L.sL;if(e&&!x[L.sL])return n(M);var t=e?l(L.sL,M,!0,y[L.sL]):f(M,L.sL.length?L.sL:void 0);return L.r>0&&(B+=t.r),e&&(y[L.sL]=t.top),h(t.language,t.value,!1,!0)}function b(){return void 0!==L.sL?d():p()}function v(e,t){var r=e.cN?h(e.cN,"",!0):"";e.rB?(k+=r,M=""):e.eB?(k+=n(t)+r,M=""):(k+=r,M=t),L=Object.create(e,{parent:{value:L}})}function m(e,t){if(M+=e,void 0===t)return k+=b(),0;var r=o(t,L);if(r)return k+=b(),v(r,t),r.rB?0:t.length;var a=u(L,t);if(a){var i=L;i.rE||i.eE||(M+=t),k+=b();do L.cN&&(k+="</span>"),B+=L.r,L=L.parent;while(L!=a.parent);return i.eE&&(k+=n(t)),M="",a.starts&&v(a.starts,""),i.rE?0:t.length}if(c(t,L))throw new Error('Illegal lexeme "'+t+'" for mode "'+(L.cN||"<unnamed>")+'"');return M+=t,t.length||1}var N=w(e);if(!N)throw new Error('Unknown language: "'+e+'"');s(N);var R,L=i||N,y={},k="";for(R=L;R!=N;R=R.parent)R.cN&&(k=h(R.cN,"",!0)+k);var M="",B=0;try{for(var C,j,I=0;;){if(L.t.lastIndex=I,C=L.t.exec(t),!C)break;j=m(t.substr(I,C.index-I),C[0]),I=C.index+j}for(m(t.substr(I)),R=L;R.parent;R=R.parent)R.cN&&(k+="</span>");return{r:B,value:k,language:e,top:L}}catch(O){if(-1!=O.message.indexOf("Illegal"))return{r:0,value:n(t)};throw O}}function f(e,t){t=t||E.languages||Object.keys(x);var r={r:0,value:n(e)},a=r;return t.forEach(function(n){if(w(n)){var t=l(n,e,!1);t.language=n,t.r>a.r&&(a=t),t.r>r.r&&(a=r,r=t)}}),a.language&&(r.second_best=a),r}function g(e){return E.tabReplace&&(e=e.replace(/^((<[^>]+>|\t)+)/gm,function(e,n){return n.replace(/\t/g,E.tabReplace)})),E.useBR&&(e=e.replace(/\n/g,"<br>")),e}function h(e,n,t){var r=n?R[n]:t,a=[e.trim()];return e.match(/\bhljs\b/)||a.push("hljs"),-1===e.indexOf(r)&&a.push(r),a.join(" ").trim()}function p(e){var n=i(e);if(!a(n)){var t;E.useBR?(t=document.createElementNS("http://www.w3.org/1999/xhtml","div"),t.innerHTML=e.innerHTML.replace(/\n/g,"").replace(/<br[ \/]*>/g,"\n")):t=e;var r=t.textContent,o=n?l(n,r,!0):f(r),s=u(t);if(s.length){var p=document.createElementNS("http://www.w3.org/1999/xhtml","div");p.innerHTML=o.value,o.value=c(s,u(p),r)}o.value=g(o.value),e.innerHTML=o.value,e.className=h(e.className,n,o.language),e.result={language:o.language,re:o.r},o.second_best&&(e.second_best={language:o.second_best.language,re:o.second_best.r})}}function d(e){E=o(E,e)}function b(){if(!b.called){b.called=!0;var e=document.querySelectorAll("pre code");Array.prototype.forEach.call(e,p)}}function v(){addEventListener("DOMContentLoaded",b,!1),addEventListener("load",b,!1)}function m(n,t){var r=x[n]=t(e);r.aliases&&r.aliases.forEach(function(e){R[e]=n})}function N(){return Object.keys(x)}function w(e){return e=(e||"").toLowerCase(),x[e]||x[R[e]]}var E={classPrefix:"hljs-",tabReplace:null,useBR:!1,languages:void 0},x={},R={};return e.highlight=l,e.highlightAuto=f,e.fixMarkup=g,e.highlightBlock=p,e.configure=d,e.initHighlighting=b,e.initHighlightingOnLoad=v,e.registerLanguage=m,e.listLanguages=N,e.getLanguage=w,e.inherit=o,e.IR="[a-zA-Z]\\w*",e.UIR="[a-zA-Z_]\\w*",e.NR="\\b\\d+(\\.\\d+)?",e.CNR="(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",e.BNR="\\b(0b[01]+)",e.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",e.BE={b:"\\\\[\\s\\S]",r:0},e.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[e.BE]},e.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[e.BE]},e.PWM={b:/\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\b/},e.C=function(n,t,r){var a=e.inherit({cN:"comment",b:n,e:t,c:[]},r||{});return a.c.push(e.PWM),a.c.push({cN:"doctag",b:"(?:TODO|FIXME|NOTE|BUG|XXX):",r:0}),a},e.CLCM=e.C("//","$"),e.CBCM=e.C("/\\*","\\*/"),e.HCM=e.C("#","$"),e.NM={cN:"number",b:e.NR,r:0},e.CNM={cN:"number",b:e.CNR,r:0},e.BNM={cN:"number",b:e.BNR,r:0},e.CSSNM={cN:"number",b:e.NR+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",r:0},e.RM={cN:"regexp",b:/\//,e:/\/[gimuy]*/,i:/\n/,c:[e.BE,{b:/\[/,e:/\]/,r:0,c:[e.BE]}]},e.TM={cN:"title",b:e.IR,r:0},e.UTM={cN:"title",b:e.UIR,r:0},e});hljs.registerLanguage("nginx",function(e){var r={cN:"variable",v:[{b:/\$\d+/},{b:/\$\{/,e:/}/},{b:"[\\$\\@]"+e.UIR}]},b={eW:!0,l:"[a-z/_]+",k:{built_in:"on off yes no true false none blocked debug info notice warn error crit select break last permanent redirect kqueue rtsig epoll poll /dev/poll"},r:0,i:"=>",c:[e.HCM,{cN:"string",c:[e.BE,r],v:[{b:/"/,e:/"/},{b:/'/,e:/'/}]},{cN:"url",b:"([a-z]+):/",e:"\\s",eW:!0,eE:!0,c:[r]},{cN:"regexp",c:[e.BE,r],v:[{b:"\\s\\^",e:"\\s|{|;",rE:!0},{b:"~\\*?\\s+",e:"\\s|{|;",rE:!0},{b:"\\*(\\.[a-z\\-]+)+"},{b:"([a-z\\-]+\\.)+\\*"}]},{cN:"number",b:"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d{1,5})?\\b"},{cN:"number",b:"\\b\\d+[kKmMgGdshdwy]*\\b",r:0},r]};return{aliases:["nginxconf"],c:[e.HCM,{b:e.UIR+"\\s",e:";|{",rB:!0,c:[{cN:"title",b:e.UIR,starts:b}],r:0}],i:"[^\\s\\}]"}});hljs.registerLanguage("diff",function(e){return{aliases:["patch"],c:[{cN:"chunk",r:10,v:[{b:/^@@ +\-\d+,\d+ +\+\d+,\d+ +@@$/},{b:/^\*\*\* +\d+,\d+ +\*\*\*\*$/},{b:/^\-\-\- +\d+,\d+ +\-\-\-\-$/}]},{cN:"header",v:[{b:/Index: /,e:/$/},{b:/=====/,e:/=====$/},{b:/^\-\-\-/,e:/$/},{b:/^\*{3} /,e:/$/},{b:/^\+\+\+/,e:/$/},{b:/\*{5}/,e:/\*{5}$/}]},{cN:"addition",b:"^\\+",e:"$"},{cN:"deletion",b:"^\\-",e:"$"},{cN:"change",b:"^\\!",e:"$"}]}});hljs.registerLanguage("http",function(t){return{aliases:["https"],i:"\\S",c:[{cN:"status",b:"^HTTP/[0-9\\.]+",e:"$",c:[{cN:"number",b:"\\b\\d{3}\\b"}]},{cN:"request",b:"^[A-Z]+ (.*?) HTTP/[0-9\\.]+$",rB:!0,e:"$",c:[{cN:"string",b:" ",e:" ",eB:!0,eE:!0}]},{cN:"attribute",b:"^\\w",e:": ",eE:!0,i:"\\n|\\s|=",starts:{cN:"string",e:"$"}},{b:"\\n\\n",starts:{sL:[],eW:!0}}]}});hljs.registerLanguage("python",function(e){var r={cN:"prompt",b:/^(>>>|\.\.\.) /},b={cN:"string",c:[e.BE],v:[{b:/(u|b)?r?'''/,e:/'''/,c:[r],r:10},{b:/(u|b)?r?"""/,e:/"""/,c:[r],r:10},{b:/(u|r|ur)'/,e:/'/,r:10},{b:/(u|r|ur)"/,e:/"/,r:10},{b:/(b|br)'/,e:/'/},{b:/(b|br)"/,e:/"/},e.ASM,e.QSM]},a={cN:"number",r:0,v:[{b:e.BNR+"[lLjJ]?"},{b:"\\b(0o[0-7]+)[lLjJ]?"},{b:e.CNR+"[lLjJ]?"}]},l={cN:"params",b:/\(/,e:/\)/,c:["self",r,a,b]};return{aliases:["py","gyp"],k:{keyword:"and elif is global as in if from raise for except finally print import pass return exec else break not with class assert yield try while continue del or def lambda async await nonlocal|10 None True False",built_in:"Ellipsis NotImplemented"},i:/(<\/|->|\?)/,c:[r,a,b,e.HCM,{v:[{cN:"function",bK:"def",r:10},{cN:"class",bK:"class"}],e:/:/,i:/[${=;\n,]/,c:[e.UTM,l]},{cN:"decorator",b:/^[\t ]*@/,e:/$/},{b:/\b(print|exec)\(/}]}});hljs.registerLanguage("makefile",function(e){var a={cN:"variable",b:/\$\(/,e:/\)/,c:[e.BE]};return{aliases:["mk","mak"],c:[e.HCM,{b:/^\w+\s*\W*=/,rB:!0,r:0,starts:{cN:"constant",e:/\s*\W*=/,eE:!0,starts:{e:/$/,r:0,c:[a]}}},{cN:"title",b:/^[\w]+:\s*$/},{cN:"phony",b:/^\.PHONY:/,e:/$/,k:".PHONY",l:/[\.\w]+/},{b:/^\t+/,e:/$/,r:0,c:[e.QSM,a]}]}});hljs.registerLanguage("json",function(e){var t={literal:"true false null"},i=[e.QSM,e.CNM],l={cN:"value",e:",",eW:!0,eE:!0,c:i,k:t},c={b:"{",e:"}",c:[{cN:"attribute",b:'\\s*"',e:'"\\s*:\\s*',eB:!0,eE:!0,c:[e.BE],i:"\\n",starts:l}],i:"\\S"},n={b:"\\[",e:"\\]",c:[e.inherit(l,{cN:null})],i:"\\S"};return i.splice(i.length,0,c,n),{c:i,k:t,i:"\\S"}});hljs.registerLanguage("css",function(e){var c="[a-zA-Z-][a-zA-Z0-9_-]*",a={cN:"function",b:c+"\\(",rB:!0,eE:!0,e:"\\("},r={cN:"rule",b:/[A-Z\_\.\-]+\s*:/,rB:!0,e:";",eW:!0,c:[{cN:"attribute",b:/\S/,e:":",eE:!0,starts:{cN:"value",eW:!0,eE:!0,c:[a,e.CSSNM,e.QSM,e.ASM,e.CBCM,{cN:"hexcolor",b:"#[0-9A-Fa-f]+"},{cN:"important",b:"!important"}]}}]};return{cI:!0,i:/[=\/|'\$]/,c:[e.CBCM,{cN:"id",b:/\#[A-Za-z0-9_-]+/},{cN:"class",b:/\.[A-Za-z0-9_-]+/},{cN:"attr_selector",b:/\[/,e:/\]/,i:"$"},{cN:"pseudo",b:/:(:)?[a-zA-Z0-9\_\-\+\(\)"']+/},{cN:"at_rule",b:"@(font-face|page)",l:"[a-z-]+",k:"font-face page"},{cN:"at_rule",b:"@",e:"[{;]",c:[{cN:"keyword",b:/\S+/},{b:/\s/,eW:!0,eE:!0,r:0,c:[a,e.ASM,e.QSM,e.CSSNM]}]},{cN:"tag",b:c,r:0},{cN:"rules",b:"{",e:"}",i:/\S/,c:[e.CBCM,r]}]}});hljs.registerLanguage("scss",function(e){var t="[a-zA-Z-][a-zA-Z0-9_-]*",i={cN:"variable",b:"(\\$"+t+")\\b"},r={cN:"function",b:t+"\\(",rB:!0,eE:!0,e:"\\("},o={cN:"hexcolor",b:"#[0-9A-Fa-f]+"};({cN:"attribute",b:"[A-Z\\_\\.\\-]+",e:":",eE:!0,i:"[^\\s]",starts:{cN:"value",eW:!0,eE:!0,c:[r,o,e.CSSNM,e.QSM,e.ASM,e.CBCM,{cN:"important",b:"!important"}]}});return{cI:!0,i:"[=/|']",c:[e.CLCM,e.CBCM,r,{cN:"id",b:"\\#[A-Za-z0-9_-]+",r:0},{cN:"class",b:"\\.[A-Za-z0-9_-]+",r:0},{cN:"attr_selector",b:"\\[",e:"\\]",i:"$"},{cN:"tag",b:"\\b(a|abbr|acronym|address|area|article|aside|audio|b|base|big|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|command|datalist|dd|del|details|dfn|div|dl|dt|em|embed|fieldset|figcaption|figure|footer|form|frame|frameset|(h[1-6])|head|header|hgroup|hr|html|i|iframe|img|input|ins|kbd|keygen|label|legend|li|link|map|mark|meta|meter|nav|noframes|noscript|object|ol|optgroup|option|output|p|param|pre|progress|q|rp|rt|ruby|samp|script|section|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|tt|ul|var|video)\\b",r:0},{cN:"pseudo",b:":(visited|valid|root|right|required|read-write|read-only|out-range|optional|only-of-type|only-child|nth-of-type|nth-last-of-type|nth-last-child|nth-child|not|link|left|last-of-type|last-child|lang|invalid|indeterminate|in-range|hover|focus|first-of-type|first-line|first-letter|first-child|first|enabled|empty|disabled|default|checked|before|after|active)"},{cN:"pseudo",b:"::(after|before|choices|first-letter|first-line|repeat-index|repeat-item|selection|value)"},i,{cN:"attribute",b:"\\b(z-index|word-wrap|word-spacing|word-break|width|widows|white-space|visibility|vertical-align|unicode-bidi|transition-timing-function|transition-property|transition-duration|transition-delay|transition|transform-style|transform-origin|transform|top|text-underline-position|text-transform|text-shadow|text-rendering|text-overflow|text-indent|text-decoration-style|text-decoration-line|text-decoration-color|text-decoration|text-align-last|text-align|tab-size|table-layout|right|resize|quotes|position|pointer-events|perspective-origin|perspective|page-break-inside|page-break-before|page-break-after|padding-top|padding-right|padding-left|padding-bottom|padding|overflow-y|overflow-x|overflow-wrap|overflow|outline-width|outline-style|outline-offset|outline-color|outline|orphans|order|opacity|object-position|object-fit|normal|none|nav-up|nav-right|nav-left|nav-index|nav-down|min-width|min-height|max-width|max-height|mask|marks|margin-top|margin-right|margin-left|margin-bottom|margin|list-style-type|list-style-position|list-style-image|list-style|line-height|letter-spacing|left|justify-content|initial|inherit|ime-mode|image-orientation|image-resolution|image-rendering|icon|hyphens|height|font-weight|font-variant-ligatures|font-variant|font-style|font-stretch|font-size-adjust|font-size|font-language-override|font-kerning|font-feature-settings|font-family|font|float|flex-wrap|flex-shrink|flex-grow|flex-flow|flex-direction|flex-basis|flex|filter|empty-cells|display|direction|cursor|counter-reset|counter-increment|content|column-width|column-span|column-rule-width|column-rule-style|column-rule-color|column-rule|column-gap|column-fill|column-count|columns|color|clip-path|clip|clear|caption-side|break-inside|break-before|break-after|box-sizing|box-shadow|box-decoration-break|bottom|border-width|border-top-width|border-top-style|border-top-right-radius|border-top-left-radius|border-top-color|border-top|border-style|border-spacing|border-right-width|border-right-style|border-right-color|border-right|border-radius|border-left-width|border-left-style|border-left-color|border-left|border-image-width|border-image-source|border-image-slice|border-image-repeat|border-image-outset|border-image|border-color|border-collapse|border-bottom-width|border-bottom-style|border-bottom-right-radius|border-bottom-left-radius|border-bottom-color|border-bottom|border|background-size|background-repeat|background-position|background-origin|background-image|background-color|background-clip|background-attachment|background-blend-mode|background|backface-visibility|auto|animation-timing-function|animation-play-state|animation-name|animation-iteration-count|animation-fill-mode|animation-duration|animation-direction|animation-delay|animation|align-self|align-items|align-content)\\b",i:"[^\\s]"},{cN:"value",b:"\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b"},{cN:"value",b:":",e:";",c:[r,i,o,e.CSSNM,e.QSM,e.ASM,{cN:"important",b:"!important"}]},{cN:"at_rule",b:"@",e:"[{;]",k:"mixin include extend for if else each while charset import debug media page content font-face namespace warn",c:[r,i,e.QSM,e.ASM,o,e.CSSNM,{cN:"preprocessor",b:"\\s[A-Za-z0-9_.-]+",r:0}]}]}});hljs.registerLanguage("bash",function(e){var t={cN:"variable",v:[{b:/\$[\w\d#@][\w\d_]*/},{b:/\$\{(.*?)}/}]},s={cN:"string",b:/"/,e:/"/,c:[e.BE,t,{cN:"variable",b:/\$\(/,e:/\)/,c:[e.BE]}]},a={cN:"string",b:/'/,e:/'/};return{aliases:["sh","zsh"],l:/-?[a-z\.]+/,k:{keyword:"if then else elif fi for while in do done case esac function",literal:"true false",built_in:"break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp",operator:"-ne -eq -lt -gt -f -d -e -s -l -a"},c:[{cN:"shebang",b:/^#![^\n]+sh\s*$/,r:10},{cN:"function",b:/\w[\w\d_]*\s*\(\s*\)\s*\{/,rB:!0,c:[e.inherit(e.TM,{b:/\w[\w\d_]*/})],r:0},e.HCM,e.NM,s,a,t]}});hljs.registerLanguage("xml",function(t){var s="[A-Za-z0-9\\._:-]+",c={b:/<\?(php)?(?!\w)/,e:/\?>/,sL:"php"},e={eW:!0,i:/</,r:0,c:[c,{cN:"attribute",b:s,r:0},{b:"=",r:0,c:[{cN:"value",c:[c],v:[{b:/"/,e:/"/},{b:/'/,e:/'/},{b:/[^\s\/>]+/}]}]}]};return{aliases:["html","xhtml","rss","atom","xsl","plist"],cI:!0,c:[{cN:"doctype",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},t.C("<!--","-->",{r:10}),{cN:"cdata",b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{cN:"tag",b:"<style(?=\\s|>|$)",e:">",k:{title:"style"},c:[e],starts:{e:"</style>",rE:!0,sL:"css"}},{cN:"tag",b:"<script(?=\\s|>|$)",e:">",k:{title:"script"},c:[e],starts:{e:"</script>",rE:!0,sL:["actionscript","javascript","handlebars"]}},c,{cN:"pi",b:/<\?\w+/,e:/\?>/,r:10},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"title",b:/[^ \/><\n\t]+/,r:0},e]}]}});hljs.registerLanguage("markdown",function(e){return{aliases:["md","mkdown","mkd"],c:[{cN:"header",v:[{b:"^#{1,6}",e:"$"},{b:"^.+?\\n[=-]{2,}$"}]},{b:"<",e:">",sL:"xml",r:0},{cN:"bullet",b:"^([*+-]|(\\d+\\.))\\s+"},{cN:"strong",b:"[*_]{2}.+?[*_]{2}"},{cN:"emphasis",v:[{b:"\\*.+?\\*"},{b:"_.+?_",r:0}]},{cN:"blockquote",b:"^>\\s+",e:"$"},{cN:"code",v:[{b:"`.+?`"},{b:"^( {4}|	)",e:"$",r:0}]},{cN:"horizontal_rule",b:"^[-\\*]{3,}",e:"$"},{b:"\\[.+?\\][\\(\\[].*?[\\)\\]]",rB:!0,c:[{cN:"link_label",b:"\\[",e:"\\]",eB:!0,rE:!0,r:0},{cN:"link_url",b:"\\]\\(",e:"\\)",eB:!0,eE:!0},{cN:"link_reference",b:"\\]\\[",e:"\\]",eB:!0,eE:!0}],r:10},{b:"^\\[.+\\]:",rB:!0,c:[{cN:"link_reference",b:"\\[",e:"\\]:",eB:!0,eE:!0,starts:{cN:"link_url",e:"$"}}]}]}});hljs.registerLanguage("java",function(e){var a=e.UIR+"(<"+e.UIR+">)?",t="false synchronized int abstract float private char boolean static null if const for true while long strictfp finally protected import native final void enum else break transient catch instanceof byte super volatile case assert short package default double public try this switch continue throws protected public private",c="\\b(0[bB]([01]+[01_]+[01]+|[01]+)|0[xX]([a-fA-F0-9]+[a-fA-F0-9_]+[a-fA-F0-9]+|[a-fA-F0-9]+)|(([\\d]+[\\d_]+[\\d]+|[\\d]+)(\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))?|\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))([eE][-+]?\\d+)?)[lLfF]?",r={cN:"number",b:c,r:0};return{aliases:["jsp"],k:t,i:/<\/|#/,c:[e.C("/\\*\\*","\\*/",{r:0,c:[{cN:"doctag",b:"@[A-Za-z]+"}]}),e.CLCM,e.CBCM,e.ASM,e.QSM,{cN:"class",bK:"class interface",e:/[{;=]/,eE:!0,k:"class interface",i:/[:"\[\]]/,c:[{bK:"extends implements"},e.UTM]},{bK:"new throw return else",r:0},{cN:"function",b:"("+a+"\\s+)+"+e.UIR+"\\s*\\(",rB:!0,e:/[{;=]/,eE:!0,k:t,c:[{b:e.UIR+"\\s*\\(",rB:!0,r:0,c:[e.UTM]},{cN:"params",b:/\(/,e:/\)/,k:t,r:0,c:[e.ASM,e.QSM,e.CNM,e.CBCM]},e.CLCM,e.CBCM]},r,{cN:"annotation",b:"@[A-Za-z]+"}]}});hljs.registerLanguage("coffeescript",function(e){var c={keyword:"in if for while finally new do return else break catch instanceof throw try this switch continue typeof delete debugger super then unless until loop of by when and or is isnt not",literal:"true false null undefined yes no on off",built_in:"npm require console print module global window document"},n="[A-Za-z$_][0-9A-Za-z$_]*",r={cN:"subst",b:/#\{/,e:/}/,k:c},t=[e.BNM,e.inherit(e.CNM,{starts:{e:"(\\s*/)?",r:0}}),{cN:"string",v:[{b:/'''/,e:/'''/,c:[e.BE]},{b:/'/,e:/'/,c:[e.BE]},{b:/"""/,e:/"""/,c:[e.BE,r]},{b:/"/,e:/"/,c:[e.BE,r]}]},{cN:"regexp",v:[{b:"///",e:"///",c:[r,e.HCM]},{b:"//[gim]*",r:0},{b:/\/(?![ *])(\\\/|.)*?\/[gim]*(?=\W|$)/}]},{cN:"property",b:"@"+n},{b:"`",e:"`",eB:!0,eE:!0,sL:"javascript"}];r.c=t;var s=e.inherit(e.TM,{b:n}),i="(\\(.*\\))?\\s*\\B[-=]>",o={cN:"params",b:"\\([^\\(]",rB:!0,c:[{b:/\(/,e:/\)/,k:c,c:["self"].concat(t)}]};return{aliases:["coffee","cson","iced"],k:c,i:/\/\*/,c:t.concat([e.C("###","###"),e.HCM,{cN:"function",b:"^\\s*"+n+"\\s*=\\s*"+i,e:"[-=]>",rB:!0,c:[s,o]},{b:/[:\(,=]\s*/,r:0,c:[{cN:"function",b:i,e:"[-=]>",rB:!0,c:[o]}]},{cN:"class",bK:"class",e:"$",i:/[:="\[\]]/,c:[{bK:"extends",eW:!0,i:/[:="\[\]]/,c:[s]},s]},{cN:"attribute",b:n+":",e:":",rB:!0,rE:!0,r:0}])}});hljs.registerLanguage("php",function(e){var c={cN:"variable",b:"\\$+[a-zA-Z_-ÿ][a-zA-Z0-9_-ÿ]*"},a={cN:"preprocessor",b:/<\?(php)?|\?>/},i={cN:"string",c:[e.BE,a],v:[{b:'b"',e:'"'},{b:"b'",e:"'"},e.inherit(e.ASM,{i:null}),e.inherit(e.QSM,{i:null})]},t={v:[e.BNM,e.CNM]};return{aliases:["php3","php4","php5","php6"],cI:!0,k:"and include_once list abstract global private echo interface as static endswitch array null if endwhile or const for endforeach self var while isset public protected exit foreach throw elseif include __FILE__ empty require_once do xor return parent clone use __CLASS__ __LINE__ else break print eval new catch __METHOD__ case exception default die require __FUNCTION__ enddeclare final try switch continue endfor endif declare unset true false trait goto instanceof insteadof __DIR__ __NAMESPACE__ yield finally",c:[e.CLCM,e.HCM,e.C("/\\*","\\*/",{c:[{cN:"doctag",b:"@[A-Za-z]+"},a]}),e.C("__halt_compiler.+?;",!1,{eW:!0,k:"__halt_compiler",l:e.UIR}),{cN:"string",b:/<<<['"]?\w+['"]?$/,e:/^\w+;?$/,c:[e.BE,{cN:"subst",v:[{b:/\$\w+/},{b:/\{\$/,e:/\}/}]}]},a,c,{b:/(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/},{cN:"function",bK:"function",e:/[;{]/,eE:!0,i:"\\$|\\[|%",c:[e.UTM,{cN:"params",b:"\\(",e:"\\)",c:["self",c,e.CBCM,i,t]}]},{cN:"class",bK:"class interface",e:"{",eE:!0,i:/[:\(\$"]/,c:[{bK:"extends implements"},e.UTM]},{bK:"namespace",e:";",i:/[\.']/,c:[e.UTM]},{bK:"use",e:";",c:[e.UTM]},{b:"=>"},i,t]}});hljs.registerLanguage("javascript",function(e){return{aliases:["js"],k:{keyword:"in of if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const export super debugger as async await",literal:"true false null undefined NaN Infinity",built_in:"eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError Number Math Date String RegExp Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect Promise"},c:[{cN:"pi",r:10,b:/^\s*['"]use (strict|asm)['"]/},e.ASM,e.QSM,{cN:"string",b:"`",e:"`",c:[e.BE,{cN:"subst",b:"\\$\\{",e:"\\}"}]},e.CLCM,e.CBCM,{cN:"number",v:[{b:"\\b(0[bB][01]+)"},{b:"\\b(0[oO][0-7]+)"},{b:e.CNR}],r:0},{b:"("+e.RSR+"|\\b(case|return|throw)\\b)\\s*",k:"return throw case",c:[e.CLCM,e.CBCM,e.RM,{b:/</,e:/>\s*[);\]]/,r:0,sL:"xml"}],r:0},{cN:"function",bK:"function",e:/\{/,eE:!0,c:[e.inherit(e.TM,{b:/[A-Za-z$_][0-9A-Za-z$_]*/}),{cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,c:[e.CLCM,e.CBCM]}],i:/\[|%/},{b:/\$[(.]/},{b:"\\."+e.IR,r:0},{bK:"import",e:"[;$]",k:"import from as",c:[e.ASM,e.QSM]},{cN:"class",bK:"class",e:/[{;=]/,eE:!0,i:/[:"\[\]]/,c:[{bK:"extends"},e.UTM]}],i:/#/}});hljs.registerLanguage("ini",function(e){var c={cN:"string",c:[e.BE],v:[{b:"'''",e:"'''",r:10},{b:'"""',e:'"""',r:10},{b:'"',e:'"'},{b:"'",e:"'"}]};return{aliases:["toml"],cI:!0,i:/\S/,c:[e.C(";","$"),e.HCM,{cN:"title",b:/^\s*\[+/,e:/\]+/},{cN:"setting",b:/^[a-z0-9\[\]_-]+\s*=\s*/,e:"$",c:[{cN:"value",eW:!0,k:"on off true false yes no",c:[{cN:"variable",v:[{b:/\$[\w\d"][\w\d_]*/},{b:/\$\{(.*?)}/}]},c,{cN:"number",b:/([\+\-]+)?[\d]+_[\d_]+/},e.NM],r:0}]}]}});hljs.registerLanguage("apache",function(e){var r={cN:"number",b:"[\\$%]\\d+"};return{aliases:["apacheconf"],cI:!0,c:[e.HCM,{cN:"tag",b:"</?",e:">"},{cN:"keyword",b:/\w+/,r:0,k:{common:"order deny allow setenv rewriterule rewriteengine rewritecond documentroot sethandler errordocument loadmodule options header listen serverroot servername"},starts:{e:/$/,r:0,k:{literal:"on off all"},c:[{cN:"sqbracket",b:"\\s\\[",e:"\\]$"},{cN:"cbracket",b:"[\\$%]\\{",e:"\\}",c:["self",r]},r,e.QSM]}}],i:/\S/}});hljs.registerLanguage("sql",function(e){var t=e.C("--","$");return{cI:!0,i:/[<>{}*]/,c:[{cN:"operator",bK:"begin end start commit rollback savepoint lock alter create drop rename call delete do handler insert load replace select truncate update set show pragma grant merge describe use explain help declare prepare execute deallocate release unlock purge reset change stop analyze cache flush optimize repair kill install uninstall checksum restore check backup revoke",e:/;/,eW:!0,k:{keyword:"abort abs absolute acc acce accep accept access accessed accessible account acos action activate add addtime admin administer advanced advise aes_decrypt aes_encrypt after agent aggregate ali alia alias allocate allow alter always analyze ancillary and any anydata anydataset anyschema anytype apply archive archived archivelog are as asc ascii asin assembly assertion associate asynchronous at atan atn2 attr attri attrib attribu attribut attribute attributes audit authenticated authentication authid authors auto autoallocate autodblink autoextend automatic availability avg backup badfile basicfile before begin beginning benchmark between bfile bfile_base big bigfile bin binary_double binary_float binlog bit_and bit_count bit_length bit_or bit_xor bitmap blob_base block blocksize body both bound buffer_cache buffer_pool build bulk by byte byteordermark bytes c cache caching call calling cancel capacity cascade cascaded case cast catalog category ceil ceiling chain change changed char_base char_length character_length characters characterset charindex charset charsetform charsetid check checksum checksum_agg child choose chr chunk class cleanup clear client clob clob_base clone close cluster_id cluster_probability cluster_set clustering coalesce coercibility col collate collation collect colu colum column column_value columns columns_updated comment commit compact compatibility compiled complete composite_limit compound compress compute concat concat_ws concurrent confirm conn connec connect connect_by_iscycle connect_by_isleaf connect_by_root connect_time connection consider consistent constant constraint constraints constructor container content contents context contributors controlfile conv convert convert_tz corr corr_k corr_s corresponding corruption cos cost count count_big counted covar_pop covar_samp cpu_per_call cpu_per_session crc32 create creation critical cross cube cume_dist curdate current current_date current_time current_timestamp current_user cursor curtime customdatum cycle d data database databases datafile datafiles datalength date_add date_cache date_format date_sub dateadd datediff datefromparts datename datepart datetime2fromparts day day_to_second dayname dayofmonth dayofweek dayofyear days db_role_change dbtimezone ddl deallocate declare decode decompose decrement decrypt deduplicate def defa defau defaul default defaults deferred defi defin define degrees delayed delegate delete delete_all delimited demand dense_rank depth dequeue des_decrypt des_encrypt des_key_file desc descr descri describ describe descriptor deterministic diagnostics difference dimension direct_load directory disable disable_all disallow disassociate discardfile disconnect diskgroup distinct distinctrow distribute distributed div do document domain dotnet double downgrade drop dumpfile duplicate duration e each edition editionable editions element ellipsis else elsif elt empty enable enable_all enclosed encode encoding encrypt end end-exec endian enforced engine engines enqueue enterprise entityescaping eomonth error errors escaped evalname evaluate event eventdata events except exception exceptions exchange exclude excluding execu execut execute exempt exists exit exp expire explain export export_set extended extent external external_1 external_2 externally extract f failed failed_login_attempts failover failure far fast feature_set feature_value fetch field fields file file_name_convert filesystem_like_logging final finish first first_value fixed flash_cache flashback floor flush following follows for forall force form forma format found found_rows freelist freelists freepools fresh from from_base64 from_days ftp full function g general generated get get_format get_lock getdate getutcdate global global_name globally go goto grant grants greatest group group_concat group_id grouping grouping_id groups gtid_subtract guarantee guard handler hash hashkeys having hea head headi headin heading heap help hex hierarchy high high_priority hosts hour http i id ident_current ident_incr ident_seed identified identity idle_time if ifnull ignore iif ilike ilm immediate import in include including increment index indexes indexing indextype indicator indices inet6_aton inet6_ntoa inet_aton inet_ntoa infile initial initialized initially initrans inmemory inner innodb input insert install instance instantiable instr interface interleaved intersect into invalidate invisible is is_free_lock is_ipv4 is_ipv4_compat is_not is_not_null is_used_lock isdate isnull isolation iterate java join json json_exists k keep keep_duplicates key keys kill l language large last last_day last_insert_id last_value lax lcase lead leading least leaves left len lenght length less level levels library like like2 like4 likec limit lines link list listagg little ln load load_file lob lobs local localtime localtimestamp locate locator lock locked log log10 log2 logfile logfiles logging logical logical_reads_per_call logoff logon logs long loop low low_priority lower lpad lrtrim ltrim m main make_set makedate maketime managed management manual map mapping mask master master_pos_wait match matched materialized max maxextents maximize maxinstances maxlen maxlogfiles maxloghistory maxlogmembers maxsize maxtrans md5 measures median medium member memcompress memory merge microsecond mid migration min minextents minimum mining minus minute minvalue missing mod mode model modification modify module monitoring month months mount move movement multiset mutex n name name_const names nan national native natural nav nchar nclob nested never new newline next nextval no no_write_to_binlog noarchivelog noaudit nobadfile nocheck nocompress nocopy nocycle nodelay nodiscardfile noentityescaping noguarantee nokeep nologfile nomapping nomaxvalue nominimize nominvalue nomonitoring none noneditionable nonschema noorder nopr nopro noprom nopromp noprompt norely noresetlogs noreverse normal norowdependencies noschemacheck noswitch not nothing notice notrim novalidate now nowait nth_value nullif nulls num numb numbe nvarchar nvarchar2 object ocicoll ocidate ocidatetime ociduration ociinterval ociloblocator ocinumber ociref ocirefcursor ocirowid ocistring ocitype oct octet_length of off offline offset oid oidindex old on online only opaque open operations operator optimal optimize option optionally or oracle oracle_date oradata ord ordaudio orddicom orddoc order ordimage ordinality ordvideo organization orlany orlvary out outer outfile outline output over overflow overriding p package pad parallel parallel_enable parameters parent parse partial partition partitions pascal passing password password_grace_time password_lock_time password_reuse_max password_reuse_time password_verify_function patch path patindex pctincrease pctthreshold pctused pctversion percent percent_rank percentile_cont percentile_disc performance period period_add period_diff permanent physical pi pipe pipelined pivot pluggable plugin policy position post_transaction pow power pragma prebuilt precedes preceding precision prediction prediction_cost prediction_details prediction_probability prediction_set prepare present preserve prior priority private private_sga privileges procedural procedure procedure_analyze processlist profiles project prompt protection public publishingservername purge quarter query quick quiesce quota quotename radians raise rand range rank raw read reads readsize rebuild record records recover recovery recursive recycle redo reduced ref reference referenced references referencing refresh regexp_like register regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy reject rekey relational relative relaylog release release_lock relies_on relocate rely rem remainder rename repair repeat replace replicate replication required reset resetlogs resize resource respect restore restricted result result_cache resumable resume retention return returning returns reuse reverse revoke right rlike role roles rollback rolling rollup round row row_count rowdependencies rowid rownum rows rtrim rules safe salt sample save savepoint sb1 sb2 sb4 scan schema schemacheck scn scope scroll sdo_georaster sdo_topo_geometry search sec_to_time second section securefile security seed segment select self sequence sequential serializable server servererror session session_user sessions_per_user set sets settings sha sha1 sha2 share shared shared_pool short show shrink shutdown si_averagecolor si_colorhistogram si_featurelist si_positionalcolor si_stillimage si_texture siblings sid sign sin size size_t sizes skip slave sleep smalldatetimefromparts smallfile snapshot some soname sort soundex source space sparse spfile split sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_small_result sql_variant_property sqlcode sqldata sqlerror sqlname sqlstate sqrt square standalone standby start starting startup statement static statistics stats_binomial_test stats_crosstab stats_ks_test stats_mode stats_mw_test stats_one_way_anova stats_t_test_ stats_t_test_indep stats_t_test_one stats_t_test_paired stats_wsr_test status std stddev stddev_pop stddev_samp stdev stop storage store stored str str_to_date straight_join strcmp strict string struct stuff style subdate subpartition subpartitions substitutable substr substring subtime subtring_index subtype success sum suspend switch switchoffset switchover sync synchronous synonym sys sys_xmlagg sysasm sysaux sysdate sysdatetimeoffset sysdba sysoper system system_user sysutcdatetime t table tables tablespace tan tdo template temporary terminated tertiary_weights test than then thread through tier ties time time_format time_zone timediff timefromparts timeout timestamp timestampadd timestampdiff timezone_abbr timezone_minute timezone_region to to_base64 to_date to_days to_seconds todatetimeoffset trace tracking transaction transactional translate translation treat trigger trigger_nestlevel triggers trim truncate try_cast try_convert try_parse type ub1 ub2 ub4 ucase unarchived unbounded uncompress under undo unhex unicode uniform uninstall union unique unix_timestamp unknown unlimited unlock unpivot unrecoverable unsafe unsigned until untrusted unusable unused update updated upgrade upped upper upsert url urowid usable usage use use_stored_outlines user user_data user_resources users using utc_date utc_timestamp uuid uuid_short validate validate_password_strength validation valist value values var var_samp varcharc vari varia variab variabl variable variables variance varp varraw varrawc varray verify version versions view virtual visible void wait wallet warning warnings week weekday weekofyear wellformed when whene whenev wheneve whenever where while whitespace with within without work wrapped xdb xml xmlagg xmlattributes xmlcast xmlcolattval xmlelement xmlexists xmlforest xmlindex xmlnamespaces xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltype xor year year_to_month years yearweek",literal:"true false null",built_in:"array bigint binary bit blob boolean char character date dec decimal float int int8 integer interval number numeric real record serial serial8 smallint text varchar varying void"},c:[{cN:"string",b:"'",e:"'",c:[e.BE,{b:"''"}]},{cN:"string",b:'"',e:'"',c:[e.BE,{b:'""'}]},{cN:"string",b:"`",e:"`",c:[e.BE]},e.CNM,e.CBCM,t]},e.CBCM,t]}});hljs.registerLanguage("typescript",function(e){var r={keyword:"in if for while finally var new function|0 do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const class public private protected get set super static implements enum export import declare type namespace abstract",literal:"true false null undefined NaN Infinity",built_in:"eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError Number Math Date String RegExp Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require module console window document any number boolean string void"};return{aliases:["ts"],k:r,c:[{cN:"pi",b:/^\s*['"]use strict['"]/,r:0},e.ASM,e.QSM,e.CLCM,e.CBCM,{cN:"number",v:[{b:"\\b(0[bB][01]+)"},{b:"\\b(0[oO][0-7]+)"},{b:e.CNR}],r:0},{b:"("+e.RSR+"|\\b(case|return|throw)\\b)\\s*",k:"return throw case",c:[e.CLCM,e.CBCM,e.RM],r:0},{cN:"function",b:"function",e:/[\{;]/,eE:!0,k:r,c:["self",e.inherit(e.TM,{b:/[A-Za-z$_][0-9A-Za-z$_]*/}),{cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,k:r,c:[e.CLCM,e.CBCM],i:/["'\(]/}],i:/\[|%/,r:0},{cN:"constructor",bK:"constructor",e:/\{/,eE:!0,r:10},{cN:"module",bK:"module",e:/\{/,eE:!0},{cN:"interface",bK:"interface",e:/\{/,eE:!0,k:"interface extends"},{b:/\$[(.]/},{b:"\\."+e.IR,r:0}]}});hljs.registerLanguage("perl",function(e){var t="getpwent getservent quotemeta msgrcv scalar kill dbmclose undef lc ma syswrite tr send umask sysopen shmwrite vec qx utime local oct semctl localtime readpipe do return format read sprintf dbmopen pop getpgrp not getpwnam rewinddir qqfileno qw endprotoent wait sethostent bless s|0 opendir continue each sleep endgrent shutdown dump chomp connect getsockname die socketpair close flock exists index shmgetsub for endpwent redo lstat msgctl setpgrp abs exit select print ref gethostbyaddr unshift fcntl syscall goto getnetbyaddr join gmtime symlink semget splice x|0 getpeername recv log setsockopt cos last reverse gethostbyname getgrnam study formline endhostent times chop length gethostent getnetent pack getprotoent getservbyname rand mkdir pos chmod y|0 substr endnetent printf next open msgsnd readdir use unlink getsockopt getpriority rindex wantarray hex system getservbyport endservent int chr untie rmdir prototype tell listen fork shmread ucfirst setprotoent else sysseek link getgrgid shmctl waitpid unpack getnetbyname reset chdir grep split require caller lcfirst until warn while values shift telldir getpwuid my getprotobynumber delete and sort uc defined srand accept package seekdir getprotobyname semop our rename seek if q|0 chroot sysread setpwent no crypt getc chown sqrt write setnetent setpriority foreach tie sin msgget map stat getlogin unless elsif truncate exec keys glob tied closedirioctl socket readlink eval xor readline binmode setservent eof ord bind alarm pipe atan2 getgrent exp time push setgrent gt lt or ne m|0 break given say state when",r={cN:"subst",b:"[$@]\\{",e:"\\}",k:t},s={b:"->{",e:"}"},n={cN:"variable",v:[{b:/\$\d/},{b:/[\$%@](\^\w\b|#\w+(::\w+)*|{\w+}|\w+(::\w*)*)/},{b:/[\$%@][^\s\w{]/,r:0}]},o=[e.BE,r,n],i=[n,e.HCM,e.C("^\\=\\w","\\=cut",{eW:!0}),s,{cN:"string",c:o,v:[{b:"q[qwxr]?\\s*\\(",e:"\\)",r:5},{b:"q[qwxr]?\\s*\\[",e:"\\]",r:5},{b:"q[qwxr]?\\s*\\{",e:"\\}",r:5},{b:"q[qwxr]?\\s*\\|",e:"\\|",r:5},{b:"q[qwxr]?\\s*\\<",e:"\\>",r:5},{b:"qw\\s+q",e:"q",r:5},{b:"'",e:"'",c:[e.BE]},{b:'"',e:'"'},{b:"`",e:"`",c:[e.BE]},{b:"{\\w+}",c:[],r:0},{b:"-?\\w+\\s*\\=\\>",c:[],r:0}]},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{b:"(\\/\\/|"+e.RSR+"|\\b(split|return|print|reverse|grep)\\b)\\s*",k:"split return print reverse grep",r:0,c:[e.HCM,{cN:"regexp",b:"(s|tr|y)/(\\\\.|[^/])*/(\\\\.|[^/])*/[a-z]*",r:10},{cN:"regexp",b:"(m|qr)?/",e:"/[a-z]*",c:[e.BE],r:0}]},{cN:"sub",bK:"sub",e:"(\\s*\\(.*?\\))?[;{]",r:5},{cN:"operator",b:"-\\w\\b",r:0},{b:"^__DATA__$",e:"^__END__$",sL:"mojolicious",c:[{b:"^@@.*",e:"$",cN:"comment"}]}];return r.c=i,s.c=i,{aliases:["pl"],k:t,c:i}});

/**
 * ngPanel by @matsko
 * https://github.com/matsko/ng-panel
 */
DocsApp

  .directive('ngPanel', ['$animate', function($animate) {
    return {
      restrict: 'EA',
      transclude: 'element',
      terminal: true,
      compile: function(elm, attrs) {
        var attrExp = attrs.ngPanel || attrs['for'];
        var regex = /^(\S+)(?:\s+track by (.+?))?$/;
        var match = regex.exec(attrExp);

        var watchCollection = true;
        var objExp = match[1];
        var trackExp = match[2];
        if (trackExp) {
          watchCollection = false;
        } else {
          trackExp = match[1];
        }

        return function(scope, $element, attrs, ctrl, $transclude) {
          var previousElement, previousScope;
          scope[watchCollection ? '$watchCollection' : '$watch'](trackExp, function(value) {
            if (previousElement) {
              $animate.leave(previousElement);
            }
            if (previousScope) {
              previousScope.$destroy();
              previousScope = null;
            }
            var record = watchCollection ? value : scope.$eval(objExp);
            previousScope = scope.$new();
            $transclude(previousScope, function(element) {
              previousElement = element;
              $animate.enter(element, null, $element);
            });
          });
        };
      }
    };
  }]);

DocsApp
.constant('SERVICES', [
  {
    "name": "$enConfig",
    "type": "service",
    "outputPath": "partials/api/enspire.ui.core/service/$enConfig.html",
    "url": "api/enspire.ui.core/service/$enConfig",
    "label": "$enConfig",
    "module": "enspire.ui.core",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/core/services/$enConfig.js",
    "hasDemo": false
  },
  {
    "name": "$uuid",
    "type": "service",
    "outputPath": "partials/api/enspire.ui.core/service/$uuid.html",
    "url": "api/enspire.ui.core/service/$uuid",
    "label": "$uuid",
    "module": "enspire.ui.core",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/core/services/$uuid.js"
  },
  {
    "name": "$uom",
    "type": "service",
    "outputPath": "partials/api/enspire.ui.core/service/$uom.html",
    "url": "api/enspire.ui.core/service/$uom",
    "label": "$uom",
    "module": "enspire.ui.core",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/core/services/$uom.js"
  },
  {
    "name": "$enDimensions",
    "type": "service",
    "outputPath": "partials/api/enspire.ui.core/service/$enDimensions.html",
    "url": "api/enspire.ui.core/service/$enDimensions",
    "label": "$enDimensions",
    "module": "enspire.ui.core",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/core/services/$enDimensions.js"
  },
  {
    "name": "$enPosition",
    "type": "service",
    "outputPath": "partials/api/enspire.ui.core/service/$enPosition.html",
    "url": "api/enspire.ui.core/service/$enPosition",
    "label": "$enPosition",
    "module": "enspire.ui.core",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/core/services/$enPosition.js"
  },
  {
    "name": "$enBase64",
    "type": "service",
    "outputPath": "partials/api/enspire.ui.core/service/$enBase64.html",
    "url": "api/enspire.ui.core/service/$enBase64",
    "label": "$enBase64",
    "module": "enspire.ui.core",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/core/services/$enBase64.js"
  },
  {
    "name": "$enLocalStorageProvider",
    "type": "service",
    "outputPath": "partials/api/enspire.ui.core/service/$enLocalStorageProvider.html",
    "url": "api/enspire.ui.core/service/$enLocalStorageProvider",
    "label": "$enLocalStorageProvider",
    "module": "enspire.ui.core",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/core/services/$enLocalStorageProvider.js"
  },
  {
    "name": "$enLocalStorage",
    "type": "service",
    "outputPath": "partials/api/enspire.ui.core/service/$enLocalStorage.html",
    "url": "api/enspire.ui.core/service/$enLocalStorage",
    "label": "$enLocalStorage",
    "module": "enspire.ui.core",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/core/services/$enLocalStorage.js"
  },
  {
    "name": "$enTouch",
    "type": "service",
    "outputPath": "partials/api/enspire.ui.core/service/$enTouch.html",
    "url": "api/enspire.ui.core/service/$enTouch",
    "label": "$enTouch",
    "module": "enspire.ui.core",
    "githubUrl": "https://github.com/envistaInteractive/enspire.ui/tree/develop/src/core/services/$enTouch.js"
  }
]);
